# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
# 1 "/home/giulianob/gcc_git_gnu/build_temp/gcc//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
# 20 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
# 1 "./bconfig.h" 1


# 1 "./auto-host.h" 1
# 4 "./bconfig.h" 2

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h" 1
# 40 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h"
extern "C" {
# 433 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h"
}
# 6 "./bconfig.h" 2
# 21 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 1
# 32 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4

# 40 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 33 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 43 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 44 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) throw ();







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) throw () __asm__ ("" "__isoc99_sscanf")

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4
# 873 "/usr/include/stdio.h" 3 4
}
# 47 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 103 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"

# 103 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 187 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}
# 209 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h" 1
# 57 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 174 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int isalnum (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalnum; }
extern __inline __attribute__ ((__gnu_inline__)) int isalpha (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalpha; }
extern __inline __attribute__ ((__gnu_inline__)) int iscntrl (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IScntrl; }
extern __inline __attribute__ ((__gnu_inline__)) int isdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISdigit; }
extern __inline __attribute__ ((__gnu_inline__)) int islower (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISlower; }
extern __inline __attribute__ ((__gnu_inline__)) int isgraph (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISgraph; }
extern __inline __attribute__ ((__gnu_inline__)) int isprint (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISprint; }
extern __inline __attribute__ ((__gnu_inline__)) int ispunct (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISpunct; }
extern __inline __attribute__ ((__gnu_inline__)) int isspace (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISspace; }
extern __inline __attribute__ ((__gnu_inline__)) int isupper (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISupper; }
extern __inline __attribute__ ((__gnu_inline__)) int isxdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISxdigit; }

extern __inline __attribute__ ((__gnu_inline__)) int isblank (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISblank; }
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) tolower (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) toupper (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 237 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 238 "/usr/include/ctype.h" 2 3 4
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 123 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h" 2
# 210 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 214 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 235 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/c++/10/cstring" 1 3
# 39 "/usr/include/c++/10/cstring" 3
       
# 40 "/usr/include/c++/10/cstring" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 1 3
# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 284 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 522 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 1 3
# 523 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/cpu_defines.h" 1 3
# 526 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3
# 42 "/usr/include/c++/10/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}
# 99 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 204 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}
# 261 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 369 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4
}
# 43 "/usr/include/c++/10/cstring" 2 3
# 71 "/usr/include/c++/10/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/include/c++/10/cstring" 3

}
}
# 236 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/c++/10/new" 1 3
# 38 "/usr/include/c++/10/new" 3
       
# 39 "/usr/include/c++/10/new" 3


# 1 "/usr/include/c++/10/exception" 1 3
# 33 "/usr/include/c++/10/exception" 3
       
# 34 "/usr/include/c++/10/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception.h" 1 3
# 34 "/usr/include/c++/10/bits/exception.h" 3
       
# 35 "/usr/include/c++/10/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/10/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/10/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/include/c++/10/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 137 "/usr/include/c++/10/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/10/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/10/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/typeinfo" 1 3
# 32 "/usr/include/c++/10/typeinfo" 3
       
# 33 "/usr/include/c++/10/typeinfo" 3



# 1 "/usr/include/c++/10/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/10/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/10/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/10/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/10/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/10/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/usr/include/c++/10/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/new" 1 3
# 41 "/usr/include/c++/10/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 118 "/usr/include/c++/10/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 145 "/usr/include/c++/10/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
# 213 "/usr/include/c++/10/bits/exception_ptr.h" 3
      return exception_ptr();

    }


}

}

#pragma GCC visibility pop
# 148 "/usr/include/c++/10/exception" 2 3
# 1 "/usr/include/c++/10/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/10/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/10/bits/move.h" 1 3
# 38 "/usr/include/c++/10/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/10/type_traits" 1 3
# 32 "/usr/include/c++/10/type_traits" 3
       
# 33 "/usr/include/c++/10/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/10/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 188 "/usr/include/c++/10/type_traits" 3
  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 284 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 364 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 604 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 623 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 770 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };
# 1001 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1410 "/usr/include/c++/10/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1508 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1730 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1806 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1884 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1932 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2067 "/usr/include/c++/10/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2106 "/usr/include/c++/10/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2239 "/usr/include/c++/10/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2624 "/usr/include/c++/10/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop
# 3455 "/usr/include/c++/10/type_traits" 3

}
# 58 "/usr/include/c++/10/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/10/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/include/c++/10/exception" 2 3
# 42 "/usr/include/c++/10/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/include/c++/10/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 174 "/usr/include/c++/10/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 230 "/usr/include/c++/10/new" 3
#pragma GCC visibility pop
# 237 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/c++/10/utility" 1 3
# 58 "/usr/include/c++/10/utility" 3
       
# 59 "/usr/include/c++/10/utility" 3
# 69 "/usr/include/c++/10/utility" 3
# 1 "/usr/include/c++/10/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/10/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/10/utility" 2 3
# 1 "/usr/include/c++/10/bits/stl_pair.h" 1 3
# 69 "/usr/include/c++/10/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/10/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/10/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/10/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };
# 464 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/10/bits/stl_pair.h" 3

}
# 71 "/usr/include/c++/10/utility" 2 3





# 1 "/usr/include/c++/10/initializer_list" 1 3
# 33 "/usr/include/c++/10/initializer_list" 3
       
# 34 "/usr/include/c++/10/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/usr/include/c++/10/utility" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/include/c++/10/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 473 "/usr/include/c++/10/utility" 3

}
# 238 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 259 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/c++/10/stdlib.h" 1 3
# 36 "/usr/include/c++/10/stdlib.h" 3
# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 75 "/usr/include/c++/10/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 610 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/10/cstdlib" 2 3

# 1 "/usr/include/c++/10/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/10/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/10/bits/std_abs.h" 3
# 46 "/usr/include/c++/10/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/10/cstdlib" 2 3
# 121 "/usr/include/c++/10/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/10/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/10/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/10/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 260 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2







# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 268 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 295 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) throw ();
# 1171 "/usr/include/unistd.h" 2 3 4

}
# 296 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 196 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/10/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4
extern "C" {


# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 210 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();



extern int raise (int __sig) throw ();



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 170 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 185 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     throw ();
# 286 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[(64 + 1)];
extern const char *const sys_siglist[(64 + 1)];



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 292 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) throw ();




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 328 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));






extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();





# 1 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 375 "/usr/include/signal.h" 2 3 4

}
# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 300 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 307 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 337 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 66 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) throw () __attribute__ ((__nonnull__ (1)));







extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 187 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 338 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 339 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 350 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern "C" {




extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) throw ();





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) throw ();
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) throw ();
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4
}
# 351 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 397 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/wait.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern "C" {
# 77 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern __pid_t wait (int *__stat_loc);
# 100 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
# 121 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);






struct rusage;






extern __pid_t wait3 (int *__stat_loc, int __options,
        struct rusage * __usage) throw ();




extern __pid_t wait4 (__pid_t __pid, int *__stat_loc, int __options,
        struct rusage *__usage) throw ();



}
# 398 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 428 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-map-flags-generic.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 113 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 3 4
extern "C" {



int memfd_create (const char *__name, unsigned int __flags) throw ();



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) throw ();





int pkey_alloc (unsigned int __flags, unsigned int __access_rights) throw ();



int pkey_set (int __key, unsigned int __access_rights) throw ();



int pkey_get (int __key) throw ();



int pkey_free (int __key) throw ();



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) throw ();

}
# 114 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 2 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4




extern "C" {
# 57 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
# 70 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (const void *__addr, size_t __len) throw ();


extern int munlock (const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
# 133 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);

}
# 429 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 440 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/resource.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/resource.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 3 4
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };


    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/usr/include/x86_64-linux-gnu/bits/resource.h" 2 3 4







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};


extern "C" {




extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) throw ();



}
# 25 "/usr/include/x86_64-linux-gnu/sys/resource.h" 2 3 4






extern "C" {
# 42 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
typedef int __rlimit_resource_t;
typedef int __rusage_who_t;
typedef int __priority_which_t;





extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) throw ();
# 61 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) throw ();






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) throw ();
# 81 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) throw ();




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();





extern int getpriority (__priority_which_t __which, id_t __who) throw ();



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     throw ();

}
# 441 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/times.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/times.h" 3 4
extern "C" {


struct tms
  {
    clock_t tms_utime;
    clock_t tms_stime;

    clock_t tms_cutime;
    clock_t tms_cstime;
  };






extern clock_t times (struct tms *__buffer) throw ();

}
# 445 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 453 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"

# 453 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 521 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4

# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 2 3 4
# 526 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/inttypes.h" 1 3 4
# 266 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__leaf__)) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__leaf__)) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const wchar_t * __restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__leaf__)) wcstoimax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const wchar_t *
          __restrict __nptr,
          wchar_t **
          __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__leaf__)) wcstoumax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 432 "/usr/include/inttypes.h" 3 4
}
# 530 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2




# 533 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 576 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}
# 599 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
extern "C" {


int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  throw () __attribute__ ((__nonnull__ (2, 5)));

}
# 40 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat (const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat (const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}






}
# 600 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 671 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h" 1
# 29 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h" 1
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"

# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"
extern "C" {


# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h" 1
# 40 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h" 2


typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, const void *);
extern void htab_remove_elt_with_hash (htab_t, const void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);




}
# 30 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h" 2


extern "C" {
# 84 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);


}
# 672 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 683 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4

# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4
extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();

}
# 28 "/usr/include/dlfcn.h" 2 3 4
# 44 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;







extern "C" {



extern void *dlopen (const char *__file, int __mode) throw ();



extern int dlclose (void *__handle) throw () __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) throw () __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) throw ();



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) throw ();





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     throw () __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) throw () __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     throw () __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;





  __extension__ union
  {
    Dl_serpath dls_serpath[0];
    Dl_serpath __dls_serpath_pad[1];
  };



} Dl_serinfo;



}
# 684 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 692 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h" 1
# 39 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"

# 39 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern "C" {





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 46 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h" 2
# 55 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 123 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);



extern int is_valid_fd (int fd);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 157 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 193 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 205 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char * getpwd (void);
# 218 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));




extern char *make_temp_file_with_prefix (const char *, const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 292 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1))) __attribute__ ((warn_unused_result));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (2))) __attribute__ ((warn_unused_result));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1, 2))) __attribute__ ((warn_unused_result));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 391 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 428 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 528 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 543 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 618 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 637 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);



extern void *bsearch_r (const void *, const void *,
   size_t, size_t,
   int (*)(const void *, const void *, void *),
   void *);
# 661 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
# 673 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 722 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 735 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 762 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
}
# 693 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 763 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern void fancy_abort (const char *, int, const char *)
      __attribute__ ((__noreturn__)) __attribute__ ((__cold__));
# 894 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        




        






        




        


        
# 963 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        






        
# 1055 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        
# 1073 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        


        



        
# 1091 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        
# 1107 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        



       
# 1224 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h" 1
# 77 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
typedef long __gcc_host_wide_int__;
# 141 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
static inline unsigned long
least_bit_hwi (unsigned long x)
{
  return (x & -x);
}



static inline bool
pow2_or_zerop (unsigned long x)
{
  return least_bit_hwi (x) == x;
}



static inline bool
pow2p_hwi (unsigned long x)
{
  return x && pow2_or_zerop (x);
}
# 184 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
static inline int
clz_hwi (unsigned long x)
{
  if (x == 0)
    return 64;

  return __builtin_clzl (x);





}

static inline int
ctz_hwi (unsigned long x)
{
  if (x == 0)
    return 64;

  return __builtin_ctzl (x);





}

static inline int
ffs_hwi (unsigned long x)
{

  return __builtin_ffsl (x);





}

static inline int
popcount_hwi (unsigned long x)
{

  return __builtin_popcountl (x);





}

static inline int
floor_log2 (unsigned long x)
{
  return 64 - 1 - clz_hwi (x);
}

static inline int
ceil_log2 (unsigned long x)
{
  return x == 0 ? 0 : floor_log2 (x - 1) + 1;
}

static inline int
exact_log2 (unsigned long x)
{
  return pow2p_hwi (x) ? ctz_hwi (x) : -1;
}







extern long abs_hwi (long);
extern unsigned long absu_hwi (long);
extern long gcd (long, long);
extern long pos_mul_hwi (long, long);
extern long mul_hwi (long, long);
extern long least_common_multiple (long, long);



static inline int
ctz_or_zero (unsigned long x)
{
  return ffs_hwi (x) - 1;
}



static inline long
sext_hwi (long src, unsigned int prec)
{
  if (prec == 64)
    return src;
  else

    {






      ((void)(!(prec < 64) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 291, __FUNCTION__), 0 : 0));
      int shift = 64 - prec;
      return ((long) ((unsigned long) src << shift)) >> shift;
    }
# 304 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
}


static inline unsigned long
zext_hwi (unsigned long src, unsigned int prec)
{
  if (prec == 64)
    return src;
  else
    {
      ((void)(!(prec < 64) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 314, __FUNCTION__), 0 : 0));
      return src & ((1UL << prec) - 1);
    }
}



inline long
abs_hwi (long x)
{
  ((void)(!(x != (long) (1UL << (64 - 1))) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 324, __FUNCTION__), 0 : 0));
  return x >= 0 ? x : -x;
}



inline unsigned long
absu_hwi (long x)
{
  return x >= 0 ? (unsigned long)x : -(unsigned long)x;
}
# 1225 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

typedef int sort_r_cmp_fn (const void *, const void *, void *);
void qsort_chk (void *, size_t, size_t, sort_r_cmp_fn *, void *);
void gcc_sort_r (void *, size_t, size_t, sort_r_cmp_fn *, void *);
void gcc_qsort (void *, size_t, size_t, int (*)(const void *, const void *));
void gcc_stablesort (void *, size_t, size_t,
       int (*)(const void *, const void *));
# 22 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/errors.h" 1
# 31 "/home/giulianob/gcc_git_gnu/gcc/gcc/errors.h"
extern void warning (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void error (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void fatal (const char *, ...) __attribute__ ((__noreturn__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void internal_error (const char *, ...) __attribute__ ((__noreturn__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern const char *trim_filename (const char *);

extern int have_error;
extern const char *progname;
# 23 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2

struct hook_desc { const char *doc, *type, *name, *param, *init, *docname; };
static struct hook_desc hook_array[] = {
# 34 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def" 1
# 24 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-hooks-macros.h" 1
# 25 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def" 2




{ 0, 0, "TARGET_INITIALIZER", 0, 0, "Target Hook" },



{ 0, 0, "TARGET_ASM_OUT", 0, 0, "Target Hook" },


{ "These target hooks are C string constants, describing the syntax in the\nassembler for grouping arithmetic expressions.  If not overridden, they\ndefault to normal parentheses, which is correct for most assemblers.", "const char *", "TARGET_ASM_" "open_paren", 0, "\"(\"", "Target Hook" },





{ 0, "const char *", "TARGET_ASM_" "close_paren", 0, "\")\"", "Target Hook" },


{ "@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_HI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_PSI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_SI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_PDI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_DI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_PTI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_ALIGNED_TI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_HI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_PSI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_SI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_PDI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_DI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_PTI_OP\n@deftypevrx {Target Hook} {const char *} TARGET_ASM_UNALIGNED_TI_OP\nThese hooks specify assembly directives for creating certain kinds\nof integer object.  The @code{TARGET_ASM_BYTE_OP} directive creates a\nbyte-sized object, the @code{TARGET_ASM_ALIGNED_HI_OP} one creates an\naligned two-byte object, and so on.  Any of the hooks may be\n@code{NULL}, indicating that no suitable directive is available.\n\nThe compiler will print these strings at the start of a new line,\nfollowed immediately by the object's initial value.  In most cases,\nthe string should contain a tab, a pseudo-op, and then another tab.", "const char *", "TARGET_ASM_" "byte_op", 0, "\"\\t.byte\\t\"", "Target Hook" },
# 71 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "struct asm_int_op", "TARGET_ASM_" "aligned_op", 0, "TARGET_ASM_ALIGNED_INT_OP", "Target Hook" },
{ "*", "struct asm_int_op", "TARGET_ASM_" "unaligned_op", 0, "TARGET_ASM_UNALIGNED_INT_OP", "Target Hook" },






{ "The @code{assemble_integer} function uses this hook to output an\ninteger object.  @var{x} is the object's value, @var{size} is its size\nin bytes and @var{aligned_p} indicates whether it is aligned.  The\nfunction should return @code{true} if it was able to output the\nobject.  If it returns false, @code{assemble_integer} will try to\nsplit the object into smaller parts.\n\nThe default implementation of this hook will use the\n@code{TARGET_ASM_BYTE_OP} family of strings, returning @code{false}\nwhen the relevant string is @code{NULL}.", "bool", "TARGET_ASM_" "integer", "(rtx x, unsigned int size, int aligned_p)", "default_assemble_integer", "Target Hook" },
# 97 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is used to emit assembly strings required by the target\nafter the .cfi_startproc directive.  The first argument is the file stream to\nwrite the strings to and the second argument is the function\'s declaration.  The\nexpected use is to add more .cfi_* directives.\n\nThe default is to not output any assembly strings.", "void", "TARGET_ASM_" "post_cfi_startproc", "(FILE *, tree)", "hook_void_FILEptr_tree", "Target Hook" },
# 110 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if the target assembler requires a special marker to\nterminate an initialized variable declaration.", "void", "TARGET_ASM_" "decl_end", "(void)", "hook_void_void", "Target Hook" },







{ "This target hook is a function to output to the stdio stream\n@var{stream} some commands that will make the label @var{name} global;\nthat is, available for reference from other files.\n\nThe default implementation relies on a proper definition of\n@code{GLOBAL_ASM_OP}.", "void", "TARGET_ASM_" "globalize_label", "(FILE *stream, const char *name)", "default_globalize_label", "Target Hook" },
# 130 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is a function to output to the stdio stream\n@var{stream} some commands that will make the name associated with @var{decl}\nglobal; that is, available for reference from other files.\n\nThe default implementation uses the TARGET_ASM_GLOBALIZE_LABEL target hook.", "void", "TARGET_ASM_" "globalize_decl_name", "(FILE *stream, tree decl)", "default_globalize_decl_name", "Target Hook" },
# 140 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is a function to output to the stdio stream\n@var{stream} some commands that will declare the name associated with\n@var{decl} which is not defined in the current translation unit.  Most\nassemblers do not require anything to be output in this case.", "void", "TARGET_ASM_" "assemble_undefined_decl", "(FILE *stream, const char *name, const_tree decl)", "hook_void_FILEptr_constcharptr_const_tree", "Target Hook" },
# 154 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook emits a label at the beginning of each FDE@.  It\nshould be defined on targets where FDEs need special labels, and it\nshould write the appropriate label, for the FDE associated with the\nfunction declaration @var{decl}, to the stdio stream @var{stream}.\nThe third argument, @var{for_eh}, is a boolean: true if this is for an\nexception table.  The fourth argument, @var{empty}, is a boolean:\ntrue if this is a placeholder label for an omitted FDE@.\n\nThe default is that FDEs are not given nonlocal labels.", "void", "TARGET_ASM_" "emit_unwind_label", "(FILE *stream, tree decl, int for_eh, int empty)", "default_emit_unwind_label", "Target Hook" },
# 169 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook emits a label at the beginning of the exception table.\nIt should be defined on targets where it is desirable for the table\nto be broken up according to function.\n\nThe default is that no label is emitted.", "void", "TARGET_ASM_" "emit_except_table_label", "(FILE *stream)", "default_emit_except_table_label", "Target Hook" },
# 180 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If the target implements @code{TARGET_ASM_UNWIND_EMIT}, this hook may be used to emit a directive to install a personality hook into the unwind info.  This hook should not be used if dwarf2 unwind info is used.", "void", "TARGET_ASM_" "emit_except_personality", "(rtx personality)", "NULL", "Target Hook" },
# 189 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook emits assembly directives required to unwind the\ngiven instruction.  This is only used when @code{TARGET_EXCEPT_UNWIND_INFO}\nreturns @code{UI_TARGET}.", "void", "TARGET_ASM_" "unwind_emit", "(FILE *stream, rtx_insn *insn)", "NULL", "Target Hook" },







{ "True if the @code{TARGET_ASM_UNWIND_EMIT} hook should be called before the assembly for @var{insn} has been emitted, false if the hook should be called afterward.", "bool", "TARGET_ASM_" "unwind_emit_before_insn", 0, "true", "Target Hook" },
# 206 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "void", "TARGET_ASM_" "generate_internal_label", "(char *buf, const char *prefix, unsigned long labelno)", "default_generate_internal_label", "Target Hook" },






{ "A function to output to the stdio stream @var{stream} a label whose\nname is made from the string @var{prefix} and the number @var{labelno}.\n\nIt is absolutely essential that these labels be distinct from the labels\nused for user-level functions and variables.  Otherwise, certain programs\nwill have name conflicts with internal labels.\n\nIt is desirable to exclude internal labels from the symbol table of the\nobject file.  Most assemblers have a naming convention for labels that\nshould be excluded; on many systems, the letter @samp{L} at the\nbeginning of a label has this effect.  You should find out what\nconvention your system uses, and follow it.\n\nThe default version of this function utilizes @code{ASM_GENERATE_INTERNAL_LABEL}.", "void", "TARGET_ASM_" "internal_label", "(FILE *stream, const char *prefix, unsigned long labelno)", "default_internal_label", "Target Hook" },
# 233 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook to output to the stdio stream @var{file} any text necessary\nfor declaring the name @var{name} of a constant which is being defined.  This\ntarget hook is responsible for outputting the label definition (perhaps using\n@code{assemble_label}).  The argument @var{exp} is the value of the constant,\nand @var{size} is the size of the constant in bytes.  The @var{name}\nwill be an internal label.\n\nThe default version of this target hook, define the @var{name} in the\nusual manner as a label (by means of @code{assemble_label}).\n\nYou may wish to use @code{ASM_OUTPUT_TYPE_DIRECTIVE} in this target hook.", "void", "TARGET_ASM_" "declare_constant_name", "(FILE *file, const char *name, const_tree expr, HOST_WIDE_INT size)", "default_asm_declare_constant_name", "Target Hook" },
# 250 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to output a reference from a frame unwinding table to\nthe type_info object identified by @var{sym}.  It should return @code{true}\nif the reference was output.  Returning @code{false} will cause the\nreference to be output using the normal Dwarf2 routines.", "bool", "TARGET_ASM_" "ttype", "(rtx sym)", "hook_bool_rtx_false", "Target Hook" },
# 261 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is a function to output to @var{asm_out_file} some\ncommands that will make the symbol(s) associated with @var{decl} have\nhidden, protected or internal visibility as specified by @var{visibility}.", "void", "TARGET_ASM_" "assemble_visibility", "(tree decl, int visibility)", "default_assemble_visibility", "Target Hook" },







{ "Generate a patchable area at the function start, consisting of\n@var{patch_area_size} NOP instructions.  If the target supports named\nsections and if @var{record_p} is true, insert a pointer to the current\nlocation in the table of patchable functions.  The default implementation\nof the hook places the table of pointers in the special section named\n@code{__patchable_function_entries}.", "void", "TARGET_ASM_" "print_patchable_function_entry", "(FILE *file, unsigned HOST_WIDE_INT patch_area_size, bool record_p)", "default_print_patchable_function_entry", "Target Hook" },
# 281 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, a function that outputs the assembler code for entry to a\nfunction.  The prologue is responsible for setting up the stack frame,\ninitializing the frame pointer register, saving registers that must be\nsaved, and allocating @var{size} additional bytes of storage for the\nlocal variables.  @var{file} is a stdio stream to which the assembler\ncode should be output.\n\nThe label for the beginning of the function need not be output by this\nmacro.  That has already been done when the macro is run.\n\n@findex regs_ever_live\nTo determine which registers to save, the macro can refer to the array\n@code{regs_ever_live}: element @var{r} is nonzero if hard register\n@var{r} is used anywhere within the function.  This implies the function\nprologue should save register @var{r}, provided it is not one of the\ncall-used registers.  (@code{TARGET_ASM_FUNCTION_EPILOGUE} must likewise use\n@code{regs_ever_live}.)\n\nOn machines that have ``register windows'', the function entry code does\nnot save on the stack the registers that are in the windows, even if\nthey are supposed to be preserved by function calls; instead it takes\nappropriate steps to ``push'' the register stack, if any non-call-used\nregisters are used in the function.\n\n@findex frame_pointer_needed\nOn machines where functions may or may not have frame-pointers, the\nfunction entry code must vary accordingly; it must set up the frame\npointer if one is wanted, and not otherwise.  To determine whether a\nframe pointer is in wanted, the macro can refer to the variable\n@code{frame_pointer_needed}.  The variable's value will be 1 at run\ntime in a function that needs a frame pointer.  @xref{Elimination}.\n\nThe function entry code is responsible for allocating any stack space\nrequired for the function.  This stack space consists of the regions\nlisted below.  In most cases, these regions are allocated in the\norder listed, with the last listed region closest to the top of the\nstack (the lowest address if @code{STACK_GROWS_DOWNWARD} is defined, and\nthe highest address if it is not defined).  You can use a different order\nfor a machine if doing so is more convenient or required for\ncompatibility reasons.  Except in cases where required by standard\nor by a debugger, there is no reason why the stack layout used by GCC\nneed agree with that used by other compilers for a machine.", "void", "TARGET_ASM_" "function_prologue", "(FILE *file)", "default_function_pro_epilogue", "Target Hook" },
# 329 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, a function that outputs assembler code at the end of a\nprologue.  This should be used when the function prologue is being\nemitted as RTL, and you have some extra assembler that needs to be\nemitted.  @xref{prologue instruction pattern}.", "void", "TARGET_ASM_" "function_end_prologue", "(FILE *file)", "no_asm_to_stream", "Target Hook" },
# 339 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, a function that outputs assembler code at the start of an\nepilogue.  This should be used when the function epilogue is being\nemitted as RTL, and you have some extra assembler that needs to be\nemitted.  @xref{epilogue instruction pattern}.", "void", "TARGET_ASM_" "function_begin_epilogue", "(FILE *file)", "no_asm_to_stream", "Target Hook" },
# 349 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, a function that outputs the assembler code for exit from a\nfunction.  The epilogue is responsible for restoring the saved\nregisters and stack pointer to their values when the function was\ncalled, and returning control to the caller.  This macro takes the\nsame argument as the macro @code{TARGET_ASM_FUNCTION_PROLOGUE}, and the\nregisters to restore are determined from @code{regs_ever_live} and\n@code{CALL_USED_REGISTERS} in the same way.\n\nOn some machines, there is a single instruction that does all the work\nof returning from the function.  On these machines, give that\ninstruction the name @samp{return} and do not define the macro\n@code{TARGET_ASM_FUNCTION_EPILOGUE} at all.\n\nDo not define a pattern named @samp{return} if you want the\n@code{TARGET_ASM_FUNCTION_EPILOGUE} to be used.  If you want the target\nswitches to control whether return instructions or epilogues are used,\ndefine a @samp{return} pattern with a validity condition that tests the\ntarget switches appropriately.  If the @samp{return} pattern's validity\ncondition is false, epilogues will be used.\n\nOn machines where functions may or may not have frame-pointers, the\nfunction exit code must vary accordingly.  Sometimes the code for these\ntwo cases is completely different.  To determine whether a frame pointer\nis wanted, the macro can refer to the variable\n@code{frame_pointer_needed}.  The variable's value will be 1 when compiling\na function that needs a frame pointer.\n\nNormally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and\n@code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially.\nThe C variable @code{current_function_is_leaf} is nonzero for such a\nfunction.  @xref{Leaf Functions}.\n\nOn some machines, some functions pop their arguments on exit while\nothers leave that for the caller to do.  For example, the 68020 when\ngiven @option{-mrtd} pops arguments in functions that take a fixed\nnumber of arguments.\n\n@findex pops_args\n@findex crtl->args.pops_args\nYour definition of the macro @code{RETURN_POPS_ARGS} decides which\nfunctions pop their own arguments.  @code{TARGET_ASM_FUNCTION_EPILOGUE}\nneeds to know what was decided.  The number of bytes of the current\nfunction's arguments that this function should pop is available in\n@code{crtl->args.pops_args}.  @xref{Scalar Return}.", "void", "TARGET_ASM_" "function_epilogue", "(FILE *file)", "default_function_pro_epilogue", "Target Hook" },
# 399 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if you need to do something special to set up the\n@file{varasm.c} sections, or if your target has some special sections\nof its own that you need to create.\n\nGCC calls this hook after processing the command line, but before writing\nany assembly code, and before calling any of the section-returning hooks\ndescribed below.", "void", "TARGET_ASM_" "init_sections", "(void)", "hook_void_void", "Target Hook" },
# 414 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output assembly directives to switch to section @var{name}.  The section\nshould have attributes as specified by @var{flags}, which is a bit mask\nof the @code{SECTION_*} flags defined in @file{output.h}.  If @var{decl}\nis non-NULL, it is the @code{VAR_DECL} or @code{FUNCTION_DECL} with which\nthis section is associated.", "void", "TARGET_ASM_" "named_section", "(const char *name, unsigned int flags, tree decl)", "default_no_named_section", "Target Hook" },
# 426 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook can be used to encode ELF section flags for which no letter\ncode has been defined in the assembler.  It is called by\n@code{default_asm_named_section} whenever the section flags need to be\nemitted in the assembler output.  If the hook returns true, then the\nnumerical value for ELF section flags should be calculated from\n@var{flags} and saved in @var{*num}; the value is printed out instead of the\nnormal sequence of letter codes.  If the hook is not defined, or if it\nreturns false, then @var{num} is ignored and the traditional letter sequence\nis emitted.", "bool", "TARGET_ASM_" "elf_flags_numeric", "(unsigned int flags, unsigned int *num)", "hook_bool_uint_uintp_false", "Target Hook" },
# 447 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return preferred text (sub)section for function @var{decl}.\nMain purpose of this function is to separate cold, normal and hot\nfunctions. @var{startup} is true when function is known to be used only\nat startup (from static constructors or it is @code{main()}).\n@var{exit} is true when function is known to be used only at exit\n(from static destructors).\nReturn NULL if function should go to default text section.", "section *", "TARGET_ASM_" "function_section", "(tree decl, enum node_frequency freq, bool startup, bool exit)", "default_function_section", "Target Hook" },
# 460 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Used by the target to emit any assembler directives or additional  labels needed when a function is partitioned between different  sections.  Output should be written to @var{file}.  The function  decl is available as @var{decl} and the new section is `cold' if  @var{new_is_cold} is @code{true}.", "void", "TARGET_ASM_" "function_switched_text_sections", "(FILE *file, tree decl, bool new_is_cold)", "default_function_switched_text_sections", "Target Hook" },
# 474 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return a mask describing how relocations should be treated when\nselecting sections.  Bit 1 should be set if global relocations\nshould be placed in a read-write section; bit 0 should be set if\nlocal relocations should be placed in a read-write section.\n\nThe default version of this function returns 3 when @option{-fpic}\nis in effect, and 0 otherwise.  The hook is typically redefined\nwhen the target cannot support (some kinds of) dynamic relocations\nin read-only sections even in executables.", "int", "TARGET_ASM_" "reloc_rw_mask", "(void)", "default_reloc_rw_mask", "Target Hook" },
# 490 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true to generate ADDR_DIF_VEC table\nor false to generate ADDR_VEC table for jumps in case of -fPIC.\n\nThe default version of this function returns true if flag_pic\nequals true and false otherwise", "bool", "TARGET_ASM_" "generate_pic_addr_diff_vec", "(void)", "default_generate_pic_addr_diff_vec", "Target Hook" },
# 504 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the section into which @var{exp} should be placed.  You can\nassume that @var{exp} is either a @code{VAR_DECL} node or a constant of\nsome sort.  @var{reloc} indicates whether the initial value of @var{exp}\nrequires link-time relocations.  Bit 0 is set when variable contains\nlocal relocations only, while bit 1 is set for global relocations.\n@var{align} is the constant alignment in bits.\n\nThe default version of this function takes care of putting read-only\nvariables in @code{readonly_data_section}.\n\nSee also @var{USE_SELECT_SECTION_FOR_FUNCTIONS}.", "section *", "TARGET_ASM_" "select_section", "(tree exp, int reloc, unsigned HOST_WIDE_INT align)", "default_select_section", "Target Hook" },
# 522 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the section into which a constant @var{x}, of mode @var{mode},\nshould be placed.  You can assume that @var{x} is some kind of\nconstant in RTL@.  The argument @var{mode} is redundant except in the\ncase of a @code{const_int} rtx.  @var{align} is the constant alignment\nin bits.\n\nThe default version of this function takes care of putting symbolic\nconstants in @code{flag_pic} mode in @code{data_section} and everything\nelse in @code{readonly_data_section}.", "section *", "TARGET_ASM_" "select_rtx_section", "(machine_mode mode, rtx x, unsigned HOST_WIDE_INT align)", "default_select_rtx_section", "Target Hook" },
# 538 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Build up a unique section name, expressed as a @code{STRING_CST} node,\nand assign it to @samp{DECL_SECTION_NAME (@var{decl})}.\nAs with @code{TARGET_ASM_SELECT_SECTION}, @var{reloc} indicates whether\nthe initial value of @var{exp} requires link-time relocations.\n\nThe default version of this function appends the symbol name to the\nELF section name that would normally be used for the symbol.  For\nexample, the function @code{foo} would be placed in @code{.text.foo}.\nWhatever the actual target object format, this is often good enough.", "void", "TARGET_ASM_" "unique_section", "(tree decl, int reloc)", "default_unique_section", "Target Hook" },
# 553 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the readonly data section associated with\n@samp{DECL_SECTION_NAME (@var{decl})}.\nThe default version of this function selects @code{.gnu.linkonce.r.name} if\nthe function's section is @code{.gnu.linkonce.t.name}, @code{.rodata.name}\nif function is in @code{.text.name}, and the normal readonly-data section\notherwise.", "section *", "TARGET_ASM_" "function_rodata_section", "(tree decl)", "default_function_rodata_section", "Target Hook" },
# 566 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Usually, the compiler uses the prefix @code{\".rodata\"} to construct\nsection names for mergeable constant data.  Define this macro to override\nthe string if a different section name should be used.", "const char *", "TARGET_ASM_" "mergeable_rodata_prefix", 0, "\".rodata\"", "Target Hook" },







{ "Return the section that should be used for transactional memory clone  tables.", "section *", "TARGET_ASM_" "tm_clone_table_section", "(void)", "default_clone_table_section", "Target Hook" },






{ "If defined, a function that outputs assembler code to arrange to call\nthe function referenced by @var{symbol} at initialization time.\n\nAssume that @var{symbol} is a @code{SYMBOL_REF} for a function taking\nno arguments and with no return value.  If the target supports initialization\npriorities, @var{priority} is a value between 0 and @code{MAX_INIT_PRIORITY};\notherwise it must be @code{DEFAULT_INIT_PRIORITY}.\n\nIf this macro is not defined by the target, a suitable default will\nbe chosen if (1) the target supports arbitrary section names, (2) the\ntarget defines @code{CTORS_SECTION_ASM_OP}, or (3) @code{USE_COLLECT2}\nis not defined.", "void", "TARGET_ASM_" "constructor", "(rtx symbol, int priority)", "NULL", "Target Hook" },
# 598 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This is like @code{TARGET_ASM_CONSTRUCTOR} but used for termination\nfunctions rather than initialization functions.", "void", "TARGET_ASM_" "destructor", "(rtx symbol, int priority)", "NULL", "Target Hook" },
# 609 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A function that outputs the assembler code for a thunk\nfunction, used to implement C++ virtual function calls with multiple\ninheritance.  The thunk acts as a wrapper around a virtual function,\nadjusting the implicit object parameter before handing control off to\nthe real function.\n\nFirst, emit code to add the integer @var{delta} to the location that\ncontains the incoming first argument.  Assume that this argument\ncontains a pointer, and is the one used to pass the @code{this} pointer\nin C++.  This is the incoming argument @emph{before} the function prologue,\ne.g.@: @samp{%o0} on a sparc.  The addition must preserve the values of\nall other incoming arguments.\n\nThen, if @var{vcall_offset} is nonzero, an additional adjustment should be\nmade after adding @code{delta}.  In particular, if @var{p} is the\nadjusted pointer, the following adjustment should be made:\n\n@smallexample\np += (*((ptrdiff_t **)p))[vcall_offset/sizeof(ptrdiff_t)]\n@end smallexample\n\nAfter the additions, emit code to jump to @var{function}, which is a\n@code{FUNCTION_DECL}.  This is a direct pure jump, not a call, and does\nnot touch the return address.  Hence returning from @var{FUNCTION} will\nreturn to whoever called the current @samp{thunk}.\n\nThe effect must be as if @var{function} had been called directly with\nthe adjusted first argument.  This macro is responsible for emitting all\nof the code for a thunk function; @code{TARGET_ASM_FUNCTION_PROLOGUE}\nand @code{TARGET_ASM_FUNCTION_EPILOGUE} are not invoked.\n\nThe @var{thunk_fndecl} is redundant.  (@var{delta} and @var{function}\nhave already been extracted from it.)  It might possibly be useful on\nsome targets, but probably not.\n\nIf you do not define this macro, the target-independent code in the C++\nfront end will generate a less efficient heavyweight thunk that calls\n@var{function} instead of jumping to it.  The generic approach does\nnot support varargs.", "void", "TARGET_ASM_" "output_mi_thunk", "(FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, tree function)", "NULL", "Target Hook" },
# 660 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A function that returns true if TARGET_ASM_OUTPUT_MI_THUNK would be able\nto output the assembler code for the thunk function specified by the\narguments it is passed, and false otherwise.  In the latter case, the\ngeneric approach will be used by the C++ front end, with the limitations\npreviously exposed.", "bool", "TARGET_ASM_" "can_output_mi_thunk", "(const_tree thunk_fndecl, HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, const_tree function)", "hook_bool_const_tree_hwi_hwi_const_tree_false", "Target Hook" },
# 673 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output to @code{asm_out_file} any text which the assembler expects to\nfind at the beginning of a file.  The default behavior is controlled\nby two flags, documented below.  Unless your target's assembler is\nquite unusual, if you override the default, you should call\n@code{default_file_start} at some point in your target hook.  This\nlets other target files rely on these variables.", "void", "TARGET_ASM_" "file_start", "(void)", "default_file_start", "Target Hook" },
# 685 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output to @code{asm_out_file} any text which the assembler expects\nto find at the end of a file.  The default is to output nothing.", "void", "TARGET_ASM_" "file_end", "(void)", "hook_void_void", "Target Hook" },
# 694 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output to @code{asm_out_file} any text which the assembler expects\nto find at the start of an LTO section.  The default is to output\nnothing.", "void", "TARGET_ASM_" "lto_start", "(void)", "hook_void_void", "Target Hook" },
# 704 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output to @code{asm_out_file} any text which the assembler expects\nto find at the end of an LTO section.  The default is to output\nnothing.", "void", "TARGET_ASM_" "lto_end", "(void)", "hook_void_void", "Target Hook" },
# 714 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output to @code{asm_out_file} any text which is needed before emitting\nunwind info and debug info at the end of a file.  Some targets emit\nhere PIC setup thunks that cannot be emitted at the end of file,\nbecause they couldn't have unwind info then.  The default is to output\nnothing.", "void", "TARGET_ASM_" "code_end", "(void)", "hook_void_void", "Target Hook" },
# 726 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is a function to output to @var{asm_out_file} an assembler\npseudo-op to declare a library function name external.  The name of the\nlibrary function is given by @var{symref}, which is a @code{symbol_ref}.", "void", "TARGET_ASM_" "external_libcall", "(rtx symref)", "default_external_libcall", "Target Hook" },
# 736 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is a function to output to @var{asm_out_file} an assembler\ndirective to annotate @var{symbol} as used.  The Darwin target uses the\n.no_dead_code_strip directive.", "void", "TARGET_ASM_" "mark_decl_preserved", "(const char *symbol)", "hook_void_constcharptr", "Target Hook" },
# 745 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Provides the target with the ability to record the gcc command line\nswitches that have been passed to the compiler, and options that are\nenabled.  The @var{type} argument specifies what is being recorded.\nIt can take the following values:\n\n@table @gcctabopt\n@item SWITCH_TYPE_PASSED\n@var{text} is a command line switch that has been set by the user.\n\n@item SWITCH_TYPE_ENABLED\n@var{text} is an option which has been enabled.  This might be as a\ndirect result of a command line switch, or because it is enabled by\ndefault or because it has been enabled as a side effect of a different\ncommand line switch.  For example, the @option{-O2} switch enables\nvarious different individual optimization passes.\n\n@item SWITCH_TYPE_DESCRIPTIVE\n@var{text} is either NULL or some descriptive text which should be\nignored.  If @var{text} is NULL then it is being used to warn the\ntarget hook that either recording is starting or ending.  The first\ntime @var{type} is SWITCH_TYPE_DESCRIPTIVE and @var{text} is NULL, the\nwarning is for start up and the second time the warning is for\nwind down.  This feature is to allow the target hook to make any\nnecessary preparations before it starts to record switches and to\nperform any necessary tidying up after it has finished recording\nswitches.\n\n@item SWITCH_TYPE_LINE_START\nThis option can be ignored by this target hook.\n\n@item  SWITCH_TYPE_LINE_END\nThis option can be ignored by this target hook.\n@end table\n\nThe hook's return value must be zero.  Other return values may be\nsupported in the future.\n\nBy default this hook is set to NULL, but an example implementation is\nprovided for ELF based targets.  Called @var{elf_record_gcc_switches},\nit records the switches as ASCII text inside a new, string mergeable\nsection in the assembler output file.  The name of the new section is\nprovided by the @code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION} target\nhook.", "int", "TARGET_ASM_" "record_gcc_switches", "(print_switch_type type, const char *text)", "NULL", "Target Hook" },
# 797 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This is the name of the section that will be created by the example\nELF implementation of the @code{TARGET_ASM_RECORD_GCC_SWITCHES} target\nhook.", "const char *", "TARGET_ASM_" "record_gcc_switches_section", 0, "\".GCC.command.line\"", "Target Hook" },







{ "Write the assembly code to define section anchor @var{x}, which is a\n@code{SYMBOL_REF} for which @samp{SYMBOL_REF_ANCHOR_P (@var{x})} is true.\nThe hook is called with the assembly output position set to the beginning\nof @code{SYMBOL_REF_BLOCK (@var{x})}.\n\nIf @code{ASM_OUTPUT_DEF} is available, the hook's default definition uses\nit to define the symbol as @samp{. + SYMBOL_REF_BLOCK_OFFSET (@var{x})}.\nIf @code{ASM_OUTPUT_DEF} is not available, the hook's default definition\nis @code{NULL}, which disables the use of section anchors altogether.", "void", "TARGET_ASM_" "output_anchor", "(rtx x)", "default_asm_output_anchor", "Target Hook" },
# 819 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output a string based on @var{name}, suitable for the @samp{#ident}  directive, or the equivalent directive or pragma in non-C-family languages.  If this hook is not defined, nothing is output for the @samp{#ident}  directive.", "void", "TARGET_ASM_" "output_ident", "(const char *name)", "hook_void_constcharptr", "Target Hook" },
# 829 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook is a function which outputs a DTP-relative\nreference to the given TLS symbol of the specified size.", "void", "TARGET_ASM_" "output_dwarf_dtprel", "(FILE *file, int size, rtx x)", "NULL", "Target Hook" },







{ "If defined, this target hook is a function which is executed just after the\noutput of assembler code for @var{insn}, to change the mode of the assembler\nif necessary.\n\nHere the argument @var{opvec} is the vector containing the operands\nextracted from @var{insn}, and @var{noperands} is the number of\nelements of the vector which contain meaningful data for this insn.\nThe contents of this vector are what was used to convert the insn\ntemplate into assembler code, so you can change the assembler mode\nby checking the contents of the vector.", "void", "TARGET_ASM_" "final_postscan_insn", "(FILE *file, rtx_insn *insn, rtx *opvec, int noperands)", "NULL", "Target Hook" },
# 853 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by @code{assemble_trampoline_template} to output,\non the stream @var{f}, assembler code for a block of data that contains\nthe constant parts of a trampoline.  This code should not include a\nlabel---the label is taken care of automatically.\n\nIf you do not define this hook, it means no template is needed\nfor the target.  Do not define this hook on systems where the block move\ncode to copy the trampoline into place would be larger than the code\nto generate it on the spot.", "void", "TARGET_ASM_" "trampoline_template", "(FILE *f)", "NULL", "Target Hook" },
# 867 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Output DWARF debugging information which indicates that filename @var{name} is the current source file to the stdio stream @var{file}.\n \n This target hook need not be defined if the standard form of output for the file format in use is appropriate.", "void", "TARGET_ASM_" "output_source_filename", "(FILE *file, const char *name)", "default_asm_output_source_filename", "Target Hook" },
# 877 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook to recognize @var{rtx} patterns that @code{output_addr_const}\ncan't deal with, and output assembly code to @var{file} corresponding to\nthe pattern @var{x}.  This may be used to allow machine-dependent\n@code{UNSPEC}s to appear within constants.\n\nIf target hook fails to recognize a pattern, it must return @code{false},\nso that a standard error message is printed.  If it prints an error message\nitself, by calling, for example, @code{output_operand_lossage}, it may just\nreturn @code{true}.", "bool", "TARGET_ASM_" "output_addr_const_extra", "(FILE *file, rtx x)", "hook_bool_FILEptr_rtx_false", "Target Hook" },
# 900 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "void", "TARGET_" "print_operand", "(FILE *file, rtx x, int code)", "default_print_operand", "Target Hook" },
# 909 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "void", "TARGET_" "print_operand_address", "(FILE *file, machine_mode mode, rtx addr)", "default_print_operand_address", "Target Hook" },
# 919 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "bool", "TARGET_" "print_operand_punct_valid_p", "(unsigned char code)", "default_print_operand_punct_valid_p", "Target Hook" },







{ "Given a symbol @var{name}, perform same mangling as @code{varasm.c}'s @code{assemble_name}, but in memory rather than to a file stream, returning result as an @code{IDENTIFIER_NODE}.  Required for correct LTO symtabs.  The default implementation calls the @code{TARGET_STRIP_NAME_ENCODING} hook and then prepends the @code{USER_LABEL_PREFIX}, if any.", "tree", "TARGET_" "mangle_assembler_name", "(const char *name)", "default_mangle_assembler_name", "Target Hook" },
# 937 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },





{ 0, 0, "TARGET_SCHED", 0, 0, "Target Hook" },




{ "This function corrects the value of @var{cost} based on the\nrelationship between @var{insn} and @var{dep_insn} through a\ndependence of type dep_type, and strength @var{dw}.  It should return the new\nvalue.  The default is to make no adjustment to @var{cost}.  This can be\nused for example to specify to the scheduler using the traditional pipeline\ndescription that an output- or anti-dependence does not incur the same cost\nas a data-dependence.  If the scheduler using the automaton based pipeline\ndescription, the cost of anti-dependence is zero and the cost of\noutput-dependence is maximum of one and the difference of latency\ntimes of the first and the second insns.  If these values are not\nacceptable, you could use the hook to modify them too.  See also\n@pxref{Processor pipeline description}.", "int", "TARGET_SCHED_" "adjust_cost", "(rtx_insn *insn, int dep_type1, rtx_insn *dep_insn, int cost, unsigned int dw)", "NULL", "Target Hook" },
# 967 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook adjusts the integer scheduling priority @var{priority} of\n@var{insn}.  It should return the new priority.  Increase the priority to\nexecute @var{insn} earlier, reduce the priority to execute @var{insn}\nlater.  Do not define this hook if you do not need to adjust the\nscheduling priorities of insns.", "int", "TARGET_SCHED_" "adjust_priority", "(rtx_insn *insn, int priority)", "NULL", "Target Hook" },
# 979 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the maximum number of instructions that can ever\nissue at the same time on the target machine.  The default is one.\nAlthough the insn scheduler can define itself the possibility of issue\nan insn on the same cycle, the value can serve as an additional\nconstraint to issue insns on the same simulated processor cycle (see\nhooks @samp{TARGET_SCHED_REORDER} and @samp{TARGET_SCHED_REORDER2}).\nThis value must be constant over the entire compilation.  If you need\nit to vary depending on what the instructions are, you must use\n@samp{TARGET_SCHED_VARIABLE_ISSUE}.", "int", "TARGET_SCHED_" "issue_rate", "(void)", "NULL", "Target Hook" },
# 994 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is executed by the scheduler after it has scheduled an insn\nfrom the ready list.  It should return the number of insns which can\nstill be issued in the current cycle.  The default is\n@samp{@w{@var{more} - 1}} for insns other than @code{CLOBBER} and\n@code{USE}, which normally are not counted against the issue rate.\nYou should define this hook if some insns take more machine resources\nthan others, so that fewer insns can follow them in the same cycle.\n@var{file} is either a null pointer, or a stdio stream to write any\ndebug output to.  @var{verbose} is the verbose level provided by\n@option{-fsched-verbose-@var{n}}.  @var{insn} is the instruction that\nwas scheduled.", "int", "TARGET_SCHED_" "variable_issue", "(FILE *file, int verbose, rtx_insn *insn, int more)", "NULL", "Target Hook" },
# 1010 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is executed by the scheduler at the beginning of each block of\ninstructions that are to be scheduled.  @var{file} is either a null\npointer, or a stdio stream to write any debug output to.  @var{verbose}\nis the verbose level provided by @option{-fsched-verbose-@var{n}}.\n@var{max_ready} is the maximum number of insns in the current scheduling\nregion that can be live at the same time.  This can be used to allocate\nscratch space if it is needed, e.g.@: by @samp{TARGET_SCHED_REORDER}.", "void", "TARGET_SCHED_" "init", "(FILE *file, int verbose, int max_ready)", "NULL", "Target Hook" },
# 1022 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is executed by the scheduler at the end of each block of\ninstructions that are to be scheduled.  It can be used to perform\ncleanup of any actions done by the other scheduling hooks.  @var{file}\nis either a null pointer, or a stdio stream to write any debug output\nto.  @var{verbose} is the verbose level provided by\n@option{-fsched-verbose-@var{n}}.", "void", "TARGET_SCHED_" "finish", "(FILE *file, int verbose)", "NULL", "Target Hook" },
# 1033 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is executed by the scheduler after function level initializations.\n@var{file} is either a null pointer, or a stdio stream to write any debug output to.\n@var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n@var{old_max_uid} is the maximum insn uid when scheduling begins.", "void", "TARGET_SCHED_" "init_global", "(FILE *file, int verbose, int old_max_uid)", "NULL", "Target Hook" },
# 1042 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This is the cleanup hook corresponding to @code{TARGET_SCHED_INIT_GLOBAL}.\n@var{file} is either a null pointer, or a stdio stream to write any debug output to.\n@var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.", "void", "TARGET_SCHED_" "finish_global", "(FILE *file, int verbose)", "NULL", "Target Hook" },
# 1051 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is executed by the scheduler after it has scheduled the ready\nlist, to allow the machine description to reorder it (for example to\ncombine two small instructions together on @samp{VLIW} machines).\n@var{file} is either a null pointer, or a stdio stream to write any\ndebug output to.  @var{verbose} is the verbose level provided by\n@option{-fsched-verbose-@var{n}}.  @var{ready} is a pointer to the ready\nlist of instructions that are ready to be scheduled.  @var{n_readyp} is\na pointer to the number of elements in the ready list.  The scheduler\nreads the ready list in reverse order, starting with\n@var{ready}[@var{*n_readyp} @minus{} 1] and going to @var{ready}[0].  @var{clock}\nis the timer tick of the scheduler.  You may modify the ready list and\nthe number of ready insns.  The return value is the number of insns that\ncan issue this cycle; normally this is just @code{issue_rate}.  See also\n@samp{TARGET_SCHED_REORDER2}.", "int", "TARGET_SCHED_" "reorder", "(FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock)", "NULL", "Target Hook" },
# 1069 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Like @samp{TARGET_SCHED_REORDER}, but called at a different time.  That\nfunction is called whenever the scheduler starts a new cycle.  This one\nis called once per iteration over a cycle, immediately after\n@samp{TARGET_SCHED_VARIABLE_ISSUE}; it can reorder the ready list and\nreturn the number of insns to be scheduled in the same cycle.  Defining\nthis hook can be useful if there are frequent situations where\nscheduling one insn causes other insns to become ready in the same\ncycle.  These other insns can then be taken into account properly.", "int", "TARGET_SCHED_" "reorder2", "(FILE *file, int verbose, rtx_insn **ready, int *n_readyp, int clock)", "NULL", "Target Hook" },
# 1081 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to check whether target platform supports macro fusion.", "bool", "TARGET_SCHED_" "macro_fusion_p", "(void)", "NULL", "Target Hook" },




{ "This hook is used to check whether two insns should be macro fused for\na target microarchitecture. If this hook returns true for the given insn pair\n(@var{prev} and @var{curr}), the scheduler will put them into a sched\ngroup, and they will not be scheduled apart.  The two insns will be either\ntwo SET insns or a compare and a conditional jump and this hook should\nvalidate any dependencies needed to fuse the two insns together.", "bool", "TARGET_SCHED_" "macro_fusion_pair_p", "(rtx_insn *prev, rtx_insn *curr)", "NULL", "Target Hook" },
# 1099 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called after evaluation forward dependencies of insns in\nchain given by two parameter values (@var{head} and @var{tail}\ncorrespondingly) but before insns scheduling of the insn chain.  For\nexample, it can be used for better insn classification if it requires\nanalysis of dependencies.  This hook can use backward and forward\ndependencies of the insn scheduler because they are already\ncalculated.", "void", "TARGET_SCHED_" "dependencies_evaluation_hook", "(rtx_insn *head, rtx_insn *tail)", "NULL", "Target Hook" },
# 1120 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The hook can be used to initialize data used by the previous hook.", "void", "TARGET_SCHED_" "init_dfa_pre_cycle_insn", "(void)", "NULL", "Target Hook" },




{ "The hook returns an RTL insn.  The automaton state used in the\npipeline hazard recognizer is changed as if the insn were scheduled\nwhen the new simulated processor cycle starts.  Usage of the hook may\nsimplify the automaton pipeline description for some @acronym{VLIW}\nprocessors.  If the hook is defined, it is used only for the automaton\nbased pipeline description.  The default is not to change the state\nwhen the new simulated processor cycle starts.", "rtx", "TARGET_SCHED_" "dfa_pre_cycle_insn", "(void)", "NULL", "Target Hook" },
# 1136 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The hook is analogous to @samp{TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN} but\nused to initialize data used by the previous hook.", "void", "TARGET_SCHED_" "init_dfa_post_cycle_insn", "(void)", "NULL", "Target Hook" },





{ "The hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used\nto changed the state as if the insn were scheduled when the new\nsimulated processor cycle finishes.", "rtx_insn *", "TARGET_SCHED_" "dfa_post_cycle_insn", "(void)", "NULL", "Target Hook" },
# 1154 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The hook to notify target that the current simulated cycle is about to finish.\nThe hook is analogous to @samp{TARGET_SCHED_DFA_PRE_CYCLE_INSN} but used\nto change the state in more complicated situations - e.g., when advancing\nstate on a single insn is not enough.", "void", "TARGET_SCHED_" "dfa_pre_advance_cycle", "(void)", "NULL", "Target Hook" },







{ "The hook to notify target that new simulated cycle has just started.\nThe hook is analogous to @samp{TARGET_SCHED_DFA_POST_CYCLE_INSN} but used\nto change the state in more complicated situations - e.g., when advancing\nstate on a single insn is not enough.", "void", "TARGET_SCHED_" "dfa_post_advance_cycle", "(void)", "NULL", "Target Hook" },
# 1177 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook controls better choosing an insn from the ready insn queue\nfor the @acronym{DFA}-based insn scheduler.  Usually the scheduler\nchooses the first insn from the queue.  If the hook returns a positive\nvalue, an additional scheduler code tries all permutations of\n@samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()}\nsubsequent ready insns to choose an insn whose issue will result in\nmaximal number of issued insns on the same cycle.  For the\n@acronym{VLIW} processor, the code could actually solve the problem of\npacking simple insns into the @acronym{VLIW} insn.  Of course, if the\nrules of @acronym{VLIW} packing are described in the automaton.\n\nThis code also could be used for superscalar @acronym{RISC}\nprocessors.  Let us consider a superscalar @acronym{RISC} processor\nwith 3 pipelines.  Some insns can be executed in pipelines @var{A} or\n@var{B}, some insns can be executed only in pipelines @var{B} or\n@var{C}, and one insn can be executed in pipeline @var{B}.  The\nprocessor may issue the 1st insn into @var{A} and the 2nd one into\n@var{B}.  In this case, the 3rd insn will wait for freeing @var{B}\nuntil the next cycle.  If the scheduler issues the 3rd insn the first,\nthe processor could issue all 3 insns per cycle.\n\nActually this code demonstrates advantages of the automaton based\npipeline hazard recognizer.  We try quickly and easy many insn\nschedules to choose the best one.\n\nThe default is no multipass scheduling.", "int", "TARGET_SCHED_" "first_cycle_multipass_dfa_lookahead", "(void)", "NULL", "Target Hook" },
# 1211 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "\nThis hook controls what insns from the ready insn queue will be\nconsidered for the multipass insn scheduling.  If the hook returns\nzero for @var{insn}, the insn will be considered in multipass scheduling.\nPositive return values will remove @var{insn} from consideration on\nthe current round of multipass scheduling.\nNegative return values will remove @var{insn} from consideration for given\nnumber of cycles.\nBackends should be careful about returning non-zero for highest priority\ninstruction at position 0 in the ready list.  @var{ready_index} is passed\nto allow backends make correct judgements.\n\nThe default is that any ready insns can be chosen to be issued.", "int", "TARGET_SCHED_" "first_cycle_multipass_dfa_lookahead_guard", "(rtx_insn *insn, int ready_index)", "NULL", "Target Hook" },
# 1237 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook prepares the target backend for a new round of multipass\nscheduling.", "void", "TARGET_SCHED_" "first_cycle_multipass_begin", "(void *data, signed char *ready_try, int n_ready, bool first_cycle_insn_p)", "NULL", "Target Hook" },
# 1254 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called when multipass scheduling evaluates instruction INSN.", "void", "TARGET_SCHED_" "first_cycle_multipass_issue", "(void *data, signed char *ready_try, int n_ready, rtx_insn *insn, const void *prev_data)", "NULL", "Target Hook" },
# 1269 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This is called when multipass scheduling backtracks from evaluation of\nan instruction.", "void", "TARGET_SCHED_" "first_cycle_multipass_backtrack", "(const void *data, signed char *ready_try, int n_ready)", "NULL", "Target Hook" },
# 1283 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook notifies the target about the result of the concluded current\nround of multipass scheduling.", "void", "TARGET_SCHED_" "first_cycle_multipass_end", "(const void *data)", "NULL", "Target Hook" },
# 1294 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook initializes target-specific data used in multipass scheduling.", "void", "TARGET_SCHED_" "first_cycle_multipass_init", "(void *data)", "NULL", "Target Hook" },
# 1304 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook finalizes target-specific data used in multipass scheduling.", "void", "TARGET_SCHED_" "first_cycle_multipass_fini", "(void *data)", "NULL", "Target Hook" },
# 1320 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the insn scheduler before issuing @var{insn}\non cycle @var{clock}.  If the hook returns nonzero,\n@var{insn} is not issued on this processor cycle.  Instead,\nthe processor cycle is advanced.  If *@var{sort_p}\nis zero, the insn ready queue is not sorted on the new cycle\nstart as usually.  @var{dump} and @var{verbose} specify the file and\nverbosity level to use for debugging output.\n@var{last_clock} and @var{clock} are, respectively, the\nprocessor cycle on which the previous insn has been issued,\nand the current processor cycle.", "int", "TARGET_SCHED_" "dfa_new_cycle", "(FILE *dump, int verbose, rtx_insn *insn, int last_clock, int clock, int *sort_p)", "NULL", "Target Hook" },
# 1345 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to define which dependences are considered costly by\nthe target, so costly that it is not advisable to schedule the insns that\nare involved in the dependence too close to one another.  The parameters\nto this hook are as follows:  The first parameter @var{_dep} is the dependence\nbeing evaluated.  The second parameter @var{cost} is the cost of the\ndependence as estimated by the scheduler, and the third\nparameter @var{distance} is the distance in cycles between the two insns.\nThe hook returns @code{true} if considering the distance between the two\ninsns the dependence between them is considered costly by the target,\nand @code{false} otherwise.\n\nDefining this hook can be useful in multiple-issue out-of-order machines,\nwhere (a) it's practically hopeless to predict the actual data/resource\ndelays, however: (b) there's a better chance to predict the actual grouping\nthat will be formed, and (c) correctly emulating the grouping can be very\nimportant.  In such targets one may want to allow issuing dependent insns\ncloser to one another---i.e., closer than the dependence distance;  however,\nnot in cases of ``costly dependences'', which this hooks allows to define.", "bool", "TARGET_SCHED_" "is_costly_dependence", "(struct _dep *_dep, int cost, int distance)", "NULL", "Target Hook" },
# 1370 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the insn scheduler after emitting a new instruction to\nthe instruction stream.  The hook notifies a target backend to extend its\nper instruction data structures.", "void", "TARGET_SCHED_" "h_i_d_extended", "(void)", "NULL", "Target Hook" },
# 1380 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return a pointer to a store large enough to hold target scheduling context.", "void *", "TARGET_SCHED_" "alloc_sched_context", "(void)", "NULL", "Target Hook" },





{ "Initialize store pointed to by @var{tc} to hold target scheduling context.\nIt @var{clean_p} is true then initialize @var{tc} as if scheduler is at the\nbeginning of the block.  Otherwise, copy the current context into @var{tc}.", "void", "TARGET_SCHED_" "init_sched_context", "(void *tc, bool clean_p)", "NULL", "Target Hook" },







{ "Copy target scheduling context pointed to by @var{tc} to the current context.", "void", "TARGET_SCHED_" "set_sched_context", "(void *tc)", "NULL", "Target Hook" },





{ "Deallocate internal data in target scheduling context pointed to by @var{tc}.", "void", "TARGET_SCHED_" "clear_sched_context", "(void *tc)", "NULL", "Target Hook" },





{ "Deallocate a store for target scheduling context pointed to by @var{tc}.", "void", "TARGET_SCHED_" "free_sched_context", "(void *tc)", "NULL", "Target Hook" },
# 1421 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the insn scheduler when @var{insn} has only\nspeculative dependencies and therefore can be scheduled speculatively.\nThe hook is used to check if the pattern of @var{insn} has a speculative\nversion and, in case of successful check, to generate that speculative\npattern.  The hook should return 1, if the instruction has a speculative form,\nor @minus{}1, if it doesn't.  @var{request} describes the type of requested\nspeculation.  If the return value equals 1 then @var{new_pat} is assigned\nthe generated speculative pattern.", "int", "TARGET_SCHED_" "speculate_insn", "(rtx_insn *insn, unsigned int dep_status, rtx *new_pat)", "NULL", "Target Hook" },
# 1436 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the insn scheduler during generation of recovery code\nfor @var{insn}.  It should return @code{true}, if the corresponding check\ninstruction should branch to recovery code, or @code{false} otherwise.", "bool", "TARGET_SCHED_" "needs_block_p", "(unsigned int dep_status)", "NULL", "Target Hook" },
# 1450 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the insn scheduler to generate a pattern for recovery\ncheck instruction.  If @var{mutate_p} is zero, then @var{insn} is a\nspeculative instruction for which the check should be generated.\n@var{label} is either a label of a basic block, where recovery code should\nbe emitted, or a null pointer, when requested check doesn't branch to\nrecovery code (a simple check).  If @var{mutate_p} is nonzero, then\na pattern for a branchy check corresponding to a simple check denoted by\n@var{insn} should be generated.  In this case @var{label} can't be null.", "rtx", "TARGET_SCHED_" "gen_spec_check", "(rtx_insn *insn, rtx_insn *label, unsigned int ds)", "NULL", "Target Hook" },
# 1465 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used by the insn scheduler to find out what features should be\nenabled/used.\nThe structure *@var{spec_info} should be filled in by the target.\nThe structure describes speculation types that can be used in the scheduler.", "void", "TARGET_SCHED_" "set_sched_flags", "(struct spec_info_def *spec_info)", "NULL", "Target Hook" },







{ "*", "unsigned int", "TARGET_SCHED_" "get_insn_spec_ds", "(rtx_insn *insn)", "NULL", "Target Hook" },




{ "*", "unsigned int", "TARGET_SCHED_" "get_insn_checked_ds", "(rtx_insn *insn)", "NULL", "Target Hook" },




{ "Some instructions should never be speculated by the schedulers, usually\n because the instruction is too expensive to get this wrong.  Often such\n instructions have long latency, and often they are not fully modeled in the\n pipeline descriptions.  This hook should return @code{false} if @var{insn}\n should not be speculated.", "bool", "TARGET_SCHED_" "can_speculate_insn", "(rtx_insn *insn)", "hook_bool_rtx_insn_true", "Target Hook" },
# 1492 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "bool", "TARGET_SCHED_" "skip_rtx_p", "(const_rtx x)", "NULL", "Target Hook" },
# 1502 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by the swing modulo scheduler to calculate a\nresource-based lower bound which is based on the resources available in\nthe machine and the resources required by each instruction.  The target\nbackend can use @var{g} to calculate such bound.  A very simple lower\nbound will be used in case this hook is not implemented: the total number\nof instructions divided by the issue rate.", "int", "TARGET_SCHED_" "sms_res_mii", "(struct ddg *g)", "NULL", "Target Hook" },
# 1515 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by Haifa Scheduler.  It performs the operation specified\nin its second parameter.", "void", "TARGET_SCHED_" "dispatch_do", "(rtx_insn *insn, int x)", "hook_void_rtx_insn_int", "Target Hook" },
# 1525 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling\nis supported in hardware and the condition specified in the parameter is true.", "bool", "TARGET_SCHED_" "dispatch", "(rtx_insn *insn, int x)", "hook_bool_rtx_insn_int_false", "Target Hook" },






{ "True if the processor has an exposed pipeline, which means that not just\nthe order of instructions is important for correctness when scheduling, but\nalso the latencies of operations.", "bool", "TARGET_SCHED_" "exposed_pipeline", 0, "false", "Target Hook" },
# 1542 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by tree reassociator to determine a level of\nparallelism required in output calculations chain.", "int", "TARGET_SCHED_" "reassociation_width", "(unsigned int opc, machine_mode mode)", "hook_int_uint_mode_1", "Target Hook" },
# 1551 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called by scheduling fusion pass.  It calculates fusion\npriorities for each instruction passed in by parameter.  The priorities\nare returned via pointer parameters.\n\n@var{insn} is the instruction whose priorities need to be calculated.\n@var{max_pri} is the maximum priority can be returned in any cases.\n@var{fusion_pri} is the pointer parameter through which @var{insn}'s\nfusion priority should be calculated and returned.\n@var{pri} is the pointer parameter through which @var{insn}'s priority\nshould be calculated and returned.\n\nSame @var{fusion_pri} should be returned for instructions which should\nbe scheduled together.  Different @var{pri} should be returned for\ninstructions with same @var{fusion_pri}.  @var{fusion_pri} is the major\nsort key, @var{pri} is the minor sort key.  All instructions will be\nscheduled according to the two priorities.  All priorities calculated\nshould be between 0 (exclusive) and @var{max_pri} (inclusive).  To avoid\nfalse dependencies, @var{fusion_pri} of instructions which need to be\nscheduled together should be smaller than @var{fusion_pri} of irrelevant\ninstructions.\n\nGiven below example:\n\n@smallexample\n    ldr r10, [r1, 4]\n    add r4, r4, r10\n    ldr r15, [r2, 8]\n    sub r5, r5, r15\n    ldr r11, [r1, 0]\n    add r4, r4, r11\n    ldr r16, [r2, 12]\n    sub r5, r5, r16\n@end smallexample\n\nOn targets like ARM/AArch64, the two pairs of consecutive loads should be\nmerged.  Since peephole2 pass can't help in this case unless consecutive\nloads are actually next to each other in instruction flow.  That's where\nthis scheduling fusion pass works.  This hook calculates priority for each\ninstruction based on its fustion type, like:\n\n@smallexample\n    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96\n    add r4, r4, r10   ; fusion_pri=100, pri=100\n    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92\n    sub r5, r5, r15   ; fusion_pri=100, pri=100\n    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100\n    add r4, r4, r11   ; fusion_pri=100, pri=100\n    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88\n    sub r5, r5, r16   ; fusion_pri=100, pri=100\n@end smallexample\n\nScheduling fusion pass then sorts all ready to issue instructions according\nto the priorities.  As a result, instructions of same fusion type will be\npushed together in instruction flow, like:\n\n@smallexample\n    ldr r11, [r1, 0]\n    ldr r10, [r1, 4]\n    ldr r15, [r2, 8]\n    ldr r16, [r2, 12]\n    add r4, r4, r10\n    sub r5, r5, r15\n    add r4, r4, r11\n    sub r5, r5, r16\n@end smallexample\n\nNow peephole2 pass can simply merge the two pairs of loads.\n\nSince scheduling fusion pass relies on peephole2 to do real fusion\nwork, it is only enabled by default when peephole2 is in effect.\n\nThis is firstly introduced on ARM/AArch64 targets, please refer to\nthe hook implementation for how different fusion types are supported.", "void", "TARGET_SCHED_" "fusion_priority", "(rtx_insn *insn, int max_pri, int *fusion_pri, int *pri)", "NULL", "Target Hook" },
# 1628 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_SIMD_CLONE", 0, 0, "Target Hook" },

{ "This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\nfields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\n@var{simdlen} field if it was previously 0.\nThe hook should return 0 if SIMD clones shouldn't be emitted,\nor number of @var{vecsize_mangle} variants that should be emitted.", "int", "TARGET_SIMD_CLONE_" "compute_vecsize_and_simdlen", "(struct cgraph_node *, struct cgraph_simd_clone *, tree, int)", "NULL", "Target Hook" },
# 1644 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should add implicit @code{attribute(target(\"...\"))} attribute\nto SIMD clone @var{node} if needed.", "void", "TARGET_SIMD_CLONE_" "adjust", "(struct cgraph_node *)", "NULL", "Target Hook" },





{ "This hook should return -1 if SIMD clone @var{node} shouldn't be used\nin vectorized loops in current function, or non-negative number if it is\nusable.  In that case, the smaller the number is, the more desirable it is\nto use it.", "int", "TARGET_SIMD_CLONE_" "usable", "(struct cgraph_node *)", "NULL", "Target Hook" },







{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_SIMT", 0, 0, "Target Hook" },

{ "Return number of threads in SIMT thread group on the target.", "int", "TARGET_SIMT_" "vf", "(void)", "NULL", "Target Hook" },




{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_OMP", 0, 0, "Target Hook" },

{ "Return 1 if @var{trait} @var{name} is present in the OpenMP context's\ndevice trait set, return 0 if not present in any OpenMP context in the\nwhole translation unit, or -1 if not present in the current OpenMP context\nbut might be present in another OpenMP context in the same TU.", "int", "TARGET_OMP_" "device_kind_arch_isa", "(enum omp_device_kind_arch_isa trait, const char *name)", "NULL", "Target Hook" },







{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_GOACC", 0, 0, "Target Hook" },

{ "This hook should check the launch dimensions provided for an OpenACC\ncompute region, or routine.  Defaulted values are represented as -1\nand non-constant values as 0.  The @var{fn_level} is negative for the\nfunction corresponding to the compute region.  For a routine it is the\noutermost level at which partitioned execution may be spawned.  The hook\nshould verify non-default values.  If DECL is NULL, global defaults\nare being validated and unspecified defaults should be filled in.\nDiagnostics should be issued as appropriate.  Return\ntrue, if changes have been made.  You must override this hook to\nprovide dimensions larger than 1.", "bool", "TARGET_GOACC_" "validate_dims", "(tree decl, int *dims, int fn_level, unsigned used)", "default_goacc_validate_dims", "Target Hook" },
# 1707 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the maximum size of a particular dimension,\nor zero if unbounded.", "int", "TARGET_GOACC_" "dim_limit", "(int axis)", "default_goacc_dim_limit", "Target Hook" },






{ "This hook can be used to convert IFN_GOACC_FORK and IFN_GOACC_JOIN\nfunction calls to target-specific gimple, or indicate whether they\nshould be retained.  It is executed during the oacc_device_lower pass.\nIt should return true, if the call should be retained.  It should\nreturn false, if it is to be deleted (either because target-specific\ngimple has been inserted before it, or there is no need for it).\nThe default hook returns false, if there are no RTL expanders for them.", "bool", "TARGET_GOACC_" "fork_join", "(gcall *call, const int *dims, bool is_fork)", "default_goacc_fork_join", "Target Hook" },
# 1726 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used by the oacc_transform pass to expand calls to the\n@var{GOACC_REDUCTION} internal function, into a sequence of gimple\ninstructions.  @var{call} is gimple statement containing the call to\nthe function.  This hook removes statement @var{call} after the\nexpanded sequence has been inserted.  This hook is also responsible\nfor allocating any storage for reductions when necessary.", "void", "TARGET_GOACC_" "reduction", "(gcall *call)", "default_goacc_reduction", "Target Hook" },
# 1737 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_VECTORIZE", 0, 0, "Target Hook" },




{ "This hook should return the DECL of a function @var{f} that given an\naddress @var{addr} as an argument returns a mask @var{m} that can be\nused to extract from two vectors the relevant data that resides in\n@var{addr} in case @var{addr} is not properly aligned.\n\nThe autovectorizer, when vectorizing a load operation from an address\n@var{addr} that may be unaligned, will generate two vector loads from\nthe two aligned addresses around @var{addr}. It then generates a\n@code{REALIGN_LOAD} operation to extract the relevant data from the\ntwo loaded vectors. The first two arguments to @code{REALIGN_LOAD},\n@var{v1} and @var{v2}, are the two vectors, each of size @var{VS}, and\nthe third argument, @var{OFF}, defines how the data will be extracted\nfrom these two vectors: if @var{OFF} is 0, then the returned vector is\n@var{v2}; otherwise, the returned vector is composed from the last\n@var{VS}-@var{OFF} elements of @var{v1} concatenated to the first\n@var{OFF} elements of @var{v2}.\n\nIf this hook is defined, the autovectorizer will generate a call\nto @var{f} (using the DECL tree that this hook returns) and will\nuse the return value of @var{f} as the argument @var{OFF} to\n@code{REALIGN_LOAD}. Therefore, the mask @var{m} returned by @var{f}\nshould comply with the semantics expected by @code{REALIGN_LOAD}\ndescribed above.\nIf this hook is not defined, then @var{addr} will be used as\nthe argument @var{OFF} to @code{REALIGN_LOAD}, in which case the low\nlog2(@var{VS}) @minus{} 1 bits of @var{addr} will be considered.", "tree", "TARGET_VECTORIZE_" "builtin_mask_for_load", "(void)", "NULL", "Target Hook" },
# 1779 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the decl of a function that implements the\nvectorized variant of the function with the @code{combined_fn} code\n@var{code} or @code{NULL_TREE} if such a function is not available.\nThe return type of the vectorized function shall be of vector type\n@var{vec_type_out} and the argument types should be @var{vec_type_in}.", "tree", "TARGET_VECTORIZE_" "builtin_vectorized_function", "(unsigned code, tree vec_type_out, tree vec_type_in)", "default_builtin_vectorized_function", "Target Hook" },
# 1791 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the decl of a function that implements the\nvectorized variant of target built-in function @code{fndecl}.  The\nreturn type of the vectorized function shall be of vector type\n@var{vec_type_out} and the argument types should be @var{vec_type_in}.", "tree", "TARGET_VECTORIZE_" "builtin_md_vectorized_function", "(tree fndecl, tree vec_type_out, tree vec_type_in)", "default_builtin_md_vectorized_function", "Target Hook" },
# 1803 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Returns cost of different scalar or vector statements for vectorization cost model.\nFor vector memory operations the cost may depend on type (@var{vectype}) and\nmisalignment value (@var{misalign}).", "int", "TARGET_VECTORIZE_" "builtin_vectorization_cost", "(enum vect_cost_for_stmt type_of_cost, tree vectype, int misalign)", "default_builtin_vectorization_cost", "Target Hook" },







{ "This hook returns the preferred alignment in bits for accesses to\nvectors of type @var{type} in vectorized code.  This might be less than\nor greater than the ABI-defined value returned by\n@code{TARGET_VECTOR_ALIGNMENT}.  It can be equal to the alignment of\na single element, in which case the vectorizer will not try to optimize\nfor alignment.\n\nThe default hook returns @code{TYPE_ALIGN (@var{type})}, which is\ncorrect for most targets.", "poly_uint64", "TARGET_VECTORIZE_" "preferred_vector_alignment", "(const_tree type)", "default_preferred_vector_alignment", "Target Hook" },
# 1827 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.", "bool", "TARGET_VECTORIZE_" "vector_alignment_reachable", "(const_tree type, bool is_packed)", "default_builtin_vector_alignment_reachable", "Target Hook" },





{ "This hook is used to test whether the target can permute up to two\nvectors of mode @var{mode} using the permutation vector @code{sel}, and\nalso to emit such a permutation.  In the former case @var{in0}, @var{in1}\nand @var{out} are all null.  In the latter case @var{in0} and @var{in1} are\nthe source vectors and @var{out} is the destination vector; all three are\nregisters of mode @var{mode}.  @var{in1} is the same as @var{in0} if\n@var{sel} describes a permutation on one vector instead of two.\n\nReturn true if the operation is possible, emitting instructions for it\nif rtxes are provided.\n\n@cindex @code{vec_perm@var{m}} instruction pattern\nIf the hook returns false for a mode with multibyte elements, GCC will\ntry the equivalent byte operation.  If that also fails, it will try forcing\nthe selector into a register and using the @var{vec_perm@var{mode}}\ninstruction pattern.  There is no need for the hook to handle these two\nimplementation approaches itself.", "bool", "TARGET_VECTORIZE_" "vec_perm_const", "(machine_mode mode, rtx output, rtx in0, rtx in1, const vec_perm_indices &sel)", "NULL", "Target Hook" },
# 1859 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if the target supports misaligned vector\nstore/load of a specific factor denoted in the @var{misalignment}\nparameter.  The vector store/load should be of machine mode @var{mode} and\nthe elements in the vectors should be of type @var{type}.  @var{is_packed}\nparameter is true if the memory access is defined in a packed struct.", "bool", "TARGET_VECTORIZE_" "support_vector_misalignment", "(machine_mode mode, const_tree type, int misalignment, bool is_packed)", "default_builtin_support_vector_misalignment", "Target Hook" },
# 1872 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the preferred mode for vectorizing scalar\nmode @var{mode}.  The default is\nequal to @code{word_mode}, because the vectorizer can do some\ntransformations even in absence of specialized @acronym{SIMD} hardware.", "machine_mode", "TARGET_VECTORIZE_" "preferred_simd_mode", "(scalar_mode mode)", "default_preferred_simd_mode", "Target Hook" },
# 1883 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the preferred mode to split the final reduction\nstep on @var{mode} to.  The reduction is then carried out reducing upper\nagainst lower halves of vectors recursively until the specified mode is\nreached.  The default is @var{mode} which means no splitting.", "machine_mode", "TARGET_VECTORIZE_" "split_reduction", "(machine_mode)", "default_split_reduction", "Target Hook" },
# 1895 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If using the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}\nis not the only approach worth considering, this hook should add one mode to\n@var{modes} for each useful alternative approach.  These modes are then\npassed to @code{TARGET_VECTORIZE_RELATED_MODE} to obtain the vector mode\nfor a given element mode.\n\nThe modes returned in @var{modes} should use the smallest element mode\npossible for the vectorization approach that they represent, preferring\ninteger modes over floating-poing modes in the event of a tie.  The first\nmode should be the @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} for its\nelement mode.\n\nIf @var{all} is true, add suitable vector modes even when they are generally\nnot expected to be worthwhile.\n\nThe hook returns a bitmask of flags that control how the modes in\n@var{modes} are used.  The flags are:\n@table @code\n@item VECT_COMPARE_COSTS\nTells the loop vectorizer to try all the provided modes and pick the one\nwith the lowest cost.  By default the vectorizer will choose the first\nmode that works.\n@end table\n\nThe hook does not need to do anything if the vector returned by\n@code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\nfor autovectorization.  The default implementation adds no modes and\nreturns 0.", "unsigned int", "TARGET_VECTORIZE_" "autovectorize_vector_modes", "(vector_modes *modes, bool all)", "default_autovectorize_vector_modes", "Target Hook" },
# 1929 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If a piece of code is using vector mode @var{vector_mode} and also wants\nto operate on elements of mode @var{element_mode}, return the vector mode\nit should use for those elements.  If @var{nunits} is nonzero, ensure that\nthe mode has exactly @var{nunits} elements, otherwise pick whichever vector\nsize pairs the most naturally with @var{vector_mode}.  Return an empty\n@code{opt_machine_mode} if there is no supported vector mode with the\nrequired properties.\n\nThere is no prescribed way of handling the case in which @var{nunits}\nis zero.  One common choice is to pick a vector mode with the same size\nas @var{vector_mode}; this is the natural choice if the target has a\nfixed vector size.  Another option is to choose a vector mode with the\nsame number of elements as @var{vector_mode}; this is the natural choice\nif the target has a fixed number of elements.  Alternatively, the hook\nmight choose a middle ground, such as trying to keep the number of\nelements as similar as possible while applying maximum and minimum\nvector sizes.\n\nThe default implementation uses @code{mode_for_vector} to find the\nrequested mode, returning a mode with the same size as @var{vector_mode}\nwhen @var{nunits} is zero.  This is the correct behavior for most targets.", "opt_machine_mode", "TARGET_VECTORIZE_" "related_mode", "(machine_mode vector_mode, scalar_mode element_mode, poly_uint64 nunits)", "default_vectorize_related_mode", "Target Hook" },
# 1957 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the mode to use for a vector mask that holds one boolean\nresult for each element of vector mode @var{mode}.  The returned mask mode\ncan be a vector of integers (class @code{MODE_VECTOR_INT}), a vector of\nbooleans (class @code{MODE_VECTOR_BOOL}) or a scalar integer (class\n@code{MODE_INT}).  Return an empty @code{opt_machine_mode} if no such\nmask mode exists.\n\nThe default implementation returns a @code{MODE_VECTOR_INT} with the\nsame size and number of elements as @var{mode}, if such a mode exists.", "opt_machine_mode", "TARGET_VECTORIZE_" "get_mask_mode", "(machine_mode mode)", "default_get_mask_mode", "Target Hook" },
# 1974 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if masked internal function @var{ifn} (really of\ntype @code{internal_fn}) should be considered expensive when the mask is\nall zeros.  GCC can then try to branch around the instruction instead.", "bool", "TARGET_VECTORIZE_" "empty_mask_is_expensive", "(unsigned ifn)", "default_empty_mask_is_expensive", "Target Hook" },
# 1984 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Target builtin that implements vector gather operation.  @var{mem_vectype}\nis the vector type of the load and @var{index_type} is scalar type of\nthe index, scaled by @var{scale}.\nThe default is @code{NULL_TREE} which means to not vectorize gather\nloads.", "tree", "TARGET_VECTORIZE_" "builtin_gather", "(const_tree mem_vectype, const_tree index_type, int scale)", "NULL", "Target Hook" },
# 1996 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Target builtin that implements vector scatter operation.  @var{vectype}\nis the vector type of the store and @var{index_type} is scalar type of\nthe index, scaled by @var{scale}.\nThe default is @code{NULL_TREE} which means to not vectorize scatter\nstores.", "tree", "TARGET_VECTORIZE_" "builtin_scatter", "(const_tree vectype, const_tree index_type, int scale)", "NULL", "Target Hook" },
# 2008 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should initialize target-specific data structures in preparation " "for modeling the costs of vectorizing a loop or basic block.  The default " "allocates three unsigned integers for accumulating costs for the prologue, " "body, and epilogue of the loop or basic block.  If @var{loop_info} is " "non-NULL, it identifies the loop being vectorized; otherwise a single block " "is being vectorized.", "void *", "TARGET_VECTORIZE_" "init_cost", "(class loop *loop_info)", "default_init_cost", "Target Hook" },
# 2023 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should update the target-specific @var{data} in response to " "adding @var{count} copies of the given @var{kind} of statement to a " "loop or basic block.  The default adds the builtin vectorizer cost for " "the copies of the statement to the accumulator specified by @var{where}, " "(the prologue, body, or epilogue) and returns the amount added.  The " "return value should be viewed as a tentative cost that may later be " "revised.", "unsigned", "TARGET_VECTORIZE_" "add_stmt_cost", "(class vec_info *, void *data, int count, enum vect_cost_for_stmt kind, class _stmt_vec_info *stmt_info, tree vectype, int misalign, enum vect_cost_model_location where)", "default_add_stmt_cost", "Target Hook" },
# 2040 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should complete calculations of the cost of vectorizing a loop " "or basic block based on @var{data}, and return the prologue, body, and " "epilogue costs as unsigned integers.  The default returns the value of " "the three accumulators.", "void", "TARGET_VECTORIZE_" "finish_cost", "(void *data, unsigned *prologue_cost, unsigned *body_cost, unsigned *epilogue_cost)", "default_finish_cost", "Target Hook" },
# 2052 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should release @var{data} and any related data structures " "allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the " "accumulator.", "void", "TARGET_VECTORIZE_" "destroy_cost_data", "(void *data)", "default_destroy_cost_data", "Target Hook" },
# 2061 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ "This hook returns the target's preferred final argument for a call\nto conditional internal function @var{ifn} (really of type\n@code{internal_fn}).  @var{type} specifies the return type of the\nfunction and @var{ops} are the operands to the conditional operation,\nof which there are @var{nops}.\n\nFor example, if @var{ifn} is @code{IFN_COND_ADD}, the hook returns\na value of type @var{type} that should be used when @samp{@var{ops}[0]}\nand @samp{@var{ops}[1]} are conditionally added together.\n\nThis hook is only relevant if the target supports conditional patterns\nlike @code{cond_add@var{m}}.  The default implementation returns a zero\nconstant of type @var{type}.", "tree", "TARGET_" "preferred_else_value", "(unsigned ifn, tree type, unsigned nops, tree *ops)", "default_preferred_else_value", "Target Hook" },
# 2085 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Used when offloaded functions are seen in the compilation unit and no named\nsections are available.  It is called once for each symbol that must be\nrecorded in the offload function and variable table.", "void", "TARGET_" "record_offload_symbol", "(tree)", "hook_void_tree", "Target Hook" },







{ "If defined, this target hook specifies the absolute biggest alignment\nthat a type or variable can have on this machine, otherwise,\n@code{BIGGEST_ALIGNMENT} is used.", "HOST_WIDE_INT", "TARGET_" "absolute_biggest_alignment", 0, "BIGGEST_ALIGNMENT", "Target Hook" },
# 2103 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target function is similar to the hook @code{TARGET_OPTION_OVERRIDE}\nbut is called when the optimize level is changed via an attribute or\npragma or when it is reset at the end of the code affected by the\nattribute or pragma.  It is not called at the beginning of compilation\nwhen @code{TARGET_OPTION_OVERRIDE} is called so if you want to perform these\nactions then, you should have @code{TARGET_OPTION_OVERRIDE} call\n@code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}.", "void", "TARGET_" "override_options_after_change", "(void)", "hook_void_void", "Target Hook" },
# 2115 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Used when writing out the list of options into an LTO file.  It should\ntranslate any relevant target-specific options (such as the ABI in use)\ninto one of the @option{-foffload} options that exist as a common interface\nto express such options.  It should return a string containing these options,\nseparated by spaces, which the caller will free.\n", "char *", "TARGET_" "offload_options", "(void)", "hook_charptr_void_null", "Target Hook" },
# 2124 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "scalar_int_mode", "TARGET_" "eh_return_filter_mode", "(void)", "default_eh_return_filter_mode", "Target Hook" },






{ "This target hook should return the mode to be used for the return value\nof compare instructions expanded to libgcc calls.  If not defined\n@code{word_mode} is returned which is the right choice for a majority of\ntargets.", "scalar_int_mode", "TARGET_" "libgcc_cmp_return_mode", "(void)", "default_libgcc_cmp_return_mode", "Target Hook" },
# 2141 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return the mode to be used for the shift count operand\nof shift instructions expanded to libgcc calls.  If not defined\n@code{word_mode} is returned which is the right choice for a majority of\ntargets.", "scalar_int_mode", "TARGET_" "libgcc_shift_count_mode", "(void)", "default_libgcc_shift_count_mode", "Target Hook" },
# 2151 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return machine mode to be used for @code{_Unwind_Word} type.\nThe default is to use @code{word_mode}.", "scalar_int_mode", "TARGET_" "unwind_word_mode", "(void)", "default_unwind_word_mode", "Target Hook" },







{ "Define this target hook if the merging of decl attributes needs special\nhandling.  If defined, the result is a list of the combined\n@code{DECL_ATTRIBUTES} of @var{olddecl} and @var{newdecl}.\n@var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of\nwhen this is needed are when one attribute overrides another, or when an\nattribute is nullified by a subsequent definition.  This function may\ncall @code{merge_attributes} to handle machine-independent merging.\n\n@findex TARGET_DLLIMPORT_DECL_ATTRIBUTES\nIf the only target-specific handling you require is @samp{dllimport}\nfor Microsoft Windows targets, you should define the macro\n@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES} to @code{1}.  The compiler\nwill then define a function called\n@code{merge_dllimport_decl_attributes} which can then be defined as\nthe expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  You can also\nadd @code{handle_dll_attribute} in the attribute table for your port\nto perform initial processing of the @samp{dllimport} and\n@samp{dllexport} attributes.  This is done in @file{i386/cygwin.h} and\n@file{i386/i386.c}, for example.", "tree", "TARGET_" "merge_decl_attributes", "(tree olddecl, tree newdecl)", "merge_decl_attributes", "Target Hook" },
# 2184 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this target hook if the merging of type attributes needs special\nhandling.  If defined, the result is a list of the combined\n@code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed\nthat @code{comptypes} has already been called and returned 1.  This\nfunction may call @code{merge_attributes} to handle machine-independent\nmerging.", "tree", "TARGET_" "merge_type_attributes", "(tree type1, tree type2)", "merge_type_attributes", "Target Hook" },
# 2197 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook points to an array of @samp{struct\nattribute_spec} (defined in @file{tree-core.h}) specifying the machine\nspecific attributes for this target and some of the restrictions on the\nentities to which these attributes are applied and the arguments they\ntake.", "const struct attribute_spec *", "TARGET_" "attribute_table", 0, "NULL", "Target Hook" },
# 2208 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook is a function which returns true if the\nmachine-specific attribute named @var{name} expects an identifier\ngiven as its first argument to be passed on as a plain identifier, not\nsubjected to name lookup.  If this is not defined, the default is\nfalse for all machine-specific attributes.", "bool", "TARGET_" "attribute_takes_identifier_p", "(const_tree name)", "hook_bool_const_tree_false", "Target Hook" },
# 2221 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook is a function which returns zero if the attributes on\n@var{type1} and @var{type2} are incompatible, one if they are compatible,\nand two if they are nearly compatible (which causes a warning to be\ngenerated).  If this is not defined, machine-specific attributes are\nsupposed always to be compatible.", "int", "TARGET_" "comp_type_attributes", "(const_tree type1, const_tree type2)", "hook_int_const_tree_const_tree_1", "Target Hook" },
# 2232 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook is a function which assigns default attributes to\nthe newly defined @var{type}.", "void", "TARGET_" "set_default_type_attributes", "(tree type)", "hook_void_tree", "Target Hook" },







{ "Define this target hook if you want to be able to add attributes to a decl\nwhen it is being created.  This is normally useful for back ends which\nwish to implement a pragma by using the attributes which correspond to\nthe pragma's effect.  The @var{node} argument is the decl which is being\ncreated.  The @var{attr_ptr} argument is a pointer to the attribute list\nfor this decl.  The list itself should not be modified, since it may be\nshared with other decls, but attributes may be chained on the head of\nthe list and @code{*@var{attr_ptr}} modified to point to the new\nattributes, or a copy of the list may be made if further changes are\nneeded.", "void", "TARGET_" "insert_attributes", "(tree node, tree *attr_ptr)", "hook_void_tree_treeptr", "Target Hook" },
# 2256 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this target hook if you want to be able to perform additional\ntarget-specific processing of an attribute which is handled generically\nby a front end.  The arguments are the same as those which are passed to\nattribute handlers.  So far this only affects the @var{noinit} and\n@var{section} attribute.", "tree", "TARGET_" "handle_generic_attribute", "(tree *node, tree name, tree args, int flags, bool *no_add_attrs)", "hook_tree_treeptr_tree_tree_int_boolptr_null", "Target Hook" },
# 2268 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "@cindex inlining\nThis target hook returns @code{true} if it is OK to inline @var{fndecl}\ninto the current function, despite its having target-specific\nattributes, @code{false} otherwise.  By default, if a function has a\ntarget specific attribute attached to it, it will not be inlined.", "bool", "TARGET_" "function_attribute_inlinable_p", "(const_tree fndecl)", "hook_bool_const_tree_false", "Target Hook" },
# 2280 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns @code{true} if bit-fields in the given\n@var{record_type} are to be laid out following the rules of Microsoft\nVisual C/C++, namely: (i) a bit-field won't share the same storage\nunit with the previous bit-field if their underlying types have\ndifferent sizes, and the bit-field will be aligned to the highest\nalignment of the underlying types of itself and of the previous\nbit-field; (ii) a zero-sized bit-field will affect the alignment of\nthe whole enclosing structure, even if it is unnamed; except that\n(iii) a zero-sized bit-field will be disregarded unless it follows\nanother bit-field of nonzero size.  If this hook returns @code{true},\nother macros that control bit-field layout are ignored.\n\nWhen a bit-field is inserted into a packed record, the whole size\nof the underlying type is used by one or more same-size adjacent\nbit-fields (that is, if its long:3, 32 bits is used in the record,\nand any additional adjacent long bit-fields are packed into the same\nchunk of 32 bits.  However, if the size changes, a new field of that\nsize is allocated).  In an unpacked record, this is the same as using\nalignment, but not equivalent when packing.\n\nIf both MS bit-fields and @samp{__attribute__((packed))} are used,\nthe latter will take precedence.  If @samp{__attribute__((packed))} is\nused on a single field when MS bit-fields are in use, it will take\nprecedence for that field, but the alignment of the rest of the structure\nmay affect its placement.", "bool", "TARGET_" "ms_bitfield_layout_p", "(const_tree record_type)", "hook_bool_const_tree_false", "Target Hook" },
# 2313 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "bool", "TARGET_" "words_big_endian", "(void)", "targhook_words_big_endian", "Target Hook" },






{ "*", "bool", "TARGET_" "float_words_big_endian", "(void)", "targhook_float_words_big_endian", "Target Hook" },





{ "Returns true if the target supports IEEE 754 floating-point exceptions and rounding modes, false otherwise.  This is intended to relate to the @code{float} and @code{double} types, but not necessarily @code{long double}. By default, returns true if the @code{adddf3} instruction pattern is available and false otherwise, on the assumption that hardware floating point supports exceptions and rounding modes but software floating point does not.", "bool", "TARGET_" "float_exceptions_rounding_supported_p", "(void)", "default_float_exceptions_rounding_supported_p", "Target Hook" },
# 2339 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Returns true if the target supports decimal floating point.", "bool", "TARGET_" "decimal_float_supported_p", "(void)", "default_decimal_float_supported_p", "Target Hook" },






{ "Returns true if the target supports fixed-point arithmetic.", "bool", "TARGET_" "fixed_point_supported_p", "(void)", "default_fixed_point_supported_p", "Target Hook" },






{ "When @code{PCC_BITFIELD_TYPE_MATTERS} is true this hook will determine\nwhether unnamed bitfields affect the alignment of the containing\nstructure.  The hook should return true if the structure should inherit\nthe alignment requirements of an unnamed bitfield's type.", "bool", "TARGET_" "align_anon_bitfield", "(void)", "hook_bool_void_false", "Target Hook" },
# 2364 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if accesses to volatile bitfields\nshould use the narrowest mode possible.  It should return @code{false} if\nthese accesses should use the bitfield container type.\n\nThe default is @code{false}.", "bool", "TARGET_" "narrow_volatile_bitfield", "(void)", "hook_bool_void_false", "Target Hook" },
# 2375 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if you have any machine-specific built-in functions\nthat need to be defined.  It should be a function that performs the\nnecessary setup.\n\nMachine specific built-in functions can be useful to expand special machine\ninstructions that would otherwise not normally be generated because\nthey have no equivalent in the source language (for example, SIMD vector\ninstructions or prefetch instructions).\n\nTo create a built-in function, call the function\n@code{lang_hooks.builtin_function}\nwhich is defined by the language front end.  You can use any type nodes set\nup by @code{build_common_tree_nodes};\nonly language front ends that use those two functions will call\n@samp{TARGET_INIT_BUILTINS}.", "void", "TARGET_" "init_builtins", "(void)", "hook_void_void", "Target Hook" },
# 2399 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if you have any machine-specific built-in functions\nthat need to be defined.  It should be a function that returns the\nbuiltin function declaration for the builtin function code @var{code}.\nIf there is no such builtin and it cannot be initialized at this time\nif @var{initialize_p} is true the function should return @code{NULL_TREE}.\nIf @var{code} is out of range the function should return\n@code{error_mark_node}.", "tree", "TARGET_" "builtin_decl", "(unsigned code, bool initialize_p)", "NULL", "Target Hook" },
# 2411 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "\nExpand a call to a machine specific built-in function that was set up by\n@samp{TARGET_INIT_BUILTINS}.  @var{exp} is the expression for the\nfunction call; the result should go to @var{target} if that is\nconvenient, and have mode @var{mode} if that is convenient.\n@var{subtarget} may be used as the target for computing one of\n@var{exp}'s operands.  @var{ignore} is nonzero if the value is to be\nignored.  This function should return the result of the call to the\nbuilt-in function.", "rtx", "TARGET_" "expand_builtin", "(tree exp, rtx target, rtx subtarget, machine_mode mode, int ignore)", "default_expand_builtin", "Target Hook" },
# 2431 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Select a replacement for a machine specific built-in function that\nwas set up by @samp{TARGET_INIT_BUILTINS}.  This is done\n@emph{before} regular type checking, and so allows the target to\nimplement a crude form of function overloading.  @var{fndecl} is the\ndeclaration of the built-in function.  @var{arglist} is the list of\narguments passed to the built-in function.  The result is a\ncomplete expression that implements the operation, usually\nanother @code{CALL_EXPR}.\n@var{arglist} really has type @samp{VEC(tree,gc)*}", "tree", "TARGET_" "resolve_overloaded_builtin", "(unsigned int loc, tree fndecl, void *arglist)", "NULL", "Target Hook" },
# 2444 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Perform semantic checking on a call to a machine-specific built-in\nfunction after its arguments have been constrained to the function\nsignature.  Return true if the call is valid, otherwise report an error\nand return false.\n\nThis hook is called after @code{TARGET_RESOLVE_OVERLOADED_BUILTIN}.\nThe call was originally to built-in function @var{orig_fndecl},\nbut after the optional @code{TARGET_RESOLVE_OVERLOADED_BUILTIN}\nstep is now to built-in function @var{fndecl}.  @var{loc} is the\nlocation of the call and @var{args} is an array of function arguments,\nof which there are @var{nargs}.  @var{arg_loc} specifies the location\nof each argument.", "bool", "TARGET_" "check_builtin_call", "(location_t loc, vec<location_t> arg_loc, tree fndecl, tree orig_fndecl, unsigned int nargs, tree *args)", "NULL", "Target Hook" },
# 2464 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Fold a call to a machine specific built-in function that was set up by\n@samp{TARGET_INIT_BUILTINS}.  @var{fndecl} is the declaration of the\nbuilt-in function.  @var{n_args} is the number of arguments passed to\nthe function; the arguments themselves are pointed to by @var{argp}.\nThe result is another tree, valid for both GIMPLE and GENERIC,\ncontaining a simplified expression for the call's result.  If\n@var{ignore} is true the value will be ignored.", "tree", "TARGET_" "fold_builtin", "(tree fndecl, int n_args, tree *argp, bool ignore)", "hook_tree_tree_int_treep_bool_null", "Target Hook" },
# 2477 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Fold a call to a machine specific built-in function that was set up\nby @samp{TARGET_INIT_BUILTINS}.  @var{gsi} points to the gimple\nstatement holding the function call.  Returns true if any change\nwas made to the GIMPLE stream.", "bool", "TARGET_" "gimple_fold_builtin", "(gimple_stmt_iterator *gsi)", "hook_bool_gsiptr_false", "Target Hook" },
# 2494 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to compare the target attributes in two functions to\ndetermine which function's features get higher priority.  This is used\nduring function multi-versioning to figure out the order in which two\nversions must be dispatched.  A function version with a higher priority\nis checked for dispatching earlier.  @var{decl1} and @var{decl2} are\n the two function decls that will be compared.", "int", "TARGET_" "compare_version_priority", "(tree decl1, tree decl2)", "NULL", "Target Hook" },
# 2508 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to generate the dispatcher logic to invoke the right\nfunction version at run-time for a given set of function versions.\n@var{arg} points to the callgraph node of the dispatcher function whose\nbody must be generated.", "tree", "TARGET_" "generate_version_dispatcher_body", "(void *arg)", "NULL", "Target Hook" },
# 2520 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to get the dispatcher function for a set of function\nversions.  The dispatcher function is called to invoke the right function\nversion at run-time. @var{decl} is one version from a set of semantically\nidentical versions.", "tree", "TARGET_" "get_function_versions_dispatcher", "(void *decl)", "NULL", "Target Hook" },
# 2530 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return the DECL of a function that implements the\nreciprocal of the machine-specific builtin function @var{fndecl}, or\n@code{NULL_TREE} if such a function is not available.", "tree", "TARGET_" "builtin_reciprocal", "(tree fndecl)", "default_builtin_reciprocal", "Target Hook" },
# 2541 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If your target defines any fundamental types, or any types your target\nuses should be mangled differently from the default, define this hook\nto return the appropriate encoding for these types as part of a C++\nmangled name.  The @var{type} argument is the tree structure representing\nthe type to be mangled.  The hook may be applied to trees which are\nnot target-specific fundamental types; it should return @code{NULL}\nfor all such types, as well as arguments it does not recognize.  If the\nreturn value is not @code{NULL}, it must point to a statically-allocated\nstring constant.\n\nTarget-specific fundamental types might be new fundamental types or\nqualified versions of ordinary fundamental types.  Encode new\nfundamental types as @samp{@w{u @var{n} @var{name}}}, where @var{name}\nis the name used for the type in source code, and @var{n} is the\nlength of @var{name} in decimal.  Encode qualified versions of\nordinary types as @samp{@w{U @var{n} @var{name} @var{code}}}, where\n@var{name} is the name used for the type qualifier in source code,\n@var{n} is the length of @var{name} as above, and @var{code} is the\ncode used to represent the unqualified version of this type.  (See\n@code{write_builtin_type} in @file{cp/mangle.c} for the list of\ncodes.)  In both cases the spaces are for clarity; do not include any\nspaces in your string.\n\nThis hook is applied to types prior to typedef resolution.  If the mangled\nname for a particular type depends only on that type's main variant, you\ncan perform typedef resolution yourself using @code{TYPE_MAIN_VARIANT}\nbefore mangling.\n\nThe default version of this hook always returns @code{NULL}, which is\nappropriate for a target that does not define any new fundamental\ntypes.", "const char *", "TARGET_" "mangle_type", "(const_tree type)", "hook_constcharptr_const_tree_null", "Target Hook" },
# 2578 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should declare additional library routines or rename\nexisting ones, using the functions @code{set_optab_libfunc} and\n@code{init_one_libfunc} defined in @file{optabs.c}.\n@code{init_optabs} calls this macro after initializing all the normal\nlibrary routines.\n\nThe default is to do nothing.  Most ports don't need to define this hook.", "void", "TARGET_" "init_libfuncs", "(void)", "hook_void_void", "Target Hook" },
# 2591 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If false (the default), internal library routines start with two\nunderscores.  If set to true, these routines start with @code{__gnu_}\ninstead.  E.g., @code{__muldi3} changes to @code{__gnu_muldi3}.  This\ncurrently only affects functions defined in @file{libgcc2.c}.  If this\nis set to true, the @file{tm.h} file must also\n@code{#define LIBGCC2_GNU_PREFIX}.", "bool", "TARGET_" "libfunc_gnu_prefix", 0, "false", "Target Hook" },
# 2604 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Choose a set of section attributes for use by @code{TARGET_ASM_NAMED_SECTION}\nbased on a variable or function decl, a section name, and whether or not the\ndeclaration's initializer may contain runtime relocations.  @var{decl} may be\nnull, in which case read-write data should be assumed.\n\nThe default version of this function handles choosing code vs data,\nread-only vs read-write data, and @code{flag_pic}.  You should only\nneed to override this if your target has special flags that might be\nset via @code{__attribute__}.", "unsigned int", "TARGET_" "section_type_flags", "(tree decl, const char *name, int reloc)", "default_section_type_flags", "Target Hook" },
# 2618 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook determines whether a function from a class of functions\n@var{fn_class} is present in the target C library.", "bool", "TARGET_" "libc_has_function", "(enum function_class fn_class)", "default_libc_has_function", "Target Hook" },






{ "This hook determines whether a function from a class of functions\n@code{(enum function_class)}@var{fcode} has a fast implementation.", "bool", "TARGET_" "libc_has_fast_function", "(int fcode)", "default_libc_has_fast_function", "Target Hook" },
# 2634 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns @code{true} past the point in which new jump\ninstructions could be created.  On machines that require a register for\nevery jump such as the SHmedia ISA of SH5, this point would typically be\nreload, so this target hook should be defined to a function such as:\n\n@smallexample\nstatic bool\ncannot_modify_jumps_past_reload_p ()\n@{\n  return (reload_completed || reload_in_progress);\n@}\n@end smallexample", "bool", "TARGET_" "cannot_modify_jumps_p", "(void)", "hook_bool_void_false", "Target Hook" },
# 2652 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "FOLLOWER and FOLLOWEE are JUMP_INSN instructions;  return true if FOLLOWER may be modified to follow FOLLOWEE;  false, if it can't.  For example, on some targets, certain kinds of branches can't be made to  follow through a hot/cold partitioning.", "bool", "TARGET_" "can_follow_jump", "(const rtx_insn *follower, const rtx_insn *followee)", "hook_bool_const_rtx_insn_const_rtx_insn_true", "Target Hook" },
# 2663 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns true if the target supports conditional execution.\nThis target hook is required only when the target has several different\nmodes and they have different conditional execution capability, such as ARM.", "bool", "TARGET_" "have_conditional_execution", "(void)", "default_have_conditional_execution", "Target Hook" },







{ "This function prepares to emit a comparison insn for the first compare in a\n sequence of conditional comparisions.  It returns an appropriate comparison\n with @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n The insns to prepare the compare are saved in @var{prep_seq} and the compare\n insns are saved in @var{gen_seq}.  They will be emitted when all the\n compares in the conditional comparision are generated without error.\n @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.", "rtx", "TARGET_" "gen_ccmp_first", "(rtx_insn **prep_seq, rtx_insn **gen_seq, int code, tree op0, tree op1)", "NULL", "Target Hook" },
# 2683 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This function prepares to emit a conditional comparison within a sequence\n of conditional comparisons.  It returns an appropriate comparison with\n @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n The insns to prepare the compare are saved in @var{prep_seq} and the compare\n insns are saved in @var{gen_seq}.  They will be emitted when all the\n compares in the conditional comparision are generated without error.  The\n @var{prev} expression is the result of a prior call to @code{gen_ccmp_first}\n or @code{gen_ccmp_next}.  It may return @code{NULL} if the combination of\n @var{prev} and this comparison is not supported, otherwise the result must\n be appropriate for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.", "rtx", "TARGET_" "gen_ccmp_next", "(rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code)", "NULL", "Target Hook" },
# 2701 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns a new value for the number of times @var{loop}\nshould be unrolled. The parameter @var{nunroll} is the number of times\nthe loop is to be unrolled. The parameter @var{loop} is a pointer to\nthe loop, which is going to be checked for unrolling. This target hook\nis required only when the target has special constraints like maximum\nnumber of memory accesses.", "unsigned", "TARGET_" "loop_unroll_adjust", "(unsigned nunroll, class loop *loop)", "NULL", "Target Hook" },
# 2713 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if @var{x} is a legitimate constant for a\n@var{mode}-mode immediate operand on the target machine.  You can assume that\n@var{x} satisfies @code{CONSTANT_P}, so you need not check this.\n\nThe default definition returns true.", "bool", "TARGET_" "legitimate_constant_p", "(machine_mode mode, rtx x)", "hook_bool_mode_rtx_true", "Target Hook" },
# 2724 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if @var{x} is of a form that cannot (or\nshould not) be spilled to the constant pool.  @var{mode} is the mode\nof @var{x}.\n\nThe default version of this hook returns false.\n\nThe primary reason to define this hook is to prevent reload from\ndeciding that a non-legitimate constant would be better reloaded\nfrom the constant pool instead of spilling and reloading a register\nholding the constant.  This restriction is often true of addresses\nof TLS symbols for various targets.", "bool", "TARGET_" "cannot_force_const_mem", "(machine_mode mode, rtx x)", "hook_bool_mode_rtx_false", "Target Hook" },
# 2740 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "bool", "TARGET_" "cannot_copy_insn_p", "(rtx_insn *)", "NULL", "Target Hook" },





{ "This target hook returns @code{true} if @var{x} is considered to be commutative.\nUsually, this is just COMMUTATIVE_P (@var{x}), but the HP PA doesn't consider\nPLUS to be commutative inside a MEM@.  @var{outer_code} is the rtx code\nof the enclosing rtl, if known, otherwise it is UNKNOWN.", "bool", "TARGET_" "commutative_p", "(const_rtx x, int outer_code)", "hook_bool_const_rtx_commutative_p", "Target Hook" },
# 2757 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns @code{true} if memory address @var{addr} in address\nspace @var{addrspace} can have\ndifferent meanings depending on the machine mode of the memory\nreference it is used for or if the address is valid for some modes\nbut not others.\n\nAutoincrement and autodecrement addresses typically have mode-dependent\neffects because the amount of the increment or decrement is the size\nof the operand being addressed.  Some machines have other mode-dependent\naddresses.  Many RISC machines have no mode-dependent addresses.\n\nYou may assume that @var{addr} is a valid address for the machine.\n\nThe default version of this hook returns @code{false}.", "bool", "TARGET_" "mode_dependent_address_p", "(const_rtx addr, addr_space_t addrspace)", "default_mode_dependent_address_p", "Target Hook" },
# 2778 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is given an invalid memory address @var{x} for an\noperand of mode @var{mode} and should try to return a valid memory\naddress.\n\n@findex break_out_memory_refs\n@var{x} will always be the result of a call to @code{break_out_memory_refs},\nand @var{oldx} will be the operand that was given to that function to produce\n@var{x}.\n\nThe code of the hook should not alter the substructure of\n@var{x}.  If it transforms @var{x} into a more legitimate form, it\nshould return the new @var{x}.\n\nIt is not necessary for this hook to come up with a legitimate address,\nwith the exception of native TLS addresses (@pxref{Emulated TLS}).\nThe compiler has standard ways of doing so in all cases.  In fact, if\nthe target supports only emulated TLS, it\nis safe to omit this hook or make it return @var{x} if it cannot find\na valid way to legitimize the address.  But often a machine-dependent\nstrategy can generate better code.", "rtx", "TARGET_" "legitimize_address", "(rtx x, rtx oldx, machine_mode mode)", "default_legitimize_address", "Target Hook" },
# 2804 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used to undo the possibly obfuscating effects of the\n@code{LEGITIMIZE_ADDRESS} and @code{LEGITIMIZE_RELOAD_ADDRESS} target\nmacros.  Some backend implementations of these macros wrap symbol\nreferences inside an @code{UNSPEC} rtx to represent PIC or similar\naddressing modes.  This target hook allows GCC's optimizers to understand\nthe semantics of these opaque @code{UNSPEC}s by converting them back\ninto their original form.", "rtx", "TARGET_" "delegitimize_address", "(rtx x)", "delegitimize_mem_from_attrs", "Target Hook" },
# 2818 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if @var{x} should not be emitted into\ndebug sections.", "bool", "TARGET_" "const_not_ok_for_debug_p", "(rtx x)", "default_const_not_ok_for_debug_p", "Target Hook" },







{ "A function that returns whether @var{x} (an RTX) is a legitimate memory\naddress on the target machine for a memory operand of mode @var{mode}.\n\nLegitimate addresses are defined in two variants: a strict variant and a\nnon-strict one.  The @var{strict} parameter chooses which variant is\ndesired by the caller.\n\nThe strict variant is used in the reload pass.  It must be defined so\nthat any pseudo-register that has not been allocated a hard register is\nconsidered a memory reference.  This is because in contexts where some\nkind of register is required, a pseudo-register with no hard register\nmust be rejected.  For non-hard registers, the strict variant should look\nup the @code{reg_renumber} array; it should then proceed using the hard\nregister number in the array, or treat the pseudo as a memory reference\nif the array holds @code{-1}.\n\nThe non-strict variant is used in other passes.  It must be defined to\naccept all pseudo-registers in every context where some kind of\nregister is required.\n\nNormally, constant addresses which are the sum of a @code{symbol_ref}\nand an integer are stored inside a @code{const} RTX to mark them as\nconstant.  Therefore, there is no need to recognize such sums\nspecifically as legitimate addresses.  Normally you would simply\nrecognize any @code{const} as legitimate.\n\nUsually @code{PRINT_OPERAND_ADDRESS} is not prepared to handle constant\nsums that are not marked with  @code{const}.  It assumes that a naked\n@code{plus} indicates indexing.  If so, then you @emph{must} reject such\nnaked constant sums as illegitimate addresses, so that none of them will\nbe given to @code{PRINT_OPERAND_ADDRESS}.\n\n@cindex @code{TARGET_ENCODE_SECTION_INFO} and address validation\nOn some machines, whether a symbolic address is legitimate depends on\nthe section that the address refers to.  On these machines, define the\ntarget hook @code{TARGET_ENCODE_SECTION_INFO} to store the information\ninto the @code{symbol_ref}, and then check for it here.  When you see a\n@code{const}, you will have to look inside it to find the\n@code{symbol_ref} in order to determine the section.  @xref{Assembler\nFormat}.\n\n@cindex @code{GO_IF_LEGITIMATE_ADDRESS}\nSome ports are still using a deprecated legacy substitute for\nthis hook, the @code{GO_IF_LEGITIMATE_ADDRESS} macro.  This macro\nhas this syntax:\n\n@example\n#define GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{label})\n@end example\n\n@noindent\nand should @code{goto @var{label}} if the address @var{x} is a valid\naddress on the target machine for a memory operand of mode @var{mode}.\n\n@findex REG_OK_STRICT\nCompiler source files that want to use the strict variant of this\nmacro define the macro @code{REG_OK_STRICT}.  You should use an\n@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in\nthat case and the non-strict variant otherwise.\n\nUsing the hook is usually simpler because it limits the number of\nfiles that are recompiled when changes are made.", "bool", "TARGET_" "legitimate_address_p", "(machine_mode mode, rtx x, bool strict)", "default_legitimate_address_p", "Target Hook" },
# 2894 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if pool entries for constant @var{x} can\nbe placed in an @code{object_block} structure.  @var{mode} is the mode\nof @var{x}.\n\nThe default version returns false for all constants.", "bool", "TARGET_" "use_blocks_for_constant_p", "(machine_mode mode, const_rtx x)", "hook_bool_mode_const_rtx_false", "Target Hook" },
# 2905 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if pool entries for @var{decl} should\nbe placed in an @code{object_block} structure.\n\nThe default version returns true for all decls.", "bool", "TARGET_" "use_blocks_for_decl_p", "(const_tree decl)", "hook_bool_const_tree_true", "Target Hook" },
# 2915 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The minimum offset that should be applied to a section anchor.\nOn most targets, it should be the smallest offset that can be\napplied to a base register while still giving a legitimate address\nfor every mode.  The default value is 0.", "HOST_WIDE_INT", "TARGET_" "min_anchor_offset", 0, "0", "Target Hook" },







{ "Like @code{TARGET_MIN_ANCHOR_OFFSET}, but the maximum (inclusive)\noffset that should be applied to section anchors.  The default\nvalue is 0.", "HOST_WIDE_INT", "TARGET_" "max_anchor_offset", 0, "0", "Target Hook" },







{ "Return true if GCC should attempt to use anchors to access @code{SYMBOL_REF}\n@var{x}.  You can assume @samp{SYMBOL_REF_HAS_BLOCK_INFO_P (@var{x})} and\n@samp{!SYMBOL_REF_ANCHOR_P (@var{x})}.\n\nThe default version is correct for most targets, but you might need to\nintercept this hook to handle things like target-specific attributes\nor target-specific sections.", "bool", "TARGET_" "use_anchors_for_symbol_p", "(const_rtx x)", "default_use_anchors_for_symbol_p", "Target Hook" },
# 2944 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "It returns true if the target supports GNU indirect functions.\nThe support includes the assembler, linker and dynamic linker.\nThe default value of this hook is based on target's libc.", "bool", "TARGET_" "has_ifunc_p", "(void)", "default_has_ifunc_p", "Target Hook" },
# 2955 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "True if it is OK to do sibling call optimization for the specified\ncall expression @var{exp}.  @var{decl} will be the called function,\nor @code{NULL} if this is an indirect call.\n\nIt is not uncommon for limitations of calling conventions to prevent\ntail calls to functions outside the current unit of translation, or\nduring PIC compilation.  The hook is used to enforce these restrictions,\nas the @code{sibcall} md pattern cannot fail, or fall over to a\n``normal'' call.  The criteria for successful sibling call optimization\nmay vary greatly between different architectures.", "bool", "TARGET_" "function_ok_for_sibcall", "(tree decl, tree exp)", "hook_bool_tree_tree_false", "Target Hook" },
# 2973 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The compiler invokes this hook whenever it changes its current function\ncontext (@code{cfun}).  You can define this function if\nthe back end needs to perform any initialization or reset actions on a\nper-function basis.  For example, it may be used to implement function\nattributes that affect register usage or code generation patterns.\nThe argument @var{decl} is the declaration for the new function context,\nand may be null to indicate that the compiler has left a function context\nand is returning to processing at the top level.\nThe default hook function does nothing.\n\nGCC sets @code{cfun} to a dummy function context during initialization of\nsome parts of the back end.  The hook function is not invoked in this\nsituation; you need not worry about the hook being invoked recursively,\nor when the back end is in a partially-initialized state.\n@code{cfun} might be @code{NULL} to indicate processing at top level,\noutside of any function scope.", "void", "TARGET_" "set_current_function", "(tree decl)", "hook_void_tree", "Target Hook" },
# 2994 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Returns true if @var{exp} should be placed into a ``small data'' section.\nThe default version of this hook always returns false.", "bool", "TARGET_" "in_small_data_p", "(const_tree exp)", "hook_bool_const_tree_false", "Target Hook" },
# 3003 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Returns true if @var{exp} names an object for which name resolution\nrules must resolve to the current ``module'' (dynamic shared library\nor executable image).\n\nThe default version of this hook implements the name resolution rules\nfor ELF, which has a looser model of global name binding than other\ncurrently supported object file formats.", "bool", "TARGET_" "binds_local_p", "(const_tree exp)", "default_binds_local_p", "Target Hook" },
# 3016 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "It returns true if target wants profile code emitted before prologue.\n\nThe default version of this hook use the target macro\n@code{PROFILE_BEFORE_PROLOGUE}.", "bool", "TARGET_" "profile_before_prologue", "(void)", "default_profile_before_prologue", "Target Hook" },
# 3026 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns true if the target wants the leaf flag for the current function to stay true even if it calls mcount.  This might make sense for targets using the leaf flag only to determine whether a stack frame needs to be generated or not and for which the call to mcount is generated before the function prologue.", "bool", "TARGET_" "keep_leaf_when_profiled", "(void)", "default_keep_leaf_when_profiled", "Target Hook" },
# 3040 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if you need to postprocess the assembler name generated\nby target-independent code.  The @var{id} provided to this hook will be\nthe computed name (e.g., the macro @code{DECL_NAME} of the @var{decl} in C,\nor the mangled name of the @var{decl} in C++).  The return value of the\nhook is an @code{IDENTIFIER_NODE} for the appropriate mangled name on\nyour target system.  The default implementation of this hook just\nreturns the @var{id} provided.", "tree", "TARGET_" "mangle_decl_assembler_name", "(tree decl, tree id)", "default_mangle_decl_assembler_name", "Target Hook" },
# 3054 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if references to a symbol or a constant must be\ntreated differently depending on something about the variable or\nfunction named by the symbol (such as what section it is in).\n\nThe hook is executed immediately after rtl has been created for\n@var{decl}, which may be a variable or function declaration or\nan entry in the constant pool.  In either case, @var{rtl} is the\nrtl in question.  Do @emph{not} use @code{DECL_RTL (@var{decl})}\nin this hook; that field may not have been initialized yet.\n\nIn the case of a constant, it is safe to assume that the rtl is\na @code{mem} whose address is a @code{symbol_ref}.  Most decls\nwill also have this form, but that is not guaranteed.  Global\nregister variables, for instance, will have a @code{reg} for their\nrtl.  (Normally the right thing to do with such unusual rtl is\nleave it alone.)\n\nThe @var{new_decl_p} argument will be true if this is the first time\nthat @code{TARGET_ENCODE_SECTION_INFO} has been invoked on this decl.  It will\nbe false for subsequent invocations, which will happen for duplicate\ndeclarations.  Whether or not anything must be done for the duplicate\ndeclaration depends on whether the hook examines @code{DECL_ATTRIBUTES}.\n@var{new_decl_p} is always true when the hook is called for a constant.\n\n@cindex @code{SYMBOL_REF_FLAG}, in @code{TARGET_ENCODE_SECTION_INFO}\nThe usual thing for this hook to do is to record flags in the\n@code{symbol_ref}, using @code{SYMBOL_REF_FLAG} or @code{SYMBOL_REF_FLAGS}.\nHistorically, the name string was modified if it was necessary to\nencode more than one bit of information, but this practice is now\ndiscouraged; use @code{SYMBOL_REF_FLAGS}.\n\nThe default definition of this hook, @code{default_encode_section_info}\nin @file{varasm.c}, sets a number of commonly-useful bits in\n@code{SYMBOL_REF_FLAGS}.  Check whether the default does what you need\nbefore overriding it.", "void", "TARGET_" "encode_section_info", "(tree decl, rtx rtl, int new_decl_p)", "default_encode_section_info", "Target Hook" },
# 3095 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Decode @var{name} and return the real name part, sans\nthe characters that @code{TARGET_ENCODE_SECTION_INFO}\nmay have added.", "const char *", "TARGET_" "strip_name_encoding", "(const char *name)", "default_strip_name_encoding", "Target Hook" },
# 3105 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This function describes how the standard shift patterns for @var{mode}\ndeal with shifts by negative amounts or by more than the width of the mode.\n@xref{shift patterns}.\n\nOn many machines, the shift patterns will apply a mask @var{m} to the\nshift count, meaning that a fixed-width shift of @var{x} by @var{y} is\nequivalent to an arbitrary-width shift of @var{x} by @var{y & m}.  If\nthis is true for mode @var{mode}, the function should return @var{m},\notherwise it should return 0.  A return value of 0 indicates that no\nparticular behavior is guaranteed.\n\nNote that, unlike @code{SHIFT_COUNT_TRUNCATED}, this function does\n@emph{not} apply to general shift rtxes; it applies only to instructions\nthat are generated by the named shift patterns.\n\nThe default implementation of this function returns\n@code{GET_MODE_BITSIZE (@var{mode}) - 1} if @code{SHIFT_COUNT_TRUNCATED}\nand 0 otherwise.  This definition is always safe, but if\n@code{SHIFT_COUNT_TRUNCATED} is false, and some shift patterns\nnevertheless truncate the shift count, you may get better code\nby overriding it.", "unsigned HOST_WIDE_INT", "TARGET_" "shift_truncation_mask", "(machine_mode mode)", "default_shift_truncation_mask", "Target Hook" },
# 3134 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "When @option{-ffast-math} is in effect, GCC tries to optimize\ndivisions by the same divisor, by turning them into multiplications by\nthe reciprocal.  This target hook specifies the minimum number of divisions\nthat should be there for GCC to perform the optimization for a variable\nof mode @var{mode}.  The default implementation returns 3 if the machine\nhas an instruction for the division, and 2 if it does not.", "unsigned int", "TARGET_" "min_divisions_for_recip_mul", "(machine_mode mode)", "default_min_divisions_for_recip_mul", "Target Hook" },
# 3145 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if it is safe to ``convert'' a value of\n@var{inprec} bits to one of @var{outprec} bits (where @var{outprec} is\nsmaller than @var{inprec}) by merely operating on it as if it had only\n@var{outprec} bits.  The default returns true unconditionally, which\nis correct for most machines.  When @code{TARGET_TRULY_NOOP_TRUNCATION}\nreturns false, the machine description should provide a @code{trunc}\noptab to specify the RTL that performs the required truncation.\n\nIf @code{TARGET_MODES_TIEABLE_P} returns false for a pair of modes,\nsuboptimal code can result if this hook returns true for the corresponding\nmode sizes.  Making this hook return false in such cases may improve things.", "bool", "TARGET_" "truly_noop_truncation", "(poly_uint64 outprec, poly_uint64 inprec)", "hook_bool_puint64_puint64_true", "Target Hook" },
# 3166 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The representation of an integral mode can be such that the values\nare always extended to a wider integral mode.  Return\n@code{SIGN_EXTEND} if values of @var{mode} are represented in\nsign-extended form to @var{rep_mode}.  Return @code{UNKNOWN}\notherwise.  (Currently, none of the targets use zero-extended\nrepresentation this way so unlike @code{LOAD_EXTEND_OP},\n@code{TARGET_MODE_REP_EXTENDED} is expected to return either\n@code{SIGN_EXTEND} or @code{UNKNOWN}.  Also no target extends\n@var{mode} to @var{rep_mode} so that @var{rep_mode} is not the next\nwidest integral mode and currently we take advantage of this fact.)\n\nSimilarly to @code{LOAD_EXTEND_OP} you may return a non-@code{UNKNOWN}\nvalue even if the extension is not performed on certain hard registers\nas long as for the @code{REGNO_REG_CLASS} of these hard registers\n@code{TARGET_CAN_CHANGE_MODE_CLASS} returns false.\n\nNote that @code{TARGET_MODE_REP_EXTENDED} and @code{LOAD_EXTEND_OP}\ndescribe two related properties.  If you define\n@code{TARGET_MODE_REP_EXTENDED (mode, word_mode)} you probably also want\nto define @code{LOAD_EXTEND_OP (mode)} to return the same type of\nextension.\n\nIn order to enforce the representation of @code{mode},\n@code{TARGET_TRULY_NOOP_TRUNCATION} should return false when truncating to\n@code{mode}.", "int", "TARGET_" "mode_rep_extended", "(scalar_int_mode mode, scalar_int_mode rep_mode)", "default_mode_rep_extended", "Target Hook" },
# 3196 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
 { "On some targets, it is assumed that the compiler will spill all pseudos\n  that are live across a call to @code{setjmp}, while other targets treat\n  @code{setjmp} calls as normal function calls.\n  \n  This hook returns false if @code{setjmp} calls do not preserve all\n  non-volatile registers so that gcc that must spill all pseudos that are\n  live across @code{setjmp} calls.  Define this to return true if the\n  target does not need to spill all pseudos live across @code{setjmp} calls.\n  The default implementation conservatively assumes all pseudos must be\n  spilled across @code{setjmp} calls.", "bool", "TARGET_" "setjmp_preserves_nonvolatile_regs_p", "(void)", "hook_bool_void_false", "Target Hook" },
# 3212 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if the port can handle pointers\nwith machine mode @var{mode}.  The default version of this\nhook returns true for both @code{ptr_mode} and @code{Pmode}.", "bool", "TARGET_" "valid_pointer_mode", "(scalar_int_mode mode)", "default_valid_pointer_mode", "Target Hook" },
# 3221 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if the memory reference @var{ref}  may alias with the system C library errno location.  The default  version of this hook assumes the system C library errno location  is either a declaration of type int or accessed by dereferencing  a pointer to int.", "bool", "TARGET_" "ref_may_alias_errno", "(ao_ref *ref)", "default_ref_may_alias_errno", "Target Hook" },
# 3234 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "TARGET_ADDR_SPACE_HOOKS", 0, 0, "Target Hook" },


{ "Define this to return the machine mode to use for pointers to\n@var{address_space} if the target supports named address spaces.\nThe default version of this hook returns @code{ptr_mode}.", "scalar_int_mode", "TARGET_ADDR_SPACE_" "pointer_mode", "(addr_space_t address_space)", "default_addr_space_pointer_mode", "Target Hook" },
# 3246 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return the machine mode to use for addresses in\n@var{address_space} if the target supports named address spaces.\nThe default version of this hook returns @code{Pmode}.", "scalar_int_mode", "TARGET_ADDR_SPACE_" "address_mode", "(addr_space_t address_space)", "default_addr_space_address_mode", "Target Hook" },
# 3256 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if the port can handle pointers\nwith machine mode @var{mode} to address space @var{as}.  This target\nhook is the same as the @code{TARGET_VALID_POINTER_MODE} target hook,\nexcept that it includes explicit named address space support.  The default\nversion of this hook returns true for the modes returned by either the\n@code{TARGET_ADDR_SPACE_POINTER_MODE} or @code{TARGET_ADDR_SPACE_ADDRESS_MODE}\ntarget hooks for the given address space.", "bool", "TARGET_ADDR_SPACE_" "valid_pointer_mode", "(scalar_int_mode mode, addr_space_t as)", "default_addr_space_valid_pointer_mode", "Target Hook" },
# 3270 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return true if @var{exp} is a valid address for mode\n@var{mode} in the named address space @var{as}.  The @var{strict}\nparameter says whether strict addressing is in effect after reload has\nfinished.  This target hook is the same as the\n@code{TARGET_LEGITIMATE_ADDRESS_P} target hook, except that it includes\nexplicit named address space support.", "bool", "TARGET_ADDR_SPACE_" "legitimate_address_p", "(machine_mode mode, rtx exp, bool strict, addr_space_t as)", "default_addr_space_legitimate_address_p", "Target Hook" },
# 3284 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to modify an invalid address @var{x} to be a valid address\nwith mode @var{mode} in the named address space @var{as}.  This target\nhook is the same as the @code{TARGET_LEGITIMIZE_ADDRESS} target hook,\nexcept that it includes explicit named address space support.", "rtx", "TARGET_ADDR_SPACE_" "legitimize_address", "(rtx x, rtx oldx, machine_mode mode, addr_space_t as)", "default_addr_space_legitimize_address", "Target Hook" },
# 3294 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return whether the @var{subset} named address space is\ncontained within the @var{superset} named address space.  Pointers to\na named address space that is a subset of another named address space\nwill be converted automatically without a cast if used together in\narithmetic operations.  Pointers to a superset address space can be\nconverted to pointers to a subset address space via explicit casts.", "bool", "TARGET_ADDR_SPACE_" "subset_p", "(addr_space_t subset, addr_space_t superset)", "default_addr_space_subset_p", "Target Hook" },
# 3307 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to modify the default handling of address 0 for the\naddress space.  Return true if 0 should be considered a valid address.", "bool", "TARGET_ADDR_SPACE_" "zero_address_valid", "(addr_space_t as)", "default_addr_space_zero_address_valid", "Target Hook" },







{ "Define this to convert the pointer expression represented by the RTL\n@var{op} with type @var{from_type} that points to a named address\nspace to a new pointer expression with type @var{to_type} that points\nto a different named address space.  When this hook it called, it is\nguaranteed that one of the two address spaces is a subset of the other,\nas determined by the @code{TARGET_ADDR_SPACE_SUBSET_P} target hook.", "rtx", "TARGET_ADDR_SPACE_" "convert", "(rtx op, tree from_type, tree to_type)", "default_addr_space_convert", "Target Hook" },
# 3327 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to define how the address space is encoded in dwarf.\nThe result is the value to be used with @code{DW_AT_address_class}.", "int", "TARGET_ADDR_SPACE_" "debug", "(addr_space_t as)", "default_addr_space_debug", "Target Hook" },







{ "Define this hook if the availability of an address space depends on\ncommand line options and some diagnostics should be printed when the\naddress space is used.  This hook is called during parsing and allows\nto emit a better diagnostic compared to the case where the address space\nwas not registered with @code{c_register_addr_space}.  @var{as} is\nthe address space as registered with @code{c_register_addr_space}.\n@var{loc} is the location of the address space qualifier token.\nThe default implementation does nothing.", "void", "TARGET_ADDR_SPACE_" "diagnose_usage", "(addr_space_t as, location_t loc)", "default_addr_space_diagnose_usage", "Target Hook" },
# 3348 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ "Define this hook to lower alignment of local, parm or result\ndecl @samp{(@var{decl})}.", "void", "TARGET_" "lower_local_decl_alignment", "(tree decl)", "hook_void_tree", "Target Hook" },






{ "This hook returns the preferred alignment in bits for a\nstatically-allocated rtx, such as a constant pool entry.  @var{mode}\nis the mode of the rtx.  The default implementation returns\n@samp{GET_MODE_ALIGNMENT (@var{mode})}.", "HOST_WIDE_INT", "TARGET_" "static_rtx_alignment", "(machine_mode mode)", "default_static_rtx_alignment", "Target Hook" },
# 3369 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the alignment in bits of a constant that is being\nplaced in memory.  @var{constant} is the constant and @var{basic_align}\nis the alignment that the object would ordinarily have.\n\nThe default definition just returns @var{basic_align}.\n\nThe typical use of this hook is to increase alignment for string\nconstants to be word aligned so that @code{strcpy} calls that copy\nconstants can be done inline.  The function\n@code{constant_alignment_word_strings} provides such a definition.", "HOST_WIDE_INT", "TARGET_" "constant_alignment", "(const_tree constant, HOST_WIDE_INT basic_align)", "default_constant_alignment", "Target Hook" },
# 3384 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if during mode attribute processing, the port should\ntranslate machine_mode @var{mode} to another mode.  For example, rs6000's\n@code{KFmode}, when it is the same as @code{TFmode}.\n\nThe default version of the hook returns that mode that was passed in.", "machine_mode", "TARGET_" "translate_mode_attribute", "(machine_mode mode)", "default_translate_mode_attribute", "Target Hook" },
# 3397 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if the port is prepared to handle\ninsns involving scalar mode @var{mode}.  For a scalar mode to be\nconsidered supported, all the basic arithmetic and comparisons\nmust work.\n\nThe default version of this hook returns true for any mode\nrequired to handle the basic C types (as defined by the port).\nIncluded here are the double-word arithmetic supported by the\ncode in @file{optabs.c}.", "bool", "TARGET_" "scalar_mode_supported_p", "(scalar_mode mode)", "default_scalar_mode_supported_p", "Target Hook" },
# 3414 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if the port is prepared to handle\ninsns involving vector mode @var{mode}.  At the very least, it\nmust have move patterns for this mode.", "bool", "TARGET_" "vector_mode_supported_p", "(machine_mode mode)", "hook_bool_mode_false", "Target Hook" },







{ "Return true if there is no target-specific reason for treating\nvector types @var{type1} and @var{type2} as distinct types.  The caller\nhas already checked for target-independent reasons, meaning that the\ntypes are known to have the same mode, to have the same number of elements,\nand to have what the caller considers to be compatible element types.\n\nThe main reason for defining this hook is to reject pairs of types\nthat are handled differently by the target's calling convention.\nFor example, when a new @var{N}-bit vector architecture is added\nto a target, the target may want to handle normal @var{N}-bit\n@code{VECTOR_TYPE} arguments and return values in the same way as\nbefore, to maintain backwards compatibility.  However, it may also\nprovide new, architecture-specific @code{VECTOR_TYPE}s that are passed\nand returned in a more efficient way.  It is then important to maintain\na distinction between the ``normal'' @code{VECTOR_TYPE}s and the new\narchitecture-specific ones.\n\nThe default implementation returns true, which is correct for most targets.", "bool", "TARGET_" "compatible_vector_types_p", "(const_tree type1, const_tree type2)", "hook_bool_const_tree_const_tree_true", "Target Hook" },
# 3445 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook can be used to define the alignment for a vector of type\n@var{type}, in order to comply with a platform ABI.  The default is to\nrequire natural alignment for vector types.  The alignment returned by\nthis hook must be a power-of-two multiple of the default alignment of\nthe vector element type.", "HOST_WIDE_INT", "TARGET_" "vector_alignment", "(const_tree type)", "default_vector_alignment", "Target Hook" },
# 3455 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the mode that GCC should use for an array that has\n@var{nelems} elements, with each element having mode @var{mode}.\nReturn no mode if the target has no special requirements.  In the\nlatter case, GCC looks for an integer mode of the appropriate size\nif available and uses BLKmode otherwise.  Usually the search for the\ninteger mode is limited to @code{MAX_FIXED_MODE_SIZE}, but the\n@code{TARGET_ARRAY_MODE_SUPPORTED_P} hook allows a larger mode to be\nused in specific cases.\n\nThe main use of this hook is to specify that an array of vectors should\nalso have a vector mode.  The default implementation returns no mode.", "opt_machine_mode", "TARGET_" "array_mode", "(machine_mode mode, unsigned HOST_WIDE_INT nelems)", "hook_optmode_mode_uhwi_none", "Target Hook" },
# 3473 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if GCC should try to use a scalar mode to store an array\nof @var{nelems} elements, given that each element has mode @var{mode}.\nReturning true here overrides the usual @code{MAX_FIXED_MODE} limit\nand allows GCC to use any defined integer mode.\n\nOne use of this hook is to support vector load and store operations\nthat operate on several homogeneous vectors.  For example, ARM NEON\nhas operations like:\n\n@smallexample\nint8x8x3_t vld3_s8 (const int8_t *)\n@end smallexample\n\nwhere the return type is defined as:\n\n@smallexample\ntypedef struct int8x8x3_t\n@{\n  int8x8_t val[3];\n@} int8x8x3_t;\n@end smallexample\n\nIf this hook allows @code{val} to have a scalar mode, then\n@code{int8x8x3_t} can have the same mode.  GCC can then store\n@code{int8x8x3_t}s in registers rather than forcing them onto the stack.", "bool", "TARGET_" "array_mode_supported_p", "(machine_mode mode, unsigned HOST_WIDE_INT nelems)", "hook_bool_mode_uhwi_false", "Target Hook" },
# 3503 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero if libgcc provides support for the \nfloating-point mode @var{mode}, which is known to pass \n@code{TARGET_SCALAR_MODE_SUPPORTED_P}.  The default version of this \nhook returns true for all of @code{SFmode}, @code{DFmode}, \n@code{XFmode} and @code{TFmode}, if such modes exist.", "bool", "TARGET_" "libgcc_floating_mode_supported_p", "(scalar_float_mode mode)", "default_libgcc_floating_mode_supported_p", "Target Hook" },
# 3513 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return the machine mode to use for the type \n@code{_Float@var{n}}, if @var{extended} is false, or the type \n@code{_Float@var{n}x}, if @var{extended} is true.  If such a type is not\nsupported, return @code{opt_scalar_float_mode ()}.  The default version of\nthis hook returns @code{SFmode} for @code{_Float32}, @code{DFmode} for\n@code{_Float64} and @code{_Float32x} and @code{TFmode} for \n@code{_Float128}, if those modes exist and satisfy the requirements for \nthose types and pass @code{TARGET_SCALAR_MODE_SUPPORTED_P} and \n@code{TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P}; for @code{_Float64x}, it \nreturns the first of @code{XFmode} and @code{TFmode} that exists and \nsatisfies the same requirements; for other types, it returns \n@code{opt_scalar_float_mode ()}.  The hook is only called for values\nof @var{n} and @var{extended} that are valid according to\nISO/IEC TS 18661-3:2015; that is, @var{n} is one of 32, 64, 128, or,\nif @var{extended} is false, 16 or greater than 128 and a multiple of 32.", "opt_scalar_float_mode", "TARGET_" "floatn_mode", "(int n, bool extended)", "default_floatn_mode", "Target Hook" },
# 3533 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return true if the @code{_Float@var{n}} and\n@code{_Float@var{n}x} built-in functions should implicitly enable the\nbuilt-in function without the @code{__builtin_} prefix in addition to the\nnormal built-in function with the @code{__builtin_} prefix.  The default is\nto only enable built-in functions without the @code{__builtin_} prefix for\nthe GNU C langauge.  In strict ANSI/ISO mode, the built-in function without\nthe @code{__builtin_} prefix is not enabled.  The argument @code{FUNC} is the\n@code{enum built_in_function} id of the function to be enabled.", "bool", "TARGET_" "floatn_builtin_p", "(int func)", "default_floatn_builtin_p", "Target Hook" },
# 3548 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return the cost of moving data of mode @var{mode}\nfrom a register in class @var{from} to one in class @var{to}.  The classes\nare expressed using the enumeration values such as @code{GENERAL_REGS}.\nA value of 2 is the default; other values are interpreted relative to\nthat.\n\nIt is not required that the cost always equal 2 when @var{from} is the\nsame as @var{to}; on some machines it is expensive to move between\nregisters if they are not general registers.\n\nIf reload sees an insn consisting of a single @code{set} between two\nhard registers, and if @code{TARGET_REGISTER_MOVE_COST} applied to their\nclasses returns a value of 2, reload does not check to ensure that the\nconstraints of the insn are met.  Setting a cost of other than 2 will\nallow reload to verify that the constraints are met.  You should do this\nif the @samp{mov@var{m}} pattern's constraints do not allow such copying.\n\nThe default version of this function returns 2.", "int", "TARGET_" "register_move_cost", "(machine_mode mode, reg_class_t from, reg_class_t to)", "default_register_move_cost", "Target Hook" },
# 3574 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return the cost of moving data of mode @var{mode}\nbetween a register of class @var{rclass} and memory; @var{in} is @code{false}\nif the value is to be written to memory, @code{true} if it is to be read in.\nThis cost is relative to those in @code{TARGET_REGISTER_MOVE_COST}.\nIf moving between registers and memory is more expensive than between two\nregisters, you should add this target hook to express the relative cost.\n\nIf you do not add this target hook, GCC uses a default cost of 4 plus\nthe cost of copying via a secondary reload register, if one is\nneeded.  If your machine requires a secondary reload register to copy\nbetween memory and a register of @var{rclass} but the reload mechanism is\nmore complex than copying via an intermediate, use this target hook to\nreflect the actual cost of the move.\n\nGCC defines the function @code{memory_move_secondary_cost} if\nsecondary reloads are needed.  It computes the costs due to copying via\na secondary register.  If your machine copies from memory using a\nsecondary register in the conventional way but the default base value of\n4 is not correct for your machine, use this target hook to add some other\nvalue to the result of that function.  The arguments to that function\nare the same as to this target hook.", "int", "TARGET_" "memory_move_cost", "(machine_mode mode, reg_class_t rclass, bool in)", "default_memory_move_cost", "Target Hook" },
# 3600 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "GCC will attempt several strategies when asked to copy between\ntwo areas of memory, or to set, clear or store to memory, for example\nwhen copying a @code{struct}. The @code{by_pieces} infrastructure\nimplements such memory operations as a sequence of load, store or move\ninsns.  Alternate strategies are to expand the\n@code{cpymem} or @code{setmem} optabs, to emit a library call, or to emit\nunit-by-unit, loop-based operations.\n\nThis target hook should return true if, for a memory operation with a\ngiven @var{size} and @var{alignment}, using the @code{by_pieces}\ninfrastructure is expected to result in better code generation.\nBoth @var{size} and @var{alignment} are measured in terms of storage\nunits.\n\nThe parameter @var{op} is one of: @code{CLEAR_BY_PIECES},\n@code{MOVE_BY_PIECES}, @code{SET_BY_PIECES}, @code{STORE_BY_PIECES} or\n@code{COMPARE_BY_PIECES}.  These describe the type of memory operation\nunder consideration.\n\nThe parameter @var{speed_p} is true if the code is currently being\noptimized for speed rather than size.\n\nReturning true for higher values of @var{size} can improve code generation\nfor speed if the target does not provide an implementation of the\n@code{cpymem} or @code{setmem} standard names, if the @code{cpymem} or\n@code{setmem} implementation would be more expensive than a sequence of\ninsns, or if the overhead of a library call would dominate that of\nthe body of the memory operation.\n\nReturning true for higher values of @code{size} may also cause an increase\nin code size, for example where the number of insns emitted to perform a\nmove would be greater than that of a library call.", "bool", "TARGET_" "use_by_pieces_infrastructure_p", "(unsigned HOST_WIDE_INT size, unsigned int alignment, enum by_pieces_operation op, bool speed_p)", "default_use_by_pieces_infrastructure_p", "Target Hook" },
# 3638 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "When expanding a block comparison in MODE, gcc can try to reduce the\nnumber of branches at the expense of more memory operations.  This hook\nallows the target to override the default choice.  It should return the\nfactor by which branches should be reduced over the plain expansion with\none comparison per @var{mode}-sized piece.  A port can also prevent a\nparticular mode from being used for block comparisons by returning a\nnegative number from this hook.", "int", "TARGET_" "compare_by_pieces_branch_ratio", "(machine_mode mode)", "default_compare_by_pieces_branch_ratio", "Target Hook" },
# 3650 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if memory accesses described by the\n@var{mode} and @var{alignment} parameters have a cost many times greater\nthan aligned accesses, for example if they are emulated in a trap handler.\nThis hook is invoked only for unaligned accesses, i.e.@: when\n@code{@var{alignment} < GET_MODE_ALIGNMENT (@var{mode})}.\n\nWhen this hook returns true, the compiler will act as if\n@code{STRICT_ALIGNMENT} were true when generating code for block\nmoves.  This can cause significantly more instructions to be produced.\nTherefore, do not make this hook return true if unaligned accesses only\nadd a cycle or two to the time for a memory access.\n\nThe hook must return true whenever @code{STRICT_ALIGNMENT} is true.\nThe default implementation returns @code{STRICT_ALIGNMENT}.", "bool", "TARGET_" "slow_unaligned_access", "(machine_mode mode, unsigned int align)", "default_slow_unaligned_access", "Target Hook" },
# 3669 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if the optimizers should use optab @var{op} with\nmodes @var{mode1} and @var{mode2} for optimization type @var{opt_type}.\nThe optab is known to have an associated @file{.md} instruction\nwhose C condition is true.  @var{mode2} is only meaningful for conversion\noptabs; for direct optabs it is a copy of @var{mode1}.\n\nFor example, when called with @var{op} equal to @code{rint_optab} and\n@var{mode1} equal to @code{DFmode}, the hook should say whether the\noptimizers should use optab @code{rintdf2}.\n\nThe default hook returns true for all inputs.", "bool", "TARGET_" "optab_supported_p", "(int op, machine_mode mode1, machine_mode mode2, optimization_type opt_type)", "default_optab_supported_p", "Target Hook" },
# 3690 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to return nonzero for machine modes for which the port has\nsmall register classes.  If this target hook returns nonzero for a given\n@var{mode}, the compiler will try to minimize the lifetime of registers\nin @var{mode}.  The hook may be called with @code{VOIDmode} as argument.\nIn this case, the hook is expected to return nonzero if it returns nonzero\nfor any mode.\n\nOn some machines, it is risky to let hard registers live across arbitrary\ninsns.  Typically, these machines have instructions that require values\nto be in specific registers (like an accumulator), and reload will fail\nif the required hard register is used for another purpose across such an\ninsn.\n\nPasses before reload do not know which hard registers will be used\nin an instruction, but the machine modes of the registers set or used in\nthe instruction are already known.  And for some machines, register\nclasses are small for, say, integer registers but not for floating point\nregisters.  For example, the AMD x86-64 architecture requires specific\nregisters for the legacy x86 integer instructions, but there are many\nSSE registers for floating point operations.  On such targets, a good\nstrategy may be to return nonzero from this hook for @code{INTEGRAL_MODE_P}\nmachine modes but zero for the SSE register classes.\n\nThe default version of this hook returns false for any mode.  It is always\nsafe to redefine this hook to return with a nonzero value.  But if you\nunnecessarily define it, you will reduce the amount of optimizations\nthat can be performed in some cases.  If you do not define this hook\nto return a nonzero value when it is required, the compiler will run out\nof spill registers and print a fatal error message.", "bool", "TARGET_" "small_register_classes_for_mode_p", "(machine_mode mode)", "hook_bool_mode_false", "Target Hook" },
# 3726 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If the target has a dedicated flags register, and it needs to use the\npost-reload comparison elimination pass, or the delay slot filler pass,\nthen this value should be set appropriately.", "unsigned int", "TARGET_" "flags_regnum", 0, "INVALID_REGNUM", "Target Hook" },
# 3738 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook describes the relative costs of RTL expressions.\n\nThe cost may depend on the precise form of the expression, which is\navailable for examination in @var{x}, and the fact that @var{x} appears\nas operand @var{opno} of an expression with rtx code @var{outer_code}.\nThat is, the hook can assume that there is some rtx @var{y} such\nthat @samp{GET_CODE (@var{y}) == @var{outer_code}} and such that\neither (a) @samp{XEXP (@var{y}, @var{opno}) == @var{x}} or\n(b) @samp{XVEC (@var{y}, @var{opno})} contains @var{x}.\n\n@var{mode} is @var{x}'s machine mode, or for cases like @code{const_int} that\ndo not have a mode, the mode in which @var{x} is used.\n\nIn implementing this hook, you can use the construct\n@code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast\ninstructions.\n\nOn entry to the hook, @code{*@var{total}} contains a default estimate\nfor the cost of the expression.  The hook should modify this value as\nnecessary.  Traditionally, the default costs are @code{COSTS_N_INSNS (5)}\nfor multiplications, @code{COSTS_N_INSNS (7)} for division and modulus\noperations, and @code{COSTS_N_INSNS (1)} for all other operations.\n\nWhen optimizing for code size, i.e.@: when @code{speed} is\nfalse, this target hook should be used to estimate the relative\nsize cost of an expression, again relative to @code{COSTS_N_INSNS}.\n\nThe hook returns true when all subexpressions of @var{x} have been\nprocessed, and false when @code{rtx_cost} should recurse.", "bool", "TARGET_" "rtx_costs", "(rtx x, machine_mode mode, int outer_code, int opno, int *total, bool speed)", "hook_bool_rtx_mode_int_int_intp_bool_false", "Target Hook" },
# 3774 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook computes the cost of an addressing mode that contains\n@var{address}.  If not defined, the cost is computed from\nthe @var{address} expression and the @code{TARGET_RTX_COST} hook.\n\nFor most CISC machines, the default cost is a good approximation of the\ntrue cost of the addressing mode.  However, on RISC machines, all\ninstructions normally have the same length and execution time.  Hence\nall addresses will have equal costs.\n\nIn cases where more than one form of an address is known, the form with\nthe lowest cost will be used.  If multiple forms have the same, lowest,\ncost, the one that is the most complex will be used.\n\nFor example, suppose an address that is equal to the sum of a register\nand a constant is used twice in the same basic block.  When this macro\nis not defined, the address will be computed in a register and memory\nreferences will be indirect through that register.  On machines where\nthe cost of the addressing mode containing the sum is no higher than\nthat of a simple indirect reference, this will produce an additional\ninstruction and possibly require an additional register.  Proper\nspecification of this macro eliminates this overhead for such machines.\n\nThis hook is never called with an invalid address.\n\nOn machines where an address involving more than one register is as\ncheap as an address computation involving only one register, defining\n@code{TARGET_ADDRESS_COST} to reflect this can cause two registers to\nbe live over a region of code where only one would have been if\n@code{TARGET_ADDRESS_COST} were not defined in that manner.  This effect\nshould be considered in the definition of this macro.  Equivalent costs\nshould probably only be given to addresses with different numbers of\nregisters on machines with lots of registers.", "int", "TARGET_" "address_cost", "(rtx address, machine_mode mode, addr_space_t as, bool speed)", "default_address_cost", "Target Hook" },
# 3812 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook describes the relative costs of RTL instructions.\n\nIn implementing this hook, you can use the construct\n@code{COSTS_N_INSNS (@var{n})} to specify a cost equal to @var{n} fast\ninstructions.\n\nWhen optimizing for code size, i.e.@: when @code{speed} is\nfalse, this target hook should be used to estimate the relative\nsize cost of an expression, again relative to @code{COSTS_N_INSNS}.", "int", "TARGET_" "insn_cost", "(rtx_insn *insn, bool speed)", "NULL", "Target Hook" },
# 3827 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a value in the same units as @code{TARGET_RTX_COSTS},\ngiving the maximum acceptable cost for a sequence generated by the RTL\nif-conversion pass when conditional execution is not available.\nThe RTL if-conversion pass attempts to convert conditional operations\nthat would require a branch to a series of unconditional operations and\n@code{mov@var{mode}cc} insns.  This hook returns the maximum cost of the\nunconditional instructions and the @code{mov@var{mode}cc} insns.\nRTL if-conversion is cancelled if the cost of the converted sequence\nis greater than the value returned by this hook.\n\n@code{e} is the edge between the basic block containing the conditional\nbranch to the basic block which would be executed if the condition\nwere true.\n\nThe default implementation of this hook uses the\n@code{max-rtl-if-conversion-[un]predictable} parameters if they are set,\nand uses a multiple of @code{BRANCH_COST} otherwise.", "unsigned int", "TARGET_" "max_noce_ifcvt_seq_cost", "(edge e)", "default_max_noce_ifcvt_seq_cost", "Target Hook" },
# 3851 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if the instruction sequence @code{seq} is a good\ncandidate as a replacement for the if-convertible sequence described in\n@code{if_info}.", "bool", "TARGET_" "noce_conversion_profitable_p", "(rtx_insn *seq, struct noce_if_info *if_info)", "default_noce_conversion_profitable_p", "Target Hook" },
# 3861 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return @code{true} if it is profitable to replace the address in\n@var{memref} with @var{new_addr}.  This allows targets to prevent the\nscheduler from undoing address optimizations.  The instruction containing the\nmemref is @var{insn}.  The default implementation returns @code{true}.", "bool", "TARGET_" "new_address_profitable_p", "(rtx memref, rtx_insn * insn, rtx new_addr)", "default_new_address_profitable_p", "Target Hook" },
# 3870 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return an estimate of the runtime value of @var{val}, for use in\nthings like cost calculations or profiling frequencies.  The default\nimplementation returns the lowest possible value of @var{val}.", "HOST_WIDE_INT", "TARGET_" "estimated_poly_value", "(poly_int64 val)", "default_estimated_poly_value", "Target Hook" },
# 3880 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This predicate controls the use of the eager delay slot filler to disallow\nspeculatively executed instructions being placed in delay slots.  Targets\nsuch as certain MIPS architectures possess both branches with and without\ndelay slots.  As the eager delay slot filler can decrease performance,\ndisabling it is beneficial when ordinary branches are available.  Use of\ndelay slot branches filled using the basic filler is often still desirable\nas the delay slot can hide a pipeline bubble.", "bool", "TARGET_" "no_speculation_in_delay_slots_p", "(void)", "hook_bool_void_false", "Target Hook" },
# 3892 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "\nWhen the initial value of a hard register has been copied in a pseudo\nregister, it is often not necessary to actually allocate another register\nto this pseudo register, because the original hard register or a stack slot\nit has been saved into can be used.  @code{TARGET_ALLOCATE_INITIAL_VALUE}\nis called at the start of register allocation once for each hard register\nthat had its initial value copied by using\n@code{get_func_hard_reg_initial_val} or @code{get_hard_reg_initial_val}.\nPossible values are @code{NULL_RTX}, if you don't want\nto do any special allocation, a @code{REG} rtx---that would typically be\nthe hard register itself, if it is known not to be clobbered---or a\n@code{MEM}.\nIf you are returning a @code{MEM}, this is only a hint for the allocator;\nit might decide to use another register anyways.\nYou may use @code{current_function_is_leaf} or \n@code{REG_N_SETS} in the hook to determine if the hard\nregister in question will not be clobbered.\nThe default value of this hook is @code{NULL}, which disables any special\nallocation.", "rtx", "TARGET_" "allocate_initial_value", "(rtx hard_reg)", "NULL", "Target Hook" },
# 3917 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns nonzero if @var{x}, an @code{unspec} or\n@code{unspec_volatile} operation, might cause a trap.  Targets can use\nthis hook to enhance precision of analysis for @code{unspec} and\n@code{unspec_volatile} operations.  You may call @code{may_trap_p_1}\nto analyze inner elements of @var{x} in which case @var{flags} should be\npassed along.", "int", "TARGET_" "unspec_may_trap_p", "(const_rtx x, unsigned flags)", "default_unspec_may_trap_p", "Target Hook" },
# 3934 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Given a register, this hook should return a parallel of registers to\nrepresent where to find the register pieces.  Define this hook if the\nregister and its mode are represented in Dwarf in non-contiguous\nlocations, or if the register should be represented in more than one\nregister in Dwarf.  Otherwise, this hook should return @code{NULL_RTX}.\nIf not defined, the default is to return @code{NULL_RTX}.", "rtx", "TARGET_" "dwarf_register_span", "(rtx reg)", "hook_rtx_rtx_null", "Target Hook" },
# 3947 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Given a register, this hook should return the mode which the\ncorresponding Dwarf frame register should have.  This is normally\nused to return a smaller mode than the raw mode to prevent call\nclobbered parts of a register altering the frame register size", "machine_mode", "TARGET_" "dwarf_frame_reg_mode", "(int regno)", "default_dwarf_frame_reg_mode", "Target Hook" },
# 3960 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If some registers are represented in Dwarf-2 unwind information in\nmultiple pieces, define this hook to fill in information about the\nsizes of those pieces in the table used by the unwinder at runtime.\nIt will be called by @code{expand_builtin_init_dwarf_reg_sizes} after\nfilling in a single size corresponding to each hard register;\n@var{address} is the address of the table.", "void", "TARGET_" "init_dwarf_reg_sizes_extra", "(tree address)", "hook_void_tree", "Target Hook" },
# 3978 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On targets which do not use @code{(cc0)}, and which use a hard\nregister rather than a pseudo-register to hold condition codes, the\nregular CSE passes are often not able to identify cases in which the\nhard register is set to a common value.  Use this hook to enable a\nsmall pass which optimizes such cases.  This hook should return true\nto enable this pass, and it should set the integers to which its\narguments point to the hard register numbers used for condition codes.\nWhen there is only one such register, as is true on most systems, the\ninteger pointed to by @var{p2} should be set to\n@code{INVALID_REGNUM}.\n\nThe default version of this hook returns false.", "bool", "TARGET_" "fixed_condition_code_regs", "(unsigned int *p1, unsigned int *p2)", "hook_bool_uintp_uintp_false", "Target Hook" },
# 4000 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On targets which use multiple condition code modes in class\n@code{MODE_CC}, it is sometimes the case that a comparison can be\nvalidly done in more than one mode.  On such a system, define this\ntarget hook to take two mode arguments and to return a mode in which\nboth comparisons may be validly done.  If there is no such mode,\nreturn @code{VOIDmode}.\n\nThe default version of this hook checks whether the modes are the\nsame.  If they are, it returns that mode.  If they are different, it\nreturns @code{VOIDmode}.", "machine_mode", "TARGET_" "cc_modes_compatible", "(machine_mode m1, machine_mode m2)", "default_cc_modes_compatible", "Target Hook" },
# 4017 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If non-null, this hook performs a target-specific pass over the\ninstruction stream.  The compiler will run it at all optimization levels,\njust before the point at which it normally does delayed-branch scheduling.\n\nThe exact purpose of the hook varies from target to target.  Some use\nit to do transformations that are necessary for correctness, such as\nlaying out in-function constant pools or avoiding hardware hazards.\nOthers use it as an opportunity to do some machine-dependent optimizations.\n\nYou need not implement the hook if it has nothing to do.  The default\ndefinition is null.", "void", "TARGET_" "machine_dependent_reorg", "(void)", "NULL", "Target Hook" },
# 4033 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a type node for @code{va_list} for the target.\nThe default version of the hook returns @code{void*}.", "tree", "TARGET_" "build_builtin_va_list", "(void)", "std_build_builtin_va_list", "Target Hook" },







{ "This target hook is used in function @code{c_common_nodes_and_builtins}\nto iterate through the target specific builtin types for va_list. The\nvariable @var{idx} is used as iterator. @var{pname} has to be a pointer\nto a @code{const char *} and @var{ptree} a pointer to a @code{tree} typed\nvariable.\nThe arguments @var{pname} and @var{ptree} are used to store the result of\nthis macro and are set to the name of the va_list builtin type and its\ninternal type.\nIf the return value of this macro is zero, then there is no more element.\nOtherwise the @var{IDX} should be increased for the next call of this\nmacro to iterate through all types.", "int", "TARGET_" "enum_va_list_p", "(int idx, const char **pname, tree *ptree)", "NULL", "Target Hook" },
# 4058 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the va_list type of the calling convention specified by\n@var{fndecl}.\nThe default version of this hook returns @code{va_list_type_node}.", "tree", "TARGET_" "fn_abi_va_list", "(tree fndecl)", "std_fn_abi_va_list", "Target Hook" },
# 4067 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the va_list type of the calling convention specified by the\ntype of @var{type}. If @var{type} is not a valid va_list type, it returns\n@code{NULL_TREE}.", "tree", "TARGET_" "canonical_va_list_type", "(tree type)", "std_canonical_va_list_type", "Target Hook" },
# 4076 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "void", "TARGET_" "expand_builtin_va_start", "(tree valist, rtx nextarg)", "NULL", "Target Hook" },





{ "This hook performs target-specific gimplification of\n@code{VA_ARG_EXPR}.  The first two parameters correspond to the\narguments to @code{va_arg}; the latter two are as in\n@code{gimplify.c:gimplify_expr}.", "tree", "TARGET_" "gimplify_va_arg_expr", "(tree valist, tree type, gimple_seq *pre_p, gimple_seq *post_p)", "std_gimplify_va_arg_expr", "Target Hook" },
# 4096 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a pointer to the data needed by\n@code{TARGET_PCH_VALID_P} and sets\n@samp{*@var{sz}} to the size of the data in bytes.", "void *", "TARGET_" "get_pch_validity", "(size_t *sz)", "default_get_pch_validity", "Target Hook" },







{ "This hook checks whether the options used to create a PCH file are\ncompatible with the current settings.  It returns @code{NULL}\nif so and a suitable error message if not.  Error messages will\nbe presented to the user and must be localized using @samp{_(@var{msg})}.\n\n@var{data} is the data that was returned by @code{TARGET_GET_PCH_VALIDITY}\nwhen the PCH file was created and @var{sz} is the size of that data in bytes.\nIt's safe to assume that the data was created by the same version of the\ncompiler, so no format checking is needed.\n\nThe default definition of @code{default_pch_valid_p} should be\nsuitable for most targets.", "const char *", "TARGET_" "pch_valid_p", "(const void *data, size_t sz)", "default_pch_valid_p", "Target Hook" },
# 4121 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Called before writing out a PCH file.  If the target has some\ngarbage-collected data that needs to be in a particular state on PCH loads,\nit can use this hook to enforce that state.  Very few targets need\nto do anything here.", "void", "TARGET_" "prepare_pch_save", "(void)", "hook_void_void", "Target Hook" },
# 4133 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If this hook is nonnull, the default implementation of\n@code{TARGET_PCH_VALID_P} will use it to check for compatible values\nof @code{target_flags}.  @var{pch_flags} specifies the value that\n@code{target_flags} had when the PCH file was created.  The return\nvalue is the same as for @code{TARGET_PCH_VALID_P}.", "const char *", "TARGET_" "check_pch_target_flags", "(int pch_flags)", "NULL", "Target Hook" },
# 4145 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return true if the compiler should give an\n@code{enum} type only as many bytes as it takes to represent the range\nof possible values of that type.  It should return false if all\n@code{enum} types should be allocated like @code{int}.\n\nThe default is to return false.", "bool", "TARGET_" "default_short_enums", "(void)", "hook_bool_void_false", "Target Hook" },
# 4158 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return an rtx that is used to store\nthe address of the current frame into the built in @code{setjmp} buffer.\nThe default value, @code{virtual_stack_vars_rtx}, is correct for most\nmachines.  One reason you may need to define this target hook is if\n@code{hard_frame_pointer_rtx} is the appropriate value on your machine.", "rtx", "TARGET_" "builtin_setjmp_frame_value", "(void)", "default_builtin_setjmp_frame_value", "Target Hook" },
# 4170 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook may add @dfn{clobbers} to @var{clobbers} and\n@var{clobbered_regs} for any hard regs the port wishes to automatically\nclobber for an asm.  The @var{outputs} and @var{inputs} may be inspected\nto avoid clobbering a register that is already used by the asm.\n\nIt may modify the @var{outputs}, @var{inputs}, and @var{constraints}\nas necessary for other pre-processing.  In this case the return value is\na sequence of insns to emit after the asm.", "rtx_insn *", "TARGET_" "md_asm_adjust", "(vec<rtx>& outputs, vec<rtx>& inputs, vec<const char *>& constraints, vec<rtx>& clobbers, HARD_REG_SET& clobbered_regs)", "NULL", "Target Hook" },
# 4190 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this to enable the dwarf attribute @code{DW_AT_calling_convention} to\nbe emitted for each function.  Instead of an integer return the enum\nvalue for the @code{DW_CC_} tag.", "int", "TARGET_" "dwarf_calling_convention", "(const_tree function)", "hook_int_const_tree_0", "Target Hook" },
# 4205 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook allows the backend to emit frame-related insns that\ncontain UNSPECs or UNSPEC_VOLATILEs.  The DWARF 2 call frame debugging\ninfo engine will invoke it on insns of the form\n@smallexample\n(set (reg) (unspec [@dots{}] UNSPEC_INDEX))\n@end smallexample\nand\n@smallexample\n(set (reg) (unspec_volatile [@dots{}] UNSPECV_INDEX)).\n@end smallexample\nto let the backend emit the call frame instructions.  @var{label} is\nthe CFI label attached to the insn, @var{pattern} is the pattern of\nthe insn and @var{index} is @code{UNSPEC_INDEX} or @code{UNSPECV_INDEX}.", "void", "TARGET_" "dwarf_handle_frame_unspec", "(const char *label, rtx pattern, int index)", "NULL", "Target Hook" },
# 4222 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Express the value of @code{poly_int} indeterminate @var{i} as a DWARF\nexpression, with @var{i} counting from 1.  Return the number of a DWARF\nregister @var{R} and set @samp{*@var{factor}} and @samp{*@var{offset}} such\nthat the value of the indeterminate is:\n@smallexample\nvalue_of(@var{R}) / @var{factor} - @var{offset}\n@end smallexample\n\nA target only needs to define this hook if it sets\n@samp{NUM_POLY_INT_COEFFS} to a value greater than 1.", "unsigned int", "TARGET_" "dwarf_poly_indeterminate_value", "(unsigned int i, unsigned int *factor, int *offset)", "default_dwarf_poly_indeterminate_value", "Target Hook" },
# 4238 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "bool", "TARGET_" "stdarg_optimize_hook", "(struct stdarg_info *ai, const gimple *stmt)", "NULL", "Target Hook" },
# 4248 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a @code{DECL} node for the external variable to use\nfor the stack protection guard.  This variable is initialized by the\nruntime to some random value and is used to initialize the guard value\nthat is placed at the top of the local stack frame.  The type of this\nvariable must be @code{ptr_type_node}.\n\nThe default version of this hook creates a variable called\n@samp{__stack_chk_guard}, which is normally defined in @file{libgcc2.c}.", "tree", "TARGET_" "stack_protect_guard", "(void)", "default_stack_protect_guard", "Target Hook" },
# 4263 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a @code{CALL_EXPR} that alerts the runtime that the\nstack protect guard variable has been modified.  This expression should\ninvolve a call to a @code{noreturn} function.\n\nThe default version of this hook invokes a function called\n@samp{__stack_chk_fail}, taking no arguments.  This function is\nnormally defined in @file{libgcc2.c}.", "tree", "TARGET_" "stack_protect_fail", "(void)", "default_external_stack_protect_fail", "Target Hook" },
# 4277 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Returns true if the target wants GCC's default stack protect runtime support, otherwise return false.  The default implementation always returns true.", "bool", "TARGET_" "stack_protect_runtime_enabled_p", "(void)", "hook_bool_void_true", "Target Hook" },






{ "This hook is used to determine the level of target support for\n @code{__builtin_speculation_safe_value}.  If called with an argument\n of false, it returns true if the target has been modified to support\n this builtin.  If called with an argument of true, it returns true\n if the target requires active mitigation execution might be speculative.\n \n The default implementation returns false if the target does not define\n a pattern named @code{speculation_barrier}.  Else it returns true\n for the first case and whether the pattern is enabled for the current\n compilation for the second case.\n \n For targets that have no processors that can execute instructions\n speculatively an alternative implemenation of this hook is available:\n simply redefine this hook to @code{speculation_safe_value_not_needed}\n along with your other target hooks.", "bool", "TARGET_" "have_speculation_safe_value", "(bool active)", "default_have_speculation_safe_value", "Target Hook" },
# 4303 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook can be used to generate a target-specific code\n sequence that implements the @code{__builtin_speculation_safe_value}\n built-in function.  The function must always return @var{val} in\n @var{result} in mode @var{mode} when the cpu is not executing\n speculatively, but must never return that when speculating until it\n is known that the speculation will not be unwound.  The hook supports\n two primary mechanisms for implementing the requirements.  The first\n is to emit a speculation barrier which forces the processor to wait\n until all prior speculative operations have been resolved; the second\n is to use a target-specific mechanism that can track the speculation\n state and to return @var{failval} if it can determine that\n speculation must be unwound at a later time.\n \n The default implementation simply copies @var{val} to @var{result} and\n emits a @code{speculation_barrier} instruction if that is defined.", "rtx", "TARGET_" "speculation_safe_value", "(machine_mode mode, rtx result, rtx val, rtx failval)", "default_speculation_safe_value", "Target Hook" },
# 4323 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if we can predict it is possible to use a low-overhead loop\nfor a particular loop.  The parameter @var{loop} is a pointer to the loop.\nThis target hook is required only when the target supports low-overhead\nloops, and will help ivopts to make some decisions.\nThe default version of this hook returns false.", "bool", "TARGET_" "predict_doloop_p", "(class loop *loop)", "default_predict_doloop_p", "Target Hook" },
# 4333 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if the target supports hardware count register for decrement\nand branch.\nThe default value is false.", "bool", "TARGET_" "have_count_reg_decr_p", 0, "false", "Target Hook" },






{ "One IV candidate dedicated for doloop is introduced in IVOPTs, we can\ncalculate the computation cost of adopting it to any generic IV use by\nfunction get_computation_cost as before.  But for targets which have\nhardware count register support for decrement and branch, it may have to\nmove IV value from hardware count register to general purpose register\nwhile doloop IV candidate is used for generic IV uses.  It probably takes\nexpensive penalty.  This hook allows target owners to define the cost for\nthis especially for generic IV uses.\nThe default value is zero.", "int64_t", "TARGET_" "doloop_cost_for_generic", 0, "0", "Target Hook" },
# 4353 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "One IV candidate dedicated for doloop is introduced in IVOPTs, we can\ncalculate the computation cost of adopting it to any address IV use by\nfunction get_computation_cost as before.  But for targets which have\nhardware count register support for decrement and branch, it may have to\nmove IV value from hardware count register to general purpose register\nwhile doloop IV candidate is used for address IV uses.  It probably takes\nexpensive penalty.  This hook allows target owners to define the cost for\nthis escpecially for address IV uses.\nThe default value is zero.", "int64_t", "TARGET_" "doloop_cost_for_address", 0, "0", "Target Hook" },
# 4366 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if it is possible to use low-overhead loops (@code{doloop_end}\nand @code{doloop_begin}) for a particular loop.  @var{iterations} gives the\nexact number of iterations, or 0 if not known.  @var{iterations_max} gives\nthe maximum number of iterations, or 0 if not known.  @var{loop_depth} is\nthe nesting depth of the loop, with 1 for innermost loops, 2 for loops that\ncontain innermost loops, and so on.  @var{entered_at_top} is true if the\nloop is only entered from the top.\n\nThis hook is only used if @code{doloop_end} is available.  The default\nimplementation returns true.  You can use @code{can_use_doloop_if_innermost}\nif the loop must be the innermost, and if there are no other restrictions.", "bool", "TARGET_" "can_use_doloop_p", "(const widest_int &iterations, const widest_int &iterations_max, unsigned int loop_depth, bool entered_at_top)", "hook_bool_wint_wint_uint_bool_true", "Target Hook" },
# 4385 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "\nTake an instruction in @var{insn} and return NULL if it is valid within a\nlow-overhead loop, otherwise return a string explaining why doloop\ncould not be applied.\n\nMany targets use special registers for low-overhead looping. For any\ninstruction that clobbers these this function should return a string indicating\nthe reason why the doloop could not be applied.\nBy default, the RTL loop optimizer does not use a present doloop pattern for\nloops containing function calls or branch on table instructions.", "const char *", "TARGET_" "invalid_within_doloop", "(const rtx_insn *insn)", "default_invalid_within_doloop", "Target Hook" },
# 4401 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Take an instruction in @var{insn} and return @code{false} if the instruction is not appropriate as a combination of two or more instructions.  The default is to accept all instructions.", "bool", "TARGET_" "legitimate_combined_insn", "(rtx_insn *insn)", "hook_bool_rtx_insn_true", "Target Hook" },







{ "@var{decl} is a variable or function with @code{__attribute__((dllimport))} specified.  Use this hook if the target needs to add extra validation checks to @code{handle_dll_attribute}.", "bool", "TARGET_" "valid_dllimport_attribute_p", "(const_tree decl)", "hook_bool_const_tree_true", "Target Hook" },
# 4419 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On some architectures it can take multiple instructions to synthesize\na constant.  If there is another constant already in a register that\nis close enough in value then it is preferable that the new constant\nis computed from this register using immediate addition or\nsubtraction.  We accomplish this through CSE.  Besides the value of\nthe constant we also add a lower and an upper constant anchor to the\navailable expressions.  These are then queried when encountering new\nconstants.  The anchors are computed by rounding the constant up and\ndown to a multiple of the value of @code{TARGET_CONST_ANCHOR}.\n@code{TARGET_CONST_ANCHOR} should be the maximum positive value\naccepted by immediate-add plus one.  We currently assume that the\nvalue of @code{TARGET_CONST_ANCHOR} is a power of 2.  For example, on\nMIPS, where add-immediate takes a 16-bit signed value,\n@code{TARGET_CONST_ANCHOR} is set to @samp{0x8000}.  The default value\nis zero, which disables this optimization.", "unsigned HOST_WIDE_INT", "TARGET_" "const_anchor", 0, "0", "Target Hook" },
# 4439 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Validate target specific memory model mask bits. When NULL no target specific\nmemory model bits are allowed.", "unsigned HOST_WIDE_INT", "TARGET_" "memmodel_check", "(unsigned HOST_WIDE_INT val)", "NULL", "Target Hook" },
# 4448 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the offset bitwise ored into shifted address to get corresponding\nAddress Sanitizer shadow memory address.  NULL if Address Sanitizer is not\nsupported by the target.", "unsigned HOST_WIDE_INT", "TARGET_" "asan_shadow_offset", "(void)", "NULL", "Target Hook" },
# 4458 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "TARGET_CALLS", 0, 0, "Target Hook" },

{ "Like @code{PROMOTE_MODE}, but it is applied to outgoing function arguments or\nfunction return values.  The target hook should return the new mode\nand possibly change @code{*@var{punsignedp}} if the promotion should\nchange signedness.  This function is called only for scalar @emph{or\npointer} types.\n\n@var{for_return} allows to distinguish the promotion of arguments and\nreturn values.  If it is @code{1}, a return value is being promoted and\n@code{TARGET_FUNCTION_VALUE} must perform the same promotions done here.\nIf it is @code{2}, the returned mode should be that of the register in\nwhich an incoming parameter is copied, or the outgoing result is computed;\nthen the hook should return the same mode as @code{promote_mode}, though\nthe signedness may be different.\n\n@var{type} can be NULL when promoting function arguments of libcalls.\n\nThe default is to not promote arguments and return values.  You can\nalso define the hook to @code{default_promote_function_mode_always_promote}\nif you would like to apply the same rules given by @code{PROMOTE_MODE}.", "machine_mode", "TARGET_" "promote_function_mode", "(const_tree type, machine_mode mode, int *punsignedp, const_tree funtype, int for_return)", "default_promote_function_mode", "Target Hook" },
# 4485 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns @code{true} if an argument declared in a\nprototype as an integral type smaller than @code{int} should actually be\npassed as an @code{int}.  In addition to avoiding errors in certain\ncases of mismatch, it also makes for better code on certain machines.\nThe default is to not promote prototypes.", "bool", "TARGET_" "promote_prototypes", "(const_tree fntype)", "hook_bool_const_tree_false", "Target Hook" },
# 4495 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return the location of the structure value\naddress (normally a @code{mem} or @code{reg}), or 0 if the address is\npassed as an ``invisible'' first argument.  Note that @var{fndecl} may\nbe @code{NULL}, for libcalls.  You do not need to define this target\nhook if the address is always passed as an ``invisible'' first\nargument.\n\nOn some architectures the place where the structure value address\nis found by the called function is not the same place that the\ncaller put it.  This can be due to register windows, or it could\nbe because the function prologue moves it to a different place.\n@var{incoming} is @code{1} or @code{2} when the location is needed in\nthe context of the called function, and @code{0} in the context of\nthe caller.\n\nIf @var{incoming} is nonzero and the address is to be found on the\nstack, return a @code{mem} which refers to the frame pointer. If\n@var{incoming} is @code{2}, the result is being used to fetch the\nstructure value address at the beginning of a function.  If you need\nto emit adjusting code, you should do it at this point.", "rtx", "TARGET_" "struct_value_rtx", "(tree fndecl, int incoming)", "hook_rtx_tree_int_null", "Target Hook" },
# 4520 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Normally, when a function returns a structure by memory, the address\nis passed as an invisible pointer argument, but the compiler also\narranges to return the address from the function like it would a normal\npointer return value.  Define this to true if that behavior is\nundesirable on your target.", "bool", "TARGET_" "omit_struct_return_reg", 0, "false", "Target Hook" },
# 4529 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return a nonzero value to say to return the\nfunction value in memory, just as large structures are always returned.\nHere @var{type} will be the data type of the value, and @var{fntype}\nwill be the type of the function doing the returning, or @code{NULL} for\nlibcalls.\n\nNote that values of mode @code{BLKmode} must be explicitly handled\nby this function.  Also, the option @option{-fpcc-struct-return}\ntakes effect regardless of this macro.  On most systems, it is\npossible to leave the hook undefined; this causes a default\ndefinition to be used, whose value is the constant 1 for @code{BLKmode}\nvalues, and 0 otherwise.\n\nDo not use this hook to indicate that structures and unions should always\nbe returned in memory.  You should instead use @code{DEFAULT_PCC_STRUCT_RETURN}\nto indicate this.", "bool", "TARGET_" "return_in_memory", "(const_tree type, const_tree fntype)", "default_return_in_memory", "Target Hook" },
# 4550 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if values of type @var{type} are returned\nat the most significant end of a register (in other words, if they are\npadded at the least significant end).  You can assume that @var{type}\nis returned in a register; the caller is required to check this.\n\nNote that the register provided by @code{TARGET_FUNCTION_VALUE} must\nbe able to hold the complete return value.  For example, if a 1-, 2-\nor 3-byte structure is returned at the most significant end of a\n4-byte register, @code{TARGET_FUNCTION_VALUE} should provide an\n@code{SImode} rtx.", "bool", "TARGET_" "return_in_msb", "(const_tree type)", "hook_bool_const_tree_false", "Target Hook" },
# 4568 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if argument @var{arg} at the\nposition indicated by @var{cum} should be passed by reference.  This\npredicate is queried after target independent reasons for being\npassed by reference, such as @code{TREE_ADDRESSABLE (@var{arg}.type)}.\n\nIf the hook returns true, a copy of that argument is made in memory and a\npointer to the argument is passed instead of the argument itself.\nThe pointer is passed in whatever way is appropriate for passing a pointer\nto that type.", "bool", "TARGET_" "pass_by_reference", "(cumulative_args_t cum, const function_arg_info &arg)", "hook_bool_CUMULATIVE_ARGS_arg_info_false", "Target Hook" },
# 4583 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this hook produces the machine-specific code for a call to\n@code{__builtin_saveregs}.  This code will be moved to the very\nbeginning of the function, before any parameter access are made.  The\nreturn value of this function should be an RTX that contains the value\nto use as the return of @code{__builtin_saveregs}.", "rtx", "TARGET_" "expand_builtin_saveregs", "(void)", "default_expand_builtin_saveregs", "Target Hook" },
# 4594 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook offers an alternative to using\n@code{__builtin_saveregs} and defining the hook\n@code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous\nregister arguments into the stack so that all the arguments appear to\nhave been passed consecutively on the stack.  Once this is done, you can\nuse the standard implementation of varargs that works for machines that\npass all their arguments on the stack.\n\nThe argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data\nstructure, containing the values that are obtained after processing the\nnamed arguments.  The argument @var{arg} describes the last of these named\narguments.\n\nThe target hook should do two things: first, push onto the stack all the\nargument registers @emph{not} used for the named arguments, and second,\nstore the size of the data thus pushed into the @code{int}-valued\nvariable pointed to by @var{pretend_args_size}.  The value that you\nstore here will serve as additional offset for setting up the stack\nframe.\n\nBecause you must generate code to push the anonymous arguments at\ncompile time without knowing their data types,\n@code{TARGET_SETUP_INCOMING_VARARGS} is only useful on machines that\nhave just a single category of argument register and use it uniformly\nfor all data types.\n\nIf the argument @var{second_time} is nonzero, it means that the\narguments of the function are being analyzed for the second time.  This\nhappens for an inline function, which is not actually compiled until the\nend of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should\nnot generate any instructions in this case.", "void", "TARGET_" "setup_incoming_varargs", "(cumulative_args_t args_so_far, const function_arg_info &arg, int *pretend_args_size, int second_time)", "default_setup_incoming_varargs", "Target Hook" },
# 4631 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used by expand pass to emit insn to load bounds of\n@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\nbounds of @var{arg} are not passed in register.  If @var{slot} is a\nmemory, then bounds are loaded as for regular pointer loaded from\nmemory.  If @var{slot} is not a memory then @var{slot_no} is an integer\nconstant holding number of the target dependent special slot which\nshould be used to obtain bounds.  Hook returns RTX holding loaded bounds.", "rtx", "TARGET_" "load_bounds_for_arg", "(rtx slot, rtx arg, rtx slot_no)", "default_load_bounds_for_arg", "Target Hook" },
# 4643 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used by expand pass to emit insns to store @var{bounds} of\n@var{arg} passed in @var{slot}.  Expand pass uses this hook in case\n@var{bounds} of @var{arg} are not passed in register.  If @var{slot} is a\nmemory, then @var{bounds} are stored as for regular pointer stored in\nmemory.  If @var{slot} is not a memory then @var{slot_no} is an integer\nconstant holding number of the target dependent special slot which\nshould be used to store @var{bounds}.", "void", "TARGET_" "store_bounds_for_arg", "(rtx arg, rtx slot, rtx bounds, rtx slot_no)", "default_store_bounds_for_arg", "Target Hook" },
# 4655 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is used by expand pass to emit insn to load bounds\nreturned by function call in @var{slot}.  Hook returns RTX holding\nloaded bounds.", "rtx", "TARGET_" "load_returned_bounds", "(rtx slot)", "default_load_returned_bounds", "Target Hook" },







{ "This hook is used by expand pass to emit insn to store @var{bounds}\nreturned by function call into @var{slot}.", "void", "TARGET_" "store_returned_bounds", "(rtx slot, rtx bounds)", "default_store_returned_bounds", "Target Hook" },






{ "While generating RTL for a function call, this target hook is invoked once\nfor each argument passed to the function, either a register returned by\n@code{TARGET_FUNCTION_ARG} or a memory location.  It is called just\nbefore the point where argument registers are stored.  The type of the\nfunction to be called is also passed as the second argument; it is\n@code{NULL_TREE} for libcalls.  The @code{TARGET_END_CALL_ARGS} hook is\ninvoked just after the code to copy the return reg has been emitted.\nThis functionality can be used to perform special setup of call argument\nregisters if a target needs it.\nFor functions without arguments, the hook is called once with @code{pc_rtx}\npassed instead of an argument register.\nMost ports do not need to implement anything for this hook.", "void", "TARGET_" "call_args", "(rtx, tree)", "hook_void_rtx_tree", "Target Hook" },
# 4687 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is invoked while generating RTL for a function call,\njust after the point where the return reg is copied into a pseudo.  It\nsignals that all the call argument and return registers for the just\nemitted call are now no longer in use.\nMost ports do not need to implement anything for this hook.", "void", "TARGET_" "end_call_args", "(void)", "hook_void_void", "Target Hook" },
# 4697 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook to return @code{true} if the location where a function\nargument is passed depends on whether or not it is a named argument.\n\nThis hook controls how the @var{named} argument to @code{TARGET_FUNCTION_ARG}\nis set for varargs and stdarg functions.  If this hook returns\n@code{true}, the @var{named} argument is always true for named\narguments, and false for unnamed arguments.  If it returns @code{false},\nbut @code{TARGET_PRETEND_OUTGOING_VARARGS_NAMED} returns @code{true},\nthen all arguments are treated as named.  Otherwise, all named arguments\nexcept the last are treated as named.\n\nYou need not define this hook if it always returns @code{false}.", "bool", "TARGET_" "strict_argument_naming", "(cumulative_args_t ca)", "hook_bool_CUMULATIVE_ARGS_false", "Target Hook" },
# 4717 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If you need to conditionally change ABIs so that one works with\n@code{TARGET_SETUP_INCOMING_VARARGS}, but the other works like neither\n@code{TARGET_SETUP_INCOMING_VARARGS} nor @code{TARGET_STRICT_ARGUMENT_NAMING} was\ndefined, then define this hook to return @code{true} if\n@code{TARGET_SETUP_INCOMING_VARARGS} is used, @code{false} otherwise.\nOtherwise, you should not define this hook.", "bool", "TARGET_" "pretend_outgoing_varargs_named", "(cumulative_args_t ca)", "default_pretend_outgoing_varargs_named", "Target Hook" },
# 4730 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return true if parameter of type @var{type} are passed\nas two scalar parameters.  By default, GCC will attempt to pack complex\narguments into the target's word size.  Some ABIs require complex arguments\nto be split and treated as their individual components.  For example, on\nAIX64, complex floats should be passed in a pair of floating point\nregisters, even though a complex float would fit in one 64-bit floating\npoint register.\n\nThe default value of this hook is @code{NULL}, which is treated as always\nfalse.", "bool", "TARGET_" "split_complex_arg", "(const_tree type)", "NULL", "Target Hook" },
# 4748 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if we should not pass @var{arg}\nsolely in registers.  The file @file{expr.h} defines a\ndefinition that is usually appropriate, refer to @file{expr.h} for additional\ndocumentation.", "bool", "TARGET_" "must_pass_in_stack", "(const function_arg_info &arg)", "must_pass_in_stack_var_size_or_pad", "Target Hook" },
# 4760 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "The function argument described by the parameters to this hook is\nknown to be passed by reference.  The hook should return true if the\nfunction argument should be copied by the callee instead of copied\nby the caller.\n\nFor any argument for which the hook returns true, if it can be\ndetermined that the argument is not modified, then a copy need\nnot be generated.\n\nThe default version of this hook always returns false.", "bool", "TARGET_" "callee_copies", "(cumulative_args_t cum, const function_arg_info &arg)", "hook_bool_CUMULATIVE_ARGS_arg_info_false", "Target Hook" },
# 4779 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns the number of bytes at the beginning of an\nargument that must be put in registers.  The value must be zero for\narguments that are passed entirely in registers or that are entirely\npushed on the stack.\n\nOn some machines, certain arguments must be passed partially in\nregisters and partially in memory.  On these machines, typically the\nfirst few words of arguments are passed in registers, and the rest\non the stack.  If a multi-word argument (a @code{double} or a\nstructure) crosses that boundary, its first few words must be passed\nin registers and the rest must be pushed.  This macro tells the\ncompiler when this occurs, and how many bytes should go in registers.\n\n@code{TARGET_FUNCTION_ARG} for these arguments should return the first\nregister to be used by the caller for this argument; likewise\n@code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.", "int", "TARGET_" "arg_partial_bytes", "(cumulative_args_t cum, const function_arg_info &arg)", "hook_int_CUMULATIVE_ARGS_arg_info_0", "Target Hook" },
# 4803 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook updates the summarizer variable pointed to by @var{ca} to\nadvance past argument @var{arg} in the argument list.  Once this is done,\nthe variable @var{cum} is suitable for analyzing the @emph{following}\nargument with @code{TARGET_FUNCTION_ARG}, etc.\n\nThis hook need not do anything if the argument in question was passed\non the stack.  The compiler knows how to track the amount of stack space\nused for arguments without any special help.", "void", "TARGET_" "function_arg_advance", "(cumulative_args_t ca, const function_arg_info &arg)", "default_function_arg_advance", "Target Hook" },
# 4817 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the number of bytes to add to the offset of an\nargument of type @var{type} and mode @var{mode} when passed in memory.\nThis is needed for the SPU, which passes @code{char} and @code{short}\narguments in the preferred slot that is in the middle of the quad word\ninstead of starting at the top.  The default implementation returns 0.", "HOST_WIDE_INT", "TARGET_" "function_arg_offset", "(machine_mode mode, const_tree type)", "default_function_arg_offset", "Target Hook" },
# 4827 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook determines whether, and in which direction, to pad out\nan argument of mode @var{mode} and type @var{type}.  It returns\n@code{PAD_UPWARD} to insert padding above the argument, @code{PAD_DOWNWARD}\nto insert padding below the argument, or @code{PAD_NONE} to inhibit padding.\n\nThe @emph{amount} of padding is not controlled by this hook, but by\n@code{TARGET_FUNCTION_ARG_ROUND_BOUNDARY}.  It is always just enough\nto reach the next multiple of that boundary.\n\nThis hook has a default definition that is right for most systems.\nFor little-endian machines, the default is to pad upward.  For\nbig-endian machines, the default is to pad downward for an argument of\nconstant size shorter than an @code{int}, and upward otherwise.", "pad_direction", "TARGET_" "function_arg_padding", "(machine_mode mode, const_tree type)", "default_function_arg_padding", "Target Hook" },
# 4849 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return an RTX indicating whether function argument @var{arg} is passed\nin a register and if so, which register.  Argument @var{ca} summarizes all\nthe previous arguments.\n\nThe return value is usually either a @code{reg} RTX for the hard\nregister in which to pass the argument, or zero to pass the argument\non the stack.\n\nThe return value can be a @code{const_int} which means argument is\npassed in a target specific slot with specified number.  Target hooks\nshould be used to store or load argument in such case.  See\n@code{TARGET_STORE_BOUNDS_FOR_ARG} and @code{TARGET_LOAD_BOUNDS_FOR_ARG}\nfor more information.\n\nThe value of the expression can also be a @code{parallel} RTX@.  This is\nused when an argument is passed in multiple locations.  The mode of the\n@code{parallel} should be the mode of the entire argument.  The\n@code{parallel} holds any number of @code{expr_list} pairs; each one\ndescribes where part of the argument is passed.  In each\n@code{expr_list} the first operand must be a @code{reg} RTX for the hard\nregister in which to pass this part of the argument, and the mode of the\nregister RTX indicates how large this part of the argument is.  The\nsecond operand of the @code{expr_list} is a @code{const_int} which gives\nthe offset in bytes into the entire argument of where this part starts.\nAs a special exception the first @code{expr_list} in the @code{parallel}\nRTX may have a first operand of zero.  This indicates that the entire\nargument is also stored on the stack.\n\nThe last time this hook is called, it is called with @code{MODE ==\nVOIDmode}, and its result is passed to the @code{call} or @code{call_value}\npattern as operands 2 and 3 respectively.\n\n@cindex @file{stdarg.h} and register arguments\nThe usual way to make the ISO library @file{stdarg.h} work on a\nmachine where some arguments are usually passed in registers, is to\ncause nameless arguments to be passed on the stack instead.  This is\ndone by making @code{TARGET_FUNCTION_ARG} return 0 whenever\n@var{named} is @code{false}.\n\n@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{TARGET_FUNCTION_ARG}\n@cindex @code{REG_PARM_STACK_SPACE}, and @code{TARGET_FUNCTION_ARG}\nYou may use the hook @code{targetm.calls.must_pass_in_stack}\nin the definition of this macro to determine if this argument is of a\ntype that must be passed in the stack.  If @code{REG_PARM_STACK_SPACE}\nis not defined and @code{TARGET_FUNCTION_ARG} returns nonzero for such an\nargument, the compiler will abort.  If @code{REG_PARM_STACK_SPACE} is\ndefined, the argument will be computed in the stack and then loaded into\na register.", "rtx", "TARGET_" "function_arg", "(cumulative_args_t ca, const function_arg_info &arg)", "default_function_arg", "Target Hook" },
# 4902 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if the caller and callee on the target have different\nviews of where arguments are passed.  Also define this hook if there are\nfunctions that are never directly called, but are invoked by the hardware\nand which have nonstandard calling conventions.\n\nIn this case @code{TARGET_FUNCTION_ARG} computes the register in\nwhich the caller passes the value, and\n@code{TARGET_FUNCTION_INCOMING_ARG} should be defined in a similar\nfashion to tell the function being called where the arguments will\narrive.\n\n@code{TARGET_FUNCTION_INCOMING_ARG} can also return arbitrary address\ncomputation using hard register, which can be forced into a register,\nso that it can be used to pass special arguments.\n\nIf @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n@code{TARGET_FUNCTION_ARG} serves both purposes.", "rtx", "TARGET_" "function_incoming_arg", "(cumulative_args_t ca, const function_arg_info &arg)", "default_function_incoming_arg", "Target Hook" },
# 4924 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the alignment boundary, in bits, of an argument\nwith the specified mode and type.  The default hook returns\n@code{PARM_BOUNDARY} for all arguments.", "unsigned int", "TARGET_" "function_arg_boundary", "(machine_mode mode, const_tree type)", "default_function_arg_boundary", "Target Hook" },







{ "Normally, the size of an argument is rounded up to @code{PARM_BOUNDARY},\nwhich is the default value for this hook.  You can define this hook to\nreturn a different value if an argument size must be rounded to a larger\nvalue.", "unsigned int", "TARGET_" "function_arg_round_boundary", "(machine_mode mode, const_tree type)", "default_function_arg_round_boundary", "Target Hook" },
# 4943 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this macro returns the diagnostic message when it is\nillegal to pass argument @var{val} to function @var{funcdecl}\nwith prototype @var{typelist}.", "const char *", "TARGET_" "invalid_arg_for_unprototyped_fn", "(const_tree typelist, const_tree funcdecl, const_tree val)", "hook_invalid_arg_for_unprototyped_fn", "Target Hook" },
# 4953 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "\nDefine this to return an RTX representing the place where a function\nreturns or receives a value of data type @var{ret_type}, a tree node\nrepresenting a data type.  @var{fn_decl_or_type} is a tree node\nrepresenting @code{FUNCTION_DECL} or @code{FUNCTION_TYPE} of a\nfunction being called.  If @var{outgoing} is false, the hook should\ncompute the register in which the caller will see the return value.\nOtherwise, the hook should return an RTX representing the place where\na function returns a value.\n\nOn many machines, only @code{TYPE_MODE (@var{ret_type})} is relevant.\n(Actually, on most machines, scalar values are returned in the same\nplace regardless of mode.)  The value of the expression is usually a\n@code{reg} RTX for the hard register where the return value is stored.\nThe value can also be a @code{parallel} RTX, if the return value is in\nmultiple places.  See @code{TARGET_FUNCTION_ARG} for an explanation of the\n@code{parallel} form.   Note that the callee will populate every\nlocation specified in the @code{parallel}, but if the first element of\nthe @code{parallel} contains the whole return value, callers will use\nthat element as the canonical location and ignore the others.  The m68k\nport uses this type of @code{parallel} to return pointers in both\n@samp{%a0} (the canonical location) and @samp{%d0}.\n\nIf @code{TARGET_PROMOTE_FUNCTION_RETURN} returns true, you must apply\nthe same promotion rules specified in @code{PROMOTE_MODE} if\n@var{valtype} is a scalar type.\n\nIf the precise function being called is known, @var{func} is a tree\nnode (@code{FUNCTION_DECL}) for it; otherwise, @var{func} is a null\npointer.  This makes it possible to use a different value-returning\nconvention for specific functions when all their calls are\nknown.\n\nSome target machines have ``register windows'' so that the register in\nwhich a function returns its value is not the same as the one in which\nthe caller sees the value.  For such machines, you should return\ndifferent RTX depending on @var{outgoing}.\n\n@code{TARGET_FUNCTION_VALUE} is not used for return values with\naggregate data types, because these are returned in another way.  See\n@code{TARGET_STRUCT_VALUE_RTX} and related macros, below.", "rtx", "TARGET_" "function_value", "(const_tree ret_type, const_tree fn_decl_or_type, bool outgoing)", "default_function_value", "Target Hook" },
# 5001 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook if the back-end needs to know the name of the libcall\nfunction in order to determine where the result should be returned.\n\nThe mode of the result is given by @var{mode} and the name of the called\nlibrary function is given by @var{fun}.  The hook should return an RTX\nrepresenting the place where the library function result will be returned.\n\nIf this hook is not defined, then LIBCALL_VALUE will be used.", "rtx", "TARGET_" "libcall_value", "(machine_mode mode, const_rtx fun)", "default_libcall_value", "Target Hook" },
# 5016 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook that return @code{true} if @var{regno} is the number of a hard\nregister in which the values of called function may come back.\n\nA register whose use for returning values is limited to serving as the\nsecond of a pair (for a value of type @code{double}, say) need not be\nrecognized by this target hook.\n\nIf the machine has register windows, so that the caller and the called\nfunction use different registers for the return value, this target hook\nshould recognize only the caller's register numbers.\n\nIf this hook is not defined, then FUNCTION_VALUE_REGNO_P will be used.", "bool", "TARGET_" "function_value_regno_p", "(const unsigned int regno)", "default_function_value_regno_p", "Target Hook" },
# 5033 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return the ABI used by a function with type @var{type}; see the\ndefinition of @code{predefined_function_abi} for details of the ABI\ndescriptor.  Targets only need to define this hook if they support\ninteroperability between several ABIs in the same translation unit.", "const predefined_function_abi &", "TARGET_" "fntype_abi", "(const_tree type)", "NULL", "Target Hook" },
# 5042 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns a description of the ABI used by the target of\ncall instruction @var{insn}; see the definition of\n@code{predefined_function_abi} for details of the ABI descriptor.\nOnly the global function @code{insn_callee_abi} should call this hook\ndirectly.\n\nTargets only need to define this hook if they support\ninteroperability between several ABIs in the same translation unit.", "const predefined_function_abi &", "TARGET_" "insn_callee_abi", "(const rtx_insn *insn)", "NULL", "Target Hook" },
# 5056 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "*", "rtx", "TARGET_" "internal_arg_pointer", "(void)", "default_internal_arg_pointer", "Target Hook" },







{ "Define this macro to update the current function stack boundary if\nnecessary.", "void", "TARGET_" "update_stack_boundary", "(void)", "NULL", "Target Hook" },







{ "This hook should return an rtx for Dynamic Realign Argument Pointer (DRAP) if a\ndifferent argument pointer register is needed to access the function's\nargument list due to stack realignment.  Return @code{NULL} if no DRAP\nis needed.", "rtx", "TARGET_" "get_drap_rtx", "(void)", "NULL", "Target Hook" },
# 5082 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "When optimization is disabled, this hook indicates whether or not\narguments should be allocated to stack slots.  Normally, GCC allocates\nstacks slots for arguments when not optimizing in order to make\ndebugging easier.  However, when a function is declared with\n@code{__attribute__((naked))}, there is no stack frame, and the compiler\ncannot safely move arguments from the registers in which they are passed\nto the stack.  Therefore, this hook should return true in general, but\nfalse for naked functions.  The default implementation always returns true.", "bool", "TARGET_" "allocate_stack_slots_for_args", "(void)", "hook_bool_void_true", "Target Hook" },
# 5097 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook replaces the use of @code{STATIC_CHAIN_REGNUM} et al for\ntargets that may use different static chain locations for different\nnested functions.  This may be required if the target has function\nattributes that affect the calling conventions of the function and\nthose calling conventions use different static chain locations.\n\nThe default version of this hook uses @code{STATIC_CHAIN_REGNUM} et al.\n\nIf the static chain is passed in memory, this hook should be used to\nprovide rtx giving @code{mem} expressions that denote where they are stored.\nOften the @code{mem} expression as seen by the caller will be at an offset\nfrom the stack pointer and the @code{mem} expression as seen by the callee\nwill be at an offset from the frame pointer.\n@findex stack_pointer_rtx\n@findex frame_pointer_rtx\n@findex arg_pointer_rtx\nThe variables @code{stack_pointer_rtx}, @code{frame_pointer_rtx}, and\n@code{arg_pointer_rtx} will have been initialized and should be used\nto refer to those items.", "rtx", "TARGET_" "static_chain", "(const_tree fndecl_or_type, bool incoming_p)", "default_static_chain", "Target Hook" },
# 5123 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called to initialize a trampoline.\n@var{m_tramp} is an RTX for the memory block for the trampoline; @var{fndecl}\nis the @code{FUNCTION_DECL} for the nested function; @var{static_chain} is an\nRTX for the static chain value that should be passed to the function\nwhen it is called.\n\nIf the target defines @code{TARGET_ASM_TRAMPOLINE_TEMPLATE}, then the\nfirst thing this hook should do is emit a block move into @var{m_tramp}\nfrom the memory block returned by @code{assemble_trampoline_template}.\nNote that the block move need only cover the constant parts of the\ntrampoline.  If the target isolates the variable parts of the trampoline\nto the end, not all @code{TRAMPOLINE_SIZE} bytes need be copied.\n\nIf the target requires any other actions, such as flushing caches or\nenabling stack execution, these actions should be performed after\ninitializing the trampoline proper.", "void", "TARGET_" "trampoline_init", "(rtx m_tramp, tree fndecl, rtx static_chain)", "default_trampoline_init", "Target Hook" },
# 5145 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should perform any machine-specific adjustment in\nthe address of the trampoline.  Its argument contains the address of the\nmemory block that was passed to @code{TARGET_TRAMPOLINE_INIT}.  In case\nthe address to be used for a function call should be different from the\naddress at which the template was stored, the different address should\nbe returned; otherwise @var{addr} should be returned unchanged.\nIf this hook is not defined, @var{addr} will be used for function calls.", "rtx", "TARGET_" "trampoline_adjust_address", "(rtx addr)", "NULL", "Target Hook" },
# 5156 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If the target can use GCC's generic descriptor mechanism for nested\nfunctions, define this hook to a power of 2 representing an unused bit\nin function pointers which can be used to differentiate descriptors at\nrun time.  This value gives the number of bytes by which descriptor\npointers are misaligned compared to function pointers.  For example, on\ntargets that require functions to be aligned to a 4-byte boundary, a\nvalue of either 1 or 2 is appropriate unless the architecture already\nreserves the bit for another purpose, such as on ARM.\n\nDefine this hook to 0 if the target implements ABI support for\nfunction descriptors in its standard calling sequence, like for example\nHPPA or IA-64.\n\nUsing descriptors for nested functions\neliminates the need for trampolines that reside on the stack and require\nit to be made executable.", "int", "TARGET_" "custom_function_descriptors", 0, "-1", "Target Hook" },
# 5180 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns the number of bytes of its own arguments that\na function pops on returning, or 0 if the function pops no arguments\nand the caller must therefore pop them all after the function returns.\n\n@var{fundecl} is a C variable whose value is a tree node that describes\nthe function in question.  Normally it is a node of type\n@code{FUNCTION_DECL} that describes the declaration of the function.\nFrom this you can obtain the @code{DECL_ATTRIBUTES} of the function.\n\n@var{funtype} is a C variable whose value is a tree node that\ndescribes the function in question.  Normally it is a node of type\n@code{FUNCTION_TYPE} that describes the data type of the function.\nFrom this it is possible to obtain the data types of the value and\narguments (if known).\n\nWhen a call to a library function is being considered, @var{fundecl}\nwill contain an identifier node for the library function.  Thus, if\nyou need to distinguish among various library functions, you can do so\nby their names.  Note that ``library function'' in this context means\na function used to perform arithmetic, whose name is known specially\nin the compiler and was not mentioned in the C code being compiled.\n\n@var{size} is the number of bytes of arguments passed on the\nstack.  If a variable number of bytes is passed, it is zero, and\nargument popping will always be the responsibility of the calling function.\n\nOn the VAX, all functions always pop their arguments, so the definition\nof this macro is @var{size}.  On the 68000, using the standard\ncalling convention, no functions pop their arguments, so the value of\nthe macro is always 0 in this case.  But an alternative calling\nconvention is available in which functions that take a fixed number of\narguments pop them but other functions (such as @code{printf}) pop\nnothing (the caller pops all).  When this convention is in use,\n@var{funtype} is examined to determine whether a function takes a fixed\nnumber of arguments.", "poly_int64", "TARGET_" "return_pops_args", "(tree fundecl, tree funtype, poly_int64 size)", "default_return_pops_args", "Target Hook" },
# 5222 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns the mode to be used when accessing raw return registers in @code{__builtin_return}.  Define this macro if the value in @var{reg_raw_mode} is not correct.", "fixed_size_mode", "TARGET_" "get_raw_result_mode", "(int regno)", "default_get_reg_raw_mode", "Target Hook" },
# 5232 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns the mode to be used when accessing raw argument registers in @code{__builtin_apply_args}.  Define this macro if the value in @var{reg_raw_mode} is not correct.", "fixed_size_mode", "TARGET_" "get_raw_arg_mode", "(int regno)", "default_get_reg_raw_mode", "Target Hook" },
# 5241 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns true if the type is an empty record.  The default\nis to return @code{false}.", "bool", "TARGET_" "empty_record_p", "(const_tree type)", "hook_bool_const_tree_false", "Target Hook" },







{ "This target hook warns about the change in empty class parameter passing\nABI.", "void", "TARGET_" "warn_parameter_passing_abi", "(cumulative_args_t ca, tree type)", "hook_void_CUMULATIVE_ARGS_tree", "Target Hook" },






{ 0, 0, "", 0, 0, "Target Hook" },

{ "This hook should return 1 in case pseudo register should be created\nfor pic_offset_table_rtx during function expand.", "bool", "TARGET_" "use_pseudo_pic_reg", "(void)", "hook_bool_void_false", "Target Hook" },






{ "Perform a target dependent initialization of pic_offset_table_rtx.\nThis hook is called at the start of register allocation.", "void", "TARGET_" "init_pic_reg", "(void)", "hook_void_void", "Target Hook" },
# 5274 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this macro returns the diagnostic message when it is\ninvalid to convert from @var{fromtype} to @var{totype}, or @code{NULL}\nif validity should be determined by the front end.", "const char *", "TARGET_" "invalid_conversion", "(const_tree fromtype, const_tree totype)", "hook_constcharptr_const_tree_const_tree_null", "Target Hook" },
# 5284 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this macro returns the diagnostic message when it is\ninvalid to apply operation @var{op} (where unary plus is denoted by\n@code{CONVERT_EXPR}) to an operand of type @var{type}, or @code{NULL}\nif validity should be determined by the front end.", "const char *", "TARGET_" "invalid_unary_op", "(int op, const_tree type)", "hook_constcharptr_int_const_tree_null", "Target Hook" },
# 5295 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this macro returns the diagnostic message when it is\ninvalid to apply operation @var{op} to operands of types @var{type1}\nand @var{type2}, or @code{NULL} if validity should be determined by\nthe front end.", "const char *", "TARGET_" "invalid_binary_op", "(int op, const_tree type1, const_tree type2)", "hook_constcharptr_int_const_tree_const_tree_null", "Target Hook" },
# 5307 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this target hook returns the type to which values of\n@var{type} should be promoted when they appear in expressions,\nanalogous to the integer promotions, or @code{NULL_TREE} to use the\nfront end's normal promotion rules.  This hook is useful when there are\ntarget-specific types with special promotion rules.\nThis is currently used only by the C and C++ front ends.", "tree", "TARGET_" "promoted_type", "(const_tree type)", "hook_tree_const_tree_null", "Target Hook" },
# 5321 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this hook returns the result of converting @var{expr} to\n@var{type}.  It should return the converted expression,\nor @code{NULL_TREE} to apply the front end's normal conversion rules.\nThis hook is useful when there are target-specific types with special\nconversion rules.\nThis is currently used only by the C and C++ front ends.", "tree", "TARGET_" "convert_to_type", "(tree type, tree expr)", "hook_tree_tree_tree_null", "Target Hook" },
# 5332 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this hook returns false if there is a target-specific reason\nwhy type @var{type} cannot be used in the source language context described\nby @var{context}.  When @var{silent_p} is false, the hook also reports an\nerror against @var{loc} for invalid uses of @var{type}.\n\nCalls to this hook should be made through the global function\n@code{verify_type_context}, which makes the @var{silent_p} parameter\ndefault to false and also handles @code{error_mark_node}.\n\nThe default implementation always returns true.", "bool", "TARGET_" "verify_type_context", "(location_t loc, type_context_kind context, const_tree type, bool silent_p)", "NULL", "Target Hook" },
# 5348 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if it is possible to bitcast values held in\nregisters of class @var{rclass} from mode @var{from} to mode @var{to}\nand if doing so preserves the low-order bits that are common to both modes.\nThe result is only meaningful if @var{rclass} has registers that can hold\nboth @code{from} and @code{to}.  The default implementation returns true.\n\nAs an example of when such bitcasting is invalid, loading 32-bit integer or\nfloating-point objects into floating-point registers on Alpha extends them\nto 64 bits.  Therefore loading a 64-bit object and then storing it as a\n32-bit object does not store the low-order 32 bits, as would be the case\nfor a normal register.  Therefore, @file{alpha.h} defines\n@code{TARGET_CAN_CHANGE_MODE_CLASS} to return:\n\n@smallexample\n(GET_MODE_SIZE (from) == GET_MODE_SIZE (to)\n || !reg_classes_intersect_p (FLOAT_REGS, rclass))\n@end smallexample\n\nEven if storing from a register in mode @var{to} would be valid,\nif both @var{from} and @code{raw_reg_mode} for @var{rclass} are wider\nthan @code{word_mode}, then we must prevent @var{to} narrowing the\nmode.  This happens when the middle-end assumes that it can load\nor store pieces of an @var{N}-word pseudo, and that the pseudo will\neventually be allocated to @var{N} @code{word_mode} hard registers.\nFailure to prevent this kind of mode change will result in the\nentire @code{raw_reg_mode} being modified instead of the partial\nvalue that the middle-end intended.", "bool", "TARGET_" "can_change_mode_class", "(machine_mode from, machine_mode to, reg_class_t rclass)", "hook_bool_mode_mode_reg_class_t_true", "Target Hook" },
# 5381 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which can change allocno class for given pseudo from\n  allocno and best class calculated by IRA.\n  \n  The default version of this target hook always returns given class.", "reg_class_t", "TARGET_" "ira_change_pseudo_allocno_class", "(int, reg_class_t, reg_class_t)", "default_ira_change_pseudo_allocno_class", "Target Hook" },
# 5391 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns true if we use LRA instead of reload pass.    The default version of this target hook returns true.  New ports  should use LRA, and existing ports are encouraged to convert.", "bool", "TARGET_" "lra_p", "(void)", "default_lra_p", "Target Hook" },
# 5401 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns the register priority number to which the  register @var{hard_regno} belongs to.  The bigger the number, the  more preferable the hard register usage (when all other conditions are  the same).  This hook can be used to prefer some hard register over  others in LRA.  For example, some x86-64 register usage needs  additional prefix which makes instructions longer.  The hook can  return lower priority number for such registers make them less favorable  and as result making the generated code smaller.    The default version of this target hook returns always zero.", "int", "TARGET_" "register_priority", "(int)", "default_register_priority", "Target Hook" },
# 5417 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns true if we need register usage leveling.  That means if a few hard registers are equally good for the  assignment, we choose the least used hard register.  The register  usage leveling may be profitable for some targets.  Don't use the  usage leveling for targets with conditional execution or targets  with big register files as it hurts if-conversion and cross-jumping  optimizations.    The default version of this target hook returns always false.", "bool", "TARGET_" "register_usage_leveling_p", "(void)", "default_register_usage_leveling_p", "Target Hook" },
# 5432 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns true if an address with the same structure  can have different maximal legitimate displacement.  For example, the  displacement can depend on memory mode or on operand combinations in  the insn.    The default version of this target hook returns always false.", "bool", "TARGET_" "different_addr_displacement_p", "(void)", "default_different_addr_displacement_p", "Target Hook" },
# 5445 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook defines a class of registers which could be used for spilling  pseudos of the given mode and class, or @code{NO_REGS} if only memory  should be used.  Not defining this hook is equivalent to returning  @code{NO_REGS} for all inputs.", "reg_class_t", "TARGET_" "spill_class", "(reg_class_t, machine_mode)", "NULL", "Target Hook" },
# 5455 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return @code{true} if given class of registers should  be an allocno class in any way.  Usually RA uses only one register  class from all classes containing the same register set.  In some  complicated cases, you need to have two or more such classes as  allocno ones for RA correct work.  Not defining this hook is  equivalent to returning @code{false} for all inputs.", "bool", "TARGET_" "additional_allocno_class_p", "(reg_class_t)", "hook_bool_reg_class_t_false", "Target Hook" },
# 5466 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook defines the machine mode to use for the boolean result of  conditional store patterns.  The ICODE argument is the instruction code  for the cstore being performed.  Not definiting this hook is the same  as accepting the mode encoded into operand 0 of the cstore expander  patterns.", "scalar_int_mode", "TARGET_" "cstore_mode", "(enum insn_code icode)", "default_cstore_mode", "Target Hook" },
# 5478 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which lets a backend compute the set of pressure classes to  be used by those optimization passes which take register pressure into  account, as opposed to letting IRA compute them.  It returns the number of  register classes stored in the array @var{pressure_classes}.", "int", "TARGET_" "compute_pressure_classes", "(enum reg_class *pressure_classes)", "NULL", "Target Hook" },
# 5488 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Return true if a structure, union or array containing @var{field} should\nbe accessed using @code{BLKMODE}.\n\nIf @var{field} is the only field in the structure, @var{mode} is its\nmode, otherwise @var{mode} is VOIDmode.  @var{mode} is provided in the\ncase where structures of one field would require the structure's mode to\nretain the field's mode.\n\nNormally, this is not needed.", "bool", "TARGET_" "member_type_forces_blk", "(const_tree field, machine_mode mode)", "default_member_type_forces_blk", "Target Hook" },
# 5504 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Define this hook for enabling divmod transform if the port does not have\nhardware divmod insn but defines target-specific divmod libfuncs.", "void", "TARGET_" "expand_divmod_libfunc", "(rtx libfunc, machine_mode mode, rtx op0, rtx op1, rtx *quot, rtx *rem)", "NULL", "Target Hook" },







{ "Many machines have some registers that cannot be copied directly to or\nfrom memory or even from other types of registers.  An example is the\n@samp{MQ} register, which on most machines, can only be copied to or\nfrom general registers, but not memory.  Below, we shall be using the\nterm 'intermediate register' when a move operation cannot be performed\ndirectly, but has to be done by copying the source into the intermediate\nregister first, and then copying the intermediate register to the\ndestination.  An intermediate register always has the same mode as\nsource and destination.  Since it holds the actual value being copied,\nreload might apply optimizations to re-use an intermediate register\nand eliding the copy from the source when it can determine that the\nintermediate register still holds the required value.\n\nAnother kind of secondary reload is required on some machines which\nallow copying all registers to and from memory, but require a scratch\nregister for stores to some memory locations (e.g., those with symbolic\naddress on the RT, and those with certain symbolic address on the SPARC\nwhen compiling PIC)@.  Scratch registers need not have the same mode\nas the value being copied, and usually hold a different value than\nthat being copied.  Special patterns in the md file are needed to\ndescribe how the copy is performed with the help of the scratch register;\nthese patterns also describe the number, register class(es) and mode(s)\nof the scratch register(s).\n\nIn some cases, both an intermediate and a scratch register are required.\n\nFor input reloads, this target hook is called with nonzero @var{in_p},\nand @var{x} is an rtx that needs to be copied to a register of class\n@var{reload_class} in @var{reload_mode}.  For output reloads, this target\nhook is called with zero @var{in_p}, and a register of class @var{reload_class}\nneeds to be copied to rtx @var{x} in @var{reload_mode}.\n\nIf copying a register of @var{reload_class} from/to @var{x} requires\nan intermediate register, the hook @code{secondary_reload} should\nreturn the register class required for this intermediate register.\nIf no intermediate register is required, it should return NO_REGS.\nIf more than one intermediate register is required, describe the one\nthat is closest in the copy chain to the reload register.\n\nIf scratch registers are needed, you also have to describe how to\nperform the copy from/to the reload register to/from this\nclosest intermediate register.  Or if no intermediate register is\nrequired, but still a scratch register is needed, describe the\ncopy  from/to the reload register to/from the reload operand @var{x}.\n\nYou do this by setting @code{sri->icode} to the instruction code of a pattern\nin the md file which performs the move.  Operands 0 and 1 are the output\nand input of this copy, respectively.  Operands from operand 2 onward are\nfor scratch operands.  These scratch operands must have a mode, and a\nsingle-register-class\n@c [later: or memory]\noutput constraint.\n\nWhen an intermediate register is used, the @code{secondary_reload}\nhook will be called again to determine how to copy the intermediate\nregister to/from the reload operand @var{x}, so your hook must also\nhave code to handle the register class of the intermediate operand.\n\n@c [For later: maybe we'll allow multi-alternative reload patterns -\n@c   the port maintainer could name a mov<mode> pattern that has clobbers -\n@c   and match the constraints of input and output to determine the required\n@c   alternative.  A restriction would be that constraints used to match\n@c   against reloads registers would have to be written as register class\n@c   constraints, or we need a new target macro / hook that tells us if an\n@c   arbitrary constraint can match an unknown register of a given class.\n@c   Such a macro / hook would also be useful in other places.]\n\n\n@var{x} might be a pseudo-register or a @code{subreg} of a\npseudo-register, which could either be in a hard register or in memory.\nUse @code{true_regnum} to find out; it will return @minus{}1 if the pseudo is\nin memory and the hard register number if it is in a register.\n\nScratch operands in memory (constraint @code{\"=m\"} / @code{\"=&m\"}) are\ncurrently not supported.  For the time being, you will have to continue\nto use @code{TARGET_SECONDARY_MEMORY_NEEDED} for that purpose.\n\n@code{copy_cost} also uses this target hook to find out how values are\ncopied.  If you want it to include some extra cost for the need to allocate\n(a) scratch register(s), set @code{sri->extra_cost} to the additional cost.\nOr if two dependent moves are supposed to have a lower cost than the sum\nof the individual moves due to expected fortuitous scheduling and/or special\nforwarding logic, you can set @code{sri->extra_cost} to a negative amount.", "reg_class_t", "TARGET_" "secondary_reload", "(bool in_p, rtx x, reg_class_t reload_class, machine_mode reload_mode, secondary_reload_info *sri)", "default_secondary_reload", "Target Hook" },
# 5602 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Certain machines have the property that some registers cannot be copied\nto some other registers without using memory.  Define this hook on\nthose machines to return true if objects of mode @var{m} in registers\nof @var{class1} can only be copied to registers of class @var{class2} by\n storing a register of @var{class1} into memory and loading that memory\nlocation into a register of @var{class2}.  The default definition returns\nfalse for all inputs.", "bool", "TARGET_" "secondary_memory_needed", "(machine_mode mode, reg_class_t class1, reg_class_t class2)", "hook_bool_mode_reg_class_t_reg_class_t_false", "Target Hook" },
# 5614 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If @code{TARGET_SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\nwhen moving between two particular registers of mode @var{mode},\nthis hook specifies the mode that the memory should have.\n\nThe default depends on @code{TARGET_LRA_P}.  Without LRA, the default\nis to use a word-sized mode for integral modes that are smaller than a\na word.  This is right thing to do on most machines because it ensures\nthat all bits of the register are copied and prevents accesses to the\nregisters in a narrower mode, which some machines prohibit for\nfloating-point registers.\n\nHowever, this default behavior is not correct on some machines, such as\nthe DEC Alpha, that store short integers in floating-point registers\ndifferently than in integer registers.  On those machines, the default\nwidening will not work correctly and you must define this hook to\nsuppress that widening in some cases.  See the file @file{alpha.c} for\ndetails.\n\nWith LRA, the default is to use @var{mode} unmodified.", "machine_mode", "TARGET_" "secondary_memory_needed_mode", "(machine_mode mode)", "default_secondary_memory_needed_mode", "Target Hook" },
# 5640 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook that places additional restrictions on the register class\nto use when it is necessary to copy value @var{x} into a register in class\n@var{rclass}.  The value is a register class; perhaps @var{rclass}, or perhaps\nanother, smaller class.\n\nThe default version of this hook always returns value of @code{rclass} argument.\n\nSometimes returning a more restrictive class makes better code.  For\nexample, on the 68000, when @var{x} is an integer constant that is in range\nfor a @samp{moveq} instruction, the value of this macro is always\n@code{DATA_REGS} as long as @var{rclass} includes the data registers.\nRequiring a data register guarantees that a @samp{moveq} will be used.\n\nOne case where @code{TARGET_PREFERRED_RELOAD_CLASS} must not return\n@var{rclass} is if @var{x} is a legitimate constant which cannot be\nloaded into some register class.  By returning @code{NO_REGS} you can\nforce @var{x} into a memory location.  For example, rs6000 can load\nimmediate values into general-purpose registers, but does not have an\ninstruction for loading an immediate value into a floating-point\nregister, so @code{TARGET_PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when\n@var{x} is a floating-point constant.  If the constant can't be loaded\ninto any kind of register, code generation will be better if\n@code{TARGET_LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead\nof using @code{TARGET_PREFERRED_RELOAD_CLASS}.\n\nIf an insn has pseudos in it after register allocation, reload will go\nthrough the alternatives and call repeatedly @code{TARGET_PREFERRED_RELOAD_CLASS}\nto find the best one.  Returning @code{NO_REGS}, in this case, makes\nreload add a @code{!} in front of the constraint: the x86 back-end uses\nthis feature to discourage usage of 387 registers when math is done in\nthe SSE registers (and vice versa).", "reg_class_t", "TARGET_" "preferred_reload_class", "(rtx x, reg_class_t rclass)", "default_preferred_reload_class", "Target Hook" },
# 5679 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Like @code{TARGET_PREFERRED_RELOAD_CLASS}, but for output reloads instead of\ninput reloads.\n\nThe default version of this hook always returns value of @code{rclass}\nargument.\n\nYou can also use @code{TARGET_PREFERRED_OUTPUT_RELOAD_CLASS} to discourage\nreload from using some alternatives, like @code{TARGET_PREFERRED_RELOAD_CLASS}.", "reg_class_t", "TARGET_" "preferred_output_reload_class", "(rtx x, reg_class_t rclass)", "default_preferred_output_reload_class", "Target Hook" },
# 5693 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On some targets, certain modes cannot be held in registers around a\nstandard ABI call and are relatively expensive to spill to the stack.\nThe early rematerialization pass can help in such cases by aggressively\nrecomputing values after calls, so that they don't need to be spilled.\n\nThis hook returns the set of such modes by setting the associated bits\nin @var{modes}.  The default implementation selects no modes, which has\nthe effect of disabling the early rematerialization pass.", "void", "TARGET_" "select_early_remat_modes", "(sbitmap modes)", "default_select_early_remat_modes", "Target Hook" },
# 5706 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns @code{true} if pseudos that have been assigned\nto registers of class @var{rclass} would likely be spilled because\nregisters of @var{rclass} are needed for spill registers.\n\nThe default version of this target hook returns @code{true} if @var{rclass}\nhas exactly one register and @code{false} otherwise.  On most machines, this\ndefault should be used.  For generally register-starved machines, such as\ni386, or machines with right register constraints, such as SH, this hook\ncan be used to avoid excessive spilling.\n\nThis hook is also used by some of the global intra-procedural code\ntransformations to throtle code motion, to avoid increasing register\npressure.", "bool", "TARGET_" "class_likely_spilled_p", "(reg_class_t rclass)", "default_class_likely_spilled_p", "Target Hook" },
# 5726 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook returns the maximum number of consecutive registers\nof class @var{rclass} needed to hold a value of mode @var{mode}.\n\nThis is closely related to the macro @code{TARGET_HARD_REGNO_NREGS}.\nIn fact, the value returned by @code{TARGET_CLASS_MAX_NREGS (@var{rclass},\n@var{mode})} target hook should be the maximum value of\n@code{TARGET_HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\nvalues in the class @var{rclass}.\n\nThis target hook helps control the handling of multiple-word values\nin the reload pass.\n\nThe default version of this target hook returns the size of @var{mode}\nin words.", "unsigned char", "TARGET_" "class_max_nregs", "(reg_class_t rclass, machine_mode mode)", "default_class_max_nregs", "Target Hook" },
# 5745 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook that places additional preference on the register class to use when it is necessary to rename a register in class @var{rclass} to another class, or perhaps @var{NO_REGS}, if no preferred register class is found or hook @code{preferred_rename_class} is not implemented. Sometimes returning a more restrictive class makes better code.  For example, on ARM, thumb-2 instructions using @code{LO_REGS} may be smaller than instructions using @code{GENERIC_REGS}.  By returning @code{LO_REGS} from @code{preferred_rename_class}, code size can be reduced.", "reg_class_t", "TARGET_" "preferred_rename_class", "(reg_class_t rclass)", "default_preferred_rename_class", "Target Hook" },
# 5762 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "A target hook which returns @code{true} if @var{subst} can't\nsubstitute safely pseudos with equivalent memory values during\nregister allocation.\nThe default version of this target hook returns @code{false}.\nOn most machines, this default should be used.  For generally\nmachines with non orthogonal register usage for addressing, such\nas SH, this hook can be used to avoid excessive spilling.", "bool", "TARGET_" "cannot_substitute_mem_equiv_p", "(rtx subst)", "hook_bool_rtx_false", "Target Hook" },
# 5776 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook tries to split address offset @var{orig_offset} into\ntwo parts: one that should be added to the base address to create\na local anchor point, and an additional offset that can be applied\nto the anchor to address a value of mode @var{mode}.  The idea is that\nthe local anchor could be shared by other accesses to nearby locations.\n\nThe hook returns true if it succeeds, storing the offset of the\nanchor from the base in @var{offset1} and the offset of the final address\nfrom the anchor in @var{offset2}.  The default implementation returns false.", "bool", "TARGET_" "legitimize_address_displacement", "(rtx *offset1, rtx *offset2, poly_int64 orig_offset, machine_mode mode)", "default_legitimize_address_displacement", "Target Hook" },
# 5792 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called just before expansion into rtl, allowing the target\nto perform additional initializations or analysis before the expansion.\nFor example, the rs6000 port uses it to allocate a scratch stack slot\nfor use in copying SDmode values between memory and floating point\nregisters whenever the function being expanded has any SDmode\nusage.", "void", "TARGET_" "expand_to_rtl_hook", "(void)", "hook_void_void", "Target Hook" },
# 5806 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook allows the backend to perform additional instantiations on rtl\nthat are not actually in any insns yet, but will be later.", "void", "TARGET_" "instantiate_decls", "(void)", "hook_void_void", "Target Hook" },






{ "This hook returns the number of consecutive hard registers, starting\nat register number @var{regno}, required to hold a value of mode\n@var{mode}.  This hook must never return zero, even if a register\ncannot hold the requested mode - indicate that with\n@code{TARGET_HARD_REGNO_MODE_OK} and/or\n@code{TARGET_CAN_CHANGE_MODE_CLASS} instead.\n\nThe default definition returns the number of words in @var{mode}.", "unsigned int", "TARGET_" "hard_regno_nregs", "(unsigned int regno, machine_mode mode)", "default_hard_regno_nregs", "Target Hook" },
# 5826 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if it is permissible to store a value\nof mode @var{mode} in hard register number @var{regno} (or in several\nregisters starting with that one).  The default definition returns true\nunconditionally.\n\nYou need not include code to check for the numbers of fixed registers,\nbecause the allocation mechanism considers them to be always occupied.\n\n@cindex register pairs\nOn some machines, double-precision values must be kept in even/odd\nregister pairs.  You can implement that by defining this hook to reject\nodd register numbers for such modes.\n\nThe minimum requirement for a mode to be OK in a register is that the\n@samp{mov@var{mode}} instruction pattern support moves between the\nregister and other hard register in the same class and that moving a\nvalue into the register and back out not alter it.\n\nSince the same instruction used to move @code{word_mode} will work for\nall narrower integer modes, it is not necessary on any machine for\nthis hook to distinguish between these modes, provided you define\npatterns @samp{movhi}, etc., to take advantage of this.  This is\nuseful because of the interaction between @code{TARGET_HARD_REGNO_MODE_OK}\nand @code{TARGET_MODES_TIEABLE_P}; it is very desirable for all integer\nmodes to be tieable.\n\nMany machines have special registers for floating point arithmetic.\nOften people assume that floating point machine modes are allowed only\nin floating point registers.  This is not true.  Any registers that\ncan hold integers can safely @emph{hold} a floating point machine\nmode, whether or not floating arithmetic can be done on it in those\nregisters.  Integer move instructions can be used to move the values.\n\nOn some machines, though, the converse is true: fixed-point machine\nmodes may not go in floating registers.  This is true if the floating\nregisters normalize any value stored in them, because storing a\nnon-floating value there would garble it.  In this case,\n@code{TARGET_HARD_REGNO_MODE_OK} should reject fixed-point machine modes in\nfloating registers.  But if the floating registers do not automatically\nnormalize, if you can store any bit pattern in one and retrieve it\nunchanged without a trap, then any machine mode may go in a floating\nregister, so you can define this hook to say so.\n\nThe primary significance of special floating registers is rather that\nthey are the registers acceptable in floating point arithmetic\ninstructions.  However, this is of no concern to\n@code{TARGET_HARD_REGNO_MODE_OK}.  You handle it by writing the proper\nconstraints for those instructions.\n\nOn some machines, the floating registers are especially slow to access,\nso that it is better to store a value in a stack frame than in such a\nregister if floating point arithmetic is not being done.  As long as the\nfloating registers are not in class @code{GENERAL_REGS}, they will not\nbe used unless some pattern's constraint asks for one.", "bool", "TARGET_" "hard_regno_mode_ok", "(unsigned int regno, machine_mode mode)", "hook_bool_uint_mode_true", "Target Hook" },
# 5885 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if a value of mode @var{mode1} is accessible\nin mode @var{mode2} without copying.\n\nIf @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always\nthe same for any @var{r}, then\n@code{TARGET_MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\nshould be true.  If they differ for any @var{r}, you should define\nthis hook to return false unless some other mechanism ensures the\naccessibility of the value in a narrower mode.\n\nYou should define this hook to return true in as many cases as\npossible since doing so will allow GCC to perform better register\nallocation.  The default definition returns true unconditionally.", "bool", "TARGET_" "modes_tieable_p", "(machine_mode mode1, machine_mode mode2)", "hook_bool_mode_mode_true", "Target Hook" },
# 5906 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if it is OK to use a hard register\n@var{regno} as scratch reg in peephole2.\n\nOne common use of this macro is to prevent using of a register that\nis not saved by a prologue in an interrupt handler.\n\nThe default version of this hook always returns @code{true}.", "bool", "TARGET_" "hard_regno_scratch_ok", "(unsigned int regno)", "default_hard_regno_scratch_ok", "Target Hook" },
# 5918 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "ABIs usually specify that calls must preserve the full contents\nof a particular register, or that calls can alter any part of a\nparticular register.  This information is captured by the target macro\n@code{CALL_REALLY_USED_REGISTERS}.  However, some ABIs specify that calls\nmust preserve certain bits of a particular register but can alter others.\nThis hook should return true if this applies to at least one of the\nregisters in @samp{(reg:@var{mode} @var{regno})}, and if as a result the\ncall would alter part of the @var{mode} value.  For example, if a call\npreserves the low 32 bits of a 64-bit hard register @var{regno} but can\nclobber the upper 32 bits, this hook should return true for a 64-bit mode\nbut false for a 32-bit mode.\n\nThe value of @var{abi_id} comes from the @code{predefined_function_abi}\nstructure that describes the ABI of the call; see the definition of the\nstructure for more details.  If (as is usual) the target uses the same ABI\nfor all functions in a translation unit, @var{abi_id} is always 0.\n\nThe default implementation returns false, which is correct\nfor targets that don't have partly call-clobbered registers.", "bool", "TARGET_" "hard_regno_call_part_clobbered", "(unsigned int abi_id, unsigned int regno, machine_mode mode)", "hook_bool_uint_uint_mode_false", "Target Hook" },
# 5942 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns name of multilib ABI name.", "const char *", "TARGET_" "get_multilib_abi_name", "(void)", "hook_constcharptr_void_null", "Target Hook" },







{ "This function return the smallest number of different values for which it\nis best to use a jump-table instead of a tree of conditional branches.\nThe default is four for machines with a @code{casesi} instruction and\nfive otherwise.  This is best for most machines.", "unsigned int", "TARGET_" "case_values_threshold", "(void)", "default_case_values_threshold", "Target Hook" },
# 5959 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the offset from the frame pointer to the first local\nvariable slot to be allocated.  If @code{FRAME_GROWS_DOWNWARD}, it is the\noffset to @emph{end} of the first slot allocated, otherwise it is the\noffset to @emph{beginning} of the first slot allocated.  The default\nimplementation returns 0.", "HOST_WIDE_INT", "TARGET_" "starting_frame_offset", "(void)", "hook_hwi_void_0", "Target Hook" },
# 5970 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook is called once each time the frame layout needs to be\nrecalculated.  The calculations can be cached by the target and can then\nbe used by @code{INITIAL_ELIMINATION_OFFSET} instead of re-computing the\nlayout on every invocation of that hook.  This is particularly useful\nfor targets that have an expensive frame layout function.  Implementing\nthis callback is optional.", "void", "TARGET_" "compute_frame_layout", "(void)", "hook_void_void", "Target Hook" },
# 5982 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if a function must have and use\na frame pointer.  This target hook is called in the reload pass.  If its return\nvalue is @code{true} the function will have a frame pointer.\n\nThis target hook can in principle examine the current function and decide\naccording to the facts, but on most machines the constant @code{false} or the\nconstant @code{true} suffices.  Use @code{false} when the machine allows code\nto be generated with no frame pointer, and doing so saves some time or space.\nUse @code{true} when there is no possible advantage to avoiding a frame\npointer.\n\nIn certain cases, the compiler does not know how to produce valid code\nwithout a frame pointer.  The compiler recognizes those cases and\nautomatically gives the function a frame pointer regardless of what\n@code{targetm.frame_pointer_required} returns.  You don't need to worry about\nthem.\n\nIn a function that does not require a frame pointer, the frame pointer\nregister can be allocated for ordinary usage, unless you mark it as a\nfixed register.  See @code{FIXED_REGISTERS} for more information.\n\nDefault return value is @code{false}.", "bool", "TARGET_" "frame_pointer_required", "(void)", "hook_bool_void_false", "Target Hook" },
# 6011 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook should return @code{true} if the compiler is allowed to\ntry to replace register number @var{from_reg} with register number\n@var{to_reg}.  This target hook will usually be @code{true}, since most of the\ncases preventing register elimination are things that the compiler already\nknows about.\n\nDefault return value is @code{true}.", "bool", "TARGET_" "can_eliminate", "(const int from_reg, const int to_reg)", "hook_bool_const_int_const_int_true", "Target Hook" },
# 6026 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook may conditionally modify five variables\n@code{fixed_regs}, @code{call_used_regs}, @code{global_regs},\n@code{reg_names}, and @code{reg_class_contents}, to take into account\nany dependence of these register sets on target flags.  The first three\nof these are of type @code{char []} (interpreted as boolean vectors).\n@code{global_regs} is a @code{const char *[]}, and\n@code{reg_class_contents} is a @code{HARD_REG_SET}.  Before the macro is\ncalled, @code{fixed_regs}, @code{call_used_regs},\n@code{reg_class_contents}, and @code{reg_names} have been initialized\nfrom @code{FIXED_REGISTERS}, @code{CALL_USED_REGISTERS},\n@code{REG_CLASS_CONTENTS}, and @code{REGISTER_NAMES}, respectively.\n@code{global_regs} has been cleared, and any @option{-ffixed-@var{reg}},\n@option{-fcall-used-@var{reg}} and @option{-fcall-saved-@var{reg}}\ncommand options have been applied.\n\n@cindex disabling certain registers\n@cindex controlling register usage\nIf the usage of an entire class of registers depends on the target\nflags, you may indicate this to GCC by using this macro to modify\n@code{fixed_regs} and @code{call_used_regs} to 1 for each of the\nregisters in the classes which should not be used by GCC@.  Also make\n@code{define_register_constraint}s return @code{NO_REGS} for constraints\nthat shouldn't be used.\n\n(However, if this class is not included in @code{GENERAL_REGS} and all\nof the insn patterns whose constraints permit this class are\ncontrolled by target switches, then GCC will automatically avoid using\nthese registers when the target switches are opposed to them.)", "void", "TARGET_" "conditional_register_usage", "(void)", "hook_void_void", "Target Hook" },
# 6059 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Some targets have an ABI defined interval for which no probing needs to be done.\nWhen a probe does need to be done this same interval is used as the probe distance up when doing stack clash protection for alloca.\nOn such targets this value can be set to override the default probing up interval.\nDefine this variable to return nonzero if such a probe range is required or zero otherwise.  Defining this hook also requires your functions which make use of alloca to have at least 8 byesof outgoing arguments.  If this is not the case the stack will be corrupted.\nYou need not define this macro if it would always have the value zero.", "HOST_WIDE_INT", "TARGET_" "stack_clash_protection_alloca_probe_range", "(void)", "default_stack_clash_protection_alloca_probe_range", "Target Hook" },
# 6076 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "TARGET_C", 0, 0, "Target Hook" },


{ "*", "machine_mode", "TARGET_C_" "mode_for_suffix", "(char c)", "default_mode_for_suffix", "Target Hook" },






{ "Return a value, with the same meaning as the C99 macro @code{FLT_EVAL_METHOD} that describes which excess precision should be applied.  @var{type} is either @code{EXCESS_PRECISION_TYPE_IMPLICIT}, @code{EXCESS_PRECISION_TYPE_FAST}, or @code{EXCESS_PRECISION_TYPE_STANDARD}.  For @code{EXCESS_PRECISION_TYPE_IMPLICIT}, the target should return which precision and range operations will be implictly evaluated in regardless of the excess precision explicitly added.  For @code{EXCESS_PRECISION_TYPE_STANDARD} and @code{EXCESS_PRECISION_TYPE_FAST}, the target should return the explicit excess precision that should be added depending on the value set for @option{-fexcess-precision=@r{[}standard@r{|}fast@r{]}}. Note that unpredictable explicit excess precision does not make sense, so a target should never return @code{FLT_EVAL_METHOD_UNPREDICTABLE} when @var{type} is @code{EXCESS_PRECISION_TYPE_STANDARD} or @code{EXCESS_PRECISION_TYPE_FAST}.", "enum flt_eval_method", "TARGET_C_" "excess_precision", "(enum excess_precision_type type)", "default_excess_precision", "Target Hook" },
# 6107 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_CXX", 0, 0, "Target Hook" },


{ "Define this hook to override the integer type used for guard variables.\nThese are used to implement one-time construction of static objects.  The\ndefault is long_long_integer_type_node.", "tree", "TARGET_CXX_" "guard_type", "(void)", "default_cxx_guard_type", "Target Hook" },
# 6124 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook determines how guard variables are used.  It should return\n@code{false} (the default) if the first byte should be used.  A return value of\n@code{true} indicates that only the least significant bit should be used.", "bool", "TARGET_CXX_" "guard_mask_bit", "(void)", "hook_bool_void_false", "Target Hook" },
# 6133 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns the size of the cookie to use when allocating an array\nwhose elements have the indicated @var{type}.  Assumes that it is already\nknown that a cookie is needed.  The default is\n@code{max(sizeof (size_t), alignof(type))}, as defined in section 2.7 of the\nIA64/Generic C++ ABI@.", "tree", "TARGET_CXX_" "get_cookie_size", "(tree type)", "default_cxx_get_cookie_size", "Target Hook" },
# 6144 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return @code{true} if the element size should be stored in\narray cookies.  The default is to return @code{false}.", "bool", "TARGET_CXX_" "cookie_has_size", "(void)", "hook_bool_void_false", "Target Hook" },
# 6153 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined by a backend this hook allows the decision made to export\nclass @var{type} to be overruled.  Upon entry @var{import_export}\nwill contain 1 if the class is going to be exported, @minus{}1 if it is going\nto be imported and 0 otherwise.  This function should return the\nmodified value and perform any other actions necessary to support the\nbackend's targeted operating system.", "int", "TARGET_CXX_" "import_export_class", "(tree type, int import_export)", "NULL", "Target Hook" },
# 6164 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return @code{true} if constructors and destructors return\nthe address of the object created/destroyed.  The default is to return\n@code{false}.", "bool", "TARGET_CXX_" "cdtor_returns_this", "(void)", "hook_bool_void_false", "Target Hook" },
# 6175 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if the key method for a class (i.e., the method\nwhich, if defined in the current translation unit, causes the virtual\ntable to be emitted) may be an inline function.  Under the standard\nItanium C++ ABI the key method may be an inline function so long as\nthe function is not declared inline in the class definition.  Under\nsome variants of the ABI, an inline function can never be the key\nmethod.  The default is to return @code{true}.", "bool", "TARGET_CXX_" "key_method_may_be_inline", "(void)", "hook_bool_void_true", "Target Hook" },
# 6187 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "@var{decl} is a virtual table, virtual table table, typeinfo object, or other similar implicit class data object that will be emitted with external linkage in this translation unit.  No ELF visibility has been explicitly specified.  If the target needs to specify a visibility other than that of the containing class, use this hook to set @code{DECL_VISIBILITY} and @code{DECL_VISIBILITY_SPECIFIED}.", "void", "TARGET_CXX_" "determine_class_data_visibility", "(tree decl)", "hook_void_tree", "Target Hook" },
# 6203 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true (the default) if virtual tables and other\nsimilar implicit class data objects are always COMDAT if they have\nexternal linkage.  If this hook returns false, then class data for\nclasses whose virtual table will be emitted in only one translation\nunit will not be COMDAT.", "bool", "TARGET_CXX_" "class_data_always_comdat", "(void)", "hook_bool_void_true", "Target Hook" },
# 6216 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true (the default) if the RTTI information for\nthe basic types which is defined in the C++ runtime should always\nbe COMDAT, false if it should not be COMDAT.", "bool", "TARGET_CXX_" "library_rtti_comdat", "(void)", "hook_bool_void_true", "Target Hook" },
# 6226 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if @code{__aeabi_atexit} (as defined by the ARM EABI)\nshould be used to register static destructors when @option{-fuse-cxa-atexit}\nis in effect.  The default is to return false to use @code{__cxa_atexit}.", "bool", "TARGET_CXX_" "use_aeabi_atexit", "(void)", "hook_bool_void_false", "Target Hook" },
# 6236 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook returns true if the target @code{atexit} function can be used\nin the same manner as @code{__cxa_atexit} to register C++ static\ndestructors. This requires that @code{atexit}-registered functions in\nshared libraries are run in the correct order when the libraries are\nunloaded. The default is to return false.", "bool", "TARGET_CXX_" "use_atexit_for_cxa_atexit", "(void)", "hook_bool_void_false", "Target Hook" },
# 6246 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "@var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been defined.  Use this hook to make adjustments to the class (eg, tweak visibility or perform any other required target modifications).", "void", "TARGET_CXX_" "adjust_class_at_definition", "(tree type)", "hook_void_tree", "Target Hook" },







{ "Return target-specific mangling context of @var{decl} or @code{NULL_TREE}.", "tree", "TARGET_CXX_" "decl_mangling_context", "(const_tree decl)", "hook_tree_const_tree_null", "Target Hook" },





{ 0, 0, "", 0, 0, "Target Hook" },




{ 0, 0, "TARGET_EMUTLS", 0, 0, "Target Hook" },


{ "Contains the name of the helper function that uses a TLS control\nobject to locate a TLS instance.  The default causes libgcc's\nemulated TLS helper function to be used.", "const char *", "TARGET_EMUTLS_" "get_address", 0, "\"__builtin___emutls_get_address\"", "Target Hook" },






{ "Contains the name of the helper function that should be used at\nprogram startup to register TLS objects that are implicitly\ninitialized to zero.  If this is @code{NULL}, all TLS objects will\nhave explicit initializers.  The default causes libgcc's emulated TLS\nregistration function to be used.", "const char *", "TARGET_EMUTLS_" "register_common", 0, "\"__builtin___emutls_register_common\"", "Target Hook" },
# 6285 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Contains the name of the section in which TLS control variables should\nbe placed.  The default of @code{NULL} allows these to be placed in\nany section.", "const char *", "TARGET_EMUTLS_" "var_section", 0, "NULL", "Target Hook" },






{ "Contains the name of the section in which TLS initializers should be\nplaced.  The default of @code{NULL} allows these to be placed in any\nsection.", "const char *", "TARGET_EMUTLS_" "tmpl_section", 0, "NULL", "Target Hook" },







{ "Contains the prefix to be prepended to TLS control variable names.\nThe default of @code{NULL} uses a target-specific prefix.", "const char *", "TARGET_EMUTLS_" "var_prefix", 0, "NULL", "Target Hook" },





{ "Contains the prefix to be prepended to TLS initializer objects.  The\ndefault of @code{NULL} uses a target-specific prefix.", "const char *", "TARGET_EMUTLS_" "tmpl_prefix", 0, "NULL", "Target Hook" },






{ "Specifies a function that generates the FIELD_DECLs for a TLS control\nobject type.  @var{type} is the RECORD_TYPE the fields are for and\n@var{name} should be filled with the structure tag, if the default of\n@code{__emutls_object} is unsuitable.  The default creates a type suitable\nfor libgcc's emulated TLS function.", "tree", "TARGET_EMUTLS_" "var_fields", "(tree type, tree *name)", "default_emutls_var_fields", "Target Hook" },
# 6324 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Specifies a function that generates the CONSTRUCTOR to initialize a\nTLS control object.  @var{var} is the TLS control object, @var{decl}\nis the TLS object and @var{tmpl_addr} is the address of the\ninitializer.  The default initializes libgcc's emulated TLS control object.", "tree", "TARGET_EMUTLS_" "var_init", "(tree var, tree decl, tree tmpl_addr)", "default_emutls_var_init", "Target Hook" },
# 6335 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Specifies whether the alignment of TLS control variable objects is\nfixed and should not be increased as some backends may do to optimize\nsingle objects.  The default is false.", "bool", "TARGET_EMUTLS_" "var_align_fixed", 0, "false", "Target Hook" },







{ "Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor\nmay be used to describe emulated TLS control objects.", "bool", "TARGET_EMUTLS_" "debug_form_tls_address", 0, "false", "Target Hook" },





{ 0, 0, "", 0, 0, "Target Hook" },



{ 0, 0, "TARGET_OPTION_HOOKS", 0, 0, "Target Hook" },




{ "This hook is called to parse @code{attribute(target(\"...\"))}, which\nallows setting target-specific options on individual functions.\nThese function-specific options may differ\nfrom the options specified on the command line.  The hook should return\n@code{true} if the options are valid.\n\nThe hook should set the @code{DECL_FUNCTION_SPECIFIC_TARGET} field in\nthe function declaration to hold a pointer to a target-specific\n@code{struct cl_target_option} structure.", "bool", "TARGET_OPTION_" "valid_attribute_p", "(tree fndecl, tree name, tree args, int flags)", "default_target_option_valid_attribute_p", "Target Hook" },
# 6373 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called to save any additional target-specific information\nin the @code{struct cl_target_option} structure for function-specific\noptions from the @code{struct gcc_options} structure.\n@xref{Option file format}.", "void", "TARGET_OPTION_" "save", "(struct cl_target_option *ptr, struct gcc_options *opts)", "NULL", "Target Hook" },
# 6383 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called to restore any additional target-specific\ninformation in the @code{struct cl_target_option} structure for\nfunction-specific options to the @code{struct gcc_options} structure.", "void", "TARGET_OPTION_" "restore", "(struct gcc_options *opts, struct cl_target_option *ptr)", "NULL", "Target Hook" },
# 6392 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called to update target-specific information in the\n@code{struct cl_target_option} structure after it is streamed in from\nLTO bytecode.", "void", "TARGET_OPTION_" "post_stream_in", "(struct cl_target_option *ptr)", "NULL", "Target Hook" },
# 6401 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook is called to print any additional target-specific\ninformation in the @code{struct cl_target_option} structure for\nfunction-specific options.", "void", "TARGET_OPTION_" "print", "(FILE *file, int indent, struct cl_target_option *ptr)", "NULL", "Target Hook" },
# 6412 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook parses the options for @code{#pragma GCC target}, which\nsets the target-specific options for functions that occur later in the\ninput stream.  The options accepted should be the same as those handled by the\n@code{TARGET_OPTION_VALID_ATTRIBUTE_P} hook.", "bool", "TARGET_OPTION_" "pragma_parse", "(tree args, tree pop_target)", "default_target_option_pragma_parse", "Target Hook" },
# 6422 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Sometimes certain combinations of command options do not make sense on\na particular target machine.  You can override the hook\n@code{TARGET_OPTION_OVERRIDE} to take account of this.  This hooks is called\nonce just after all the command options have been parsed.\n\nDon't use this hook to turn on various extra optimizations for\n@option{-O}.  That is what @code{TARGET_OPTION_OPTIMIZATION} is for.\n\nIf you need to do something whenever the optimization level is\nchanged via the optimize attribute or pragma, see\n@code{TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE}", "void", "TARGET_OPTION_" "override", "(void)", "hook_void_void", "Target Hook" },
# 6442 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns @code{true} if @var{DECL1} and @var{DECL2} are\nversions of the same function.  @var{DECL1} and @var{DECL2} are function\nversions if and only if they have the same function signature and\ndifferent target specific attributes, that is, they are compiled for\ndifferent target machines.", "bool", "TARGET_OPTION_" "function_versions", "(tree decl1, tree decl2)", "hook_bool_tree_tree_false", "Target Hook" },
# 6455 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook returns @code{false} if the @var{caller} function\ncannot inline @var{callee}, based on target specific information.  By\ndefault, inlining is not allowed if the callee function has function\nspecific target options and the caller does not use the same options.", "bool", "TARGET_" "can_inline_p", "(tree caller, tree callee)", "default_target_can_inline_p", "Target Hook" },
# 6464 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This target hook fixes function @var{fndecl} after attributes are processed. Default does nothing. On ARM, the default function's alignment is updated with the attribute target.", "void", "TARGET_" "relayout_function", "(tree fndecl)", "hook_void_tree", "Target Hook" },





{ 0, 0, "", 0, 0, "Target Hook" },




{ "Add any hard registers to @var{regs} that are live on entry to the\nfunction.  This hook only needs to be defined to provide registers that\ncannot be found by examination of FUNCTION_ARG_REGNO_P, the callee saved\nregisters, STATIC_CHAIN_INCOMING_REGNUM, STATIC_CHAIN_REGNUM,\nTARGET_STRUCT_VALUE_RTX, FRAME_POINTER_REGNUM, EH_USES,\nFRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.", "void", "TARGET_" "extra_live_on_entry", "(bitmap regs)", "hook_void_bitmap", "Target Hook" },
# 6489 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Set to true if each call that binds to a local definition explicitly\nclobbers or sets all non-fixed registers modified by performing the call.\nThat is, by the call pattern itself, or by code that might be inserted by the\nlinker (e.g.@: stubs, veneers, branch islands), but not including those\nmodifiable by the callee.  The affected registers may be mentioned explicitly\nin the call pattern, or included as clobbers in CALL_INSN_FUNCTION_USAGE.\nThe default version of this hook is set to false.  The purpose of this hook\nis to enable the fipa-ra optimization.", "bool", "TARGET_" "call_fusage_contains_non_callee_clobbers", 0, "false", "Target Hook" },
# 6503 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should add additional registers that are computed by the prologue to the hard regset for shrink-wrapping optimization purposes.", "void", "TARGET_" "set_up_by_prologue", "(struct hard_reg_set_container *)", "NULL", "Target Hook" },
# 6513 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "True if a function's return statements should be checked for matching the function's return type.  This includes checking for falling off the end of a non-void function.  Return false if no such check should be made.", "bool", "TARGET_" "warn_func_return", "(tree)", "hook_bool_tree_true", "Target Hook" },







{ 0, 0, "TARGET_SHRINK_WRAP_HOOKS", 0, 0, "Target Hook" },

{ "This hook should return an @code{sbitmap} with the bits set for those\ncomponents that can be separately shrink-wrapped in the current function.\nReturn @code{NULL} if the current function should not get any separate\nshrink-wrapping.\nDon't define this hook if it would always return @code{NULL}.\nIf it is defined, the other hooks in this group have to be defined as well.", "sbitmap", "TARGET_SHRINK_WRAP_" "get_separate_components", "(void)", "NULL", "Target Hook" },
# 6534 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook should return an @code{sbitmap} with the bits set for those\ncomponents where either the prologue component has to be executed before\nthe @code{basic_block}, or the epilogue component after it, or both.", "sbitmap", "TARGET_SHRINK_WRAP_" "components_for_bb", "(basic_block)", "NULL", "Target Hook" },







{ "This hook should clear the bits in the @var{components} bitmap for those\ncomponents in @var{edge_components} that the target cannot handle on edge\n@var{e}, where @var{is_prologue} says if this is for a prologue or an\nepilogue instead.", "void", "TARGET_SHRINK_WRAP_" "disqualify_components", "(sbitmap components, edge e, sbitmap edge_components, bool is_prologue)", "NULL", "Target Hook" },
# 6551 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "Emit prologue insns for the components indicated by the parameter.", "void", "TARGET_SHRINK_WRAP_" "emit_prologue_components", "(sbitmap)", "NULL", "Target Hook" },





{ "Emit epilogue insns for the components indicated by the parameter.", "void", "TARGET_SHRINK_WRAP_" "emit_epilogue_components", "(sbitmap)", "NULL", "Target Hook" },





{ "Mark the components in the parameter as handled, so that the\n@code{prologue} and @code{epilogue} named patterns know to ignore those\ncomponents.  The target code should not hang on to the @code{sbitmap}, it\nwill be deleted after this call.", "void", "TARGET_SHRINK_WRAP_" "set_handled_components", "(sbitmap)", "NULL", "Target Hook" },
# 6572 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "", 0, 0, "Target Hook" },




{ "This hook defines the mechanism that will be used for describing frame\nunwind information to the debugger.  Normally the hook will return\n@code{UI_DWARF2} if DWARF 2 debug information is enabled, and\nreturn @code{UI_NONE} otherwise.\n\nA target may return @code{UI_DWARF2} even when DWARF 2 debug information\nis disabled in order to always output DWARF 2 frame information.\n\nA target may return @code{UI_TARGET} if it has ABI specified unwind tables.\nThis will suppress generation of the normal debug frame unwind information.", "enum unwind_info_type", "TARGET_" "debug_unwind_info", "(void)", "default_debug_unwind_info", "Target Hook" },
# 6592 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This hook, if defined, enables -ginternal-reset-location-views, and\nuses its result to override cases in which the estimated min insn\nlength might be nonzero even when a PC advance (i.e., a view reset)\ncannot be taken for granted.\n\nIf the hook is defined, it must return a positive value to indicate\nthe insn definitely advances the PC, and so the view number can be\nsafely assumed to be reset; a negative value to mean the insn\ndefinitely does not advance the PC, and os the view number must not\nbe reset; or zero to decide based on the estimated insn length.\n\nIf insn length is to be regarded as reliable, set the hook to\n@code{hook_int_rtx_insn_0}.", "int", "TARGET_" "reset_location_view", "(rtx_insn *)", "NULL", "Target Hook" },
# 6611 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On some machines not all possible comparisons are defined, but you can\nconvert an invalid comparison into a valid one.  For example, the Alpha\ndoes not have a @code{GT} comparison, but you can use an @code{LT}\ncomparison instead and swap the order of the operands.\n\nOn such machines, implement this hook to do any required conversions.\n@var{code} is the initial comparison code and @var{op0} and @var{op1}\nare the left and right operands of the comparison, respectively.  If\n@var{op0_preserve_value} is @code{true} the implementation is not\nallowed to change the value of @var{op0} since the value might be used\nin RTXs which aren't comparisons.  E.g. the implementation is not\nallowed to swap operands in that case.\n\nGCC will not assume that the comparison resulting from this macro is\nvalid but will see if the resulting insn matches a pattern in the\n@file{md} file.\n\nYou need not to implement this hook if it would never change the\ncomparison code or operands.", "void", "TARGET_" "canonicalize_comparison", "(int *code, rtx *op0, rtx *op1, bool op0_preserve_value)", "default_canonicalize_comparison", "Target Hook" },
# 6635 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "On some RISC architectures with 64-bit registers, the processor also\nmaintains 32-bit condition codes that make it possible to do real 32-bit\narithmetic, although the operations are performed on the full registers.\n\nOn such architectures, defining this hook to 32 tells the compiler to try\nusing 32-bit arithmetical operations setting the condition codes instead\nof doing full 64-bit arithmetic.\n\nMore generally, define this hook on RISC architectures if you want the\ncompiler to try using arithmetical operations setting the condition codes\nwith a precision lower than the word precision.\n\nYou need not define this hook if @code{WORD_REGISTER_OPERATIONS} is not\ndefined to 1.", "unsigned int", "TARGET_" "min_arithmetic_precision", "(void)", "default_min_arithmetic_precision", "Target Hook" },
# 6653 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This value should be set if the result written by @code{atomic_test_and_set} is not exactly 1, i.e.@: the @code{bool} @code{true}.", "unsigned char", "TARGET_" "atomic_test_and_set_trueval", 0, "1", "Target Hook" },
# 6663 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If defined, this function returns an appropriate alignment in bits for an atomic object of machine_mode @var{mode}.  If 0 is returned then the default alignment for the specified mode is used. ", "unsigned int", "TARGET_" "atomic_align_for_mode", "(machine_mode mode)", "hook_uint_mode_0", "Target Hook" },







{ "ISO C11 requires atomic compound assignments that may raise floating-point exceptions to raise exceptions corresponding to the arithmetic operation whose result was successfully stored in a compare-and-exchange sequence.  This requires code equivalent to calls to @code{feholdexcept}, @code{feclearexcept} and @code{feupdateenv} to be generated at appropriate points in the compare-and-exchange sequence.  This hook should set @code{*@var{hold}} to an expression equivalent to the call to @code{feholdexcept}, @code{*@var{clear}} to an expression equivalent to the call to @code{feclearexcept} and @code{*@var{update}} to an expression equivalent to the call to @code{feupdateenv}.  The three expressions are @code{NULL_TREE} on entry to the hook and may be left as @code{NULL_TREE} if no code is required in a particular place.  The default implementation leaves all three expressions as @code{NULL_TREE}.  The @code{__atomic_feraiseexcept} function from @code{libatomic} may be of use as part of the code generated in @code{*@var{update}}.", "void", "TARGET_" "atomic_assign_expand_fenv", "(tree *hold, tree *clear, tree *update)", "default_atomic_assign_expand_fenv", "Target Hook" },
# 6695 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This flag is true if we can create zeroed data by switching to a BSS\nsection and then using @code{ASM_OUTPUT_SKIP} to allocate the space.\nThis is true on most ELF targets.", "bool", "TARGET_" "have_switchable_bss_sections", 0, "false", "Target Hook" },
# 6704 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This value is true if the target supports some ``native'' method of\ncollecting constructors and destructors to be run at startup and exit.\nIt is false if we must use @command{collect2}.", "bool", "TARGET_" "have_ctors_dtors", 0, "false", "Target Hook" },







{ "Contains the value true if the target supports thread-local storage.\nThe default value is false.", "bool", "TARGET_" "have_tls", 0, "false", "Target Hook" },






{ "Contains the value true if the target places read-only\n``small data'' into a separate section.  The default value is false.", "bool", "TARGET_" "have_srodata_section", 0, "false", "Target Hook" },






{ "Contains the value true if the target should add a zero word onto the\nend of a Dwarf-2 frame info section when used for exception handling.\nDefault value is false if @code{EH_FRAME_SECTION_NAME} is defined, and\ntrue otherwise.", "bool", "TARGET_" "terminate_dw2_eh_frame_info", 0, "true", "Target Hook" },
# 6735 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If this flag is true, the text of the macro @code{ASM_APP_OFF} will be\nprinted as the very first line in the assembly file, unless\n@option{-fverbose-asm} is in effect.  (If that macro has been defined\nto the empty string, this variable has no effect.)  With the normal\ndefinition of @code{ASM_APP_OFF}, the effect is to notify the GNU\nassembler that it need not bother stripping comments or extra\nwhitespace from its input.  This allows it to work a bit faster.\n\nThe default is false.  You should not set it to true unless you have\nverified that your port does not generate any extra whitespace or\ncomments that will cause GAS to issue errors in NO_APP mode.", "bool", "TARGET_" "asm_file_start_app_off", 0, "false", "Target Hook" },
# 6752 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "If this flag is true, @code{output_file_directive} will be called\nfor the primary source file, immediately after printing\n@code{ASM_APP_OFF} (if that is enabled).  Most ELF assemblers expect\nthis to be done.  The default is false.", "bool", "TARGET_" "asm_file_start_file_directive", 0, "false", "Target Hook" },
# 6762 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ "This flag should be set to @code{true} on targets that use an ARM EABI\nbased unwinding library, and @code{false} on other targets.  This effects\nthe format of unwinding tables, and how the unwinder in entered after\nrunning a cleanup.  The default is @code{false}.", "bool", "TARGET_" "arm_eabi_unwinder", 0, "false", "Target Hook" },







{ "True if the @code{.debug_pubtypes} and @code{.debug_pubnames} sections should be emitted.  These sections are not used on most platforms, and in particular GDB does not use them.", "bool", "TARGET_" "want_debug_pub_sections", 0, "false", "Target Hook" },






{ "True if sched2 is not to be run at its normal place.\nThis usually means it will be run as part of machine-specific reorg.", "bool", "TARGET_" "delay_sched2", 0, "false", "Target Hook" },




{ "True if vartrack is not to be run at its normal place.\nThis usually means it will be run as part of machine-specific reorg.", "bool", "TARGET_" "delay_vartrack", 0, "false", "Target Hook" },




{ "True if register allocation and the passes\nfollowing it should not be run.  Usually true only for virtual assembler\ntargets.", "bool", "TARGET_" "no_register_allocation", 0, "false", "Target Hook" },
# 6798 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def"
{ 0, 0, "TARGET_TOGGLE_", 0, 0, "Target Hook" },

{ "Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. @var{prev_moxde} indicates the mode to switch from. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.", "void", "TARGET_MODE_" "emit", "(int entity, int mode, int prev_mode, HARD_REG_SET regs_live)", "NULL", "Target Hook" },




{ "@var{entity} is an integer specifying a mode-switched entity.  If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.", "int", "TARGET_MODE_" "needed", "(int entity, rtx_insn *insn)", "NULL", "Target Hook" },




{ "@var{entity} is an integer specifying a mode-switched entity.  If this macro is defined, it is evaluated for every @var{insn} during mode switching.  It determines the mode that an insn results in (if different from the incoming mode).", "int", "TARGET_MODE_" "after", "(int entity, int mode, rtx_insn *insn)", "NULL", "Target Hook" },




{ "If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function entry.  If @code{TARGET_MODE_ENTRY} is defined then @code{TARGET_MODE_EXIT} must be defined.", "int", "TARGET_MODE_" "entry", "(int entity)", "NULL", "Target Hook" },




{ "If this macro is defined, it is evaluated for every @var{entity} that needs mode switching.  It should evaluate to an integer, which is a mode that @var{entity} is assumed to be switched to at function exit.  If @code{TARGET_MODE_EXIT} is defined then @code{TARGET_MODE_ENTRY} must be defined.", "int", "TARGET_MODE_" "exit", "(int entity)", "NULL", "Target Hook" },




{ "This macro specifies the order in which modes for @var{entity} are processed. 0 is the highest priority, @code{NUM_MODES_FOR_MODE_SWITCHING[@var{entity}] - 1} the lowest.  The value of the macro should be an integer designating a mode for @var{entity}.  For any fixed @var{entity}, @code{mode_priority} (@var{entity}, @var{n}) shall be a bijection in 0 @dots{} @code{num_modes_for_mode_switching[@var{entity}] - 1}.", "int", "TARGET_MODE_" "priority", "(int entity, int n)", "NULL", "Target Hook" },




{ 0, 0, "", 0, 0, "Target Hook" },






# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def" 1
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def"
{ "*", "bool", "TARGET_" "have_allocate_stack", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_atomic_test_and_set", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_builtin_longjmp", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_builtin_setjmp_receiver", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_builtin_setjmp_setup", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_canonicalize_funcptr_for_compare", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_call", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_call_pop", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_call_value", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_call_value_pop", "(void)", "false", "Target Hook" },

{ "*", "bool", "TARGET_" "have_casesi", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_check_stack", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_clear_cache", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_doloop_begin", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_doloop_end", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_eh_return", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_epilogue", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_exception_receiver", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_extv", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_extzv", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_indirect_jump", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_insv", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_jump", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_load_multiple", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_mem_thread_fence", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_memory_barrier", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_memory_blockage", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_movstr", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_nonlocal_goto", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_nonlocal_goto_receiver", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_oacc_dim_pos", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_oacc_dim_size", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_oacc_fork", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_oacc_join", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_enter", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_exit", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_lane", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_last_lane", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_ordered", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_vote_any", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_xchg_bfly", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_omp_simt_xchg_idx", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_prefetch", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_probe_stack", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_probe_stack_address", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_prologue", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_ptr_extend", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_reload_load_address", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_restore_stack_block", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_restore_stack_function", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_restore_stack_nonlocal", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_return", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_save_stack_block", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_save_stack_function", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_save_stack_nonlocal", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_sibcall", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_sibcall_epilogue", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_sibcall_value", "(void)", "false", "Target Hook" },

{ "*", "bool", "TARGET_" "have_simple_return", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_split_stack_prologue", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_split_stack_space_check", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_stack_protect_combined_set", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_stack_protect_set", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_stack_protect_combined_test", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_stack_protect_test", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_store_multiple", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_tablejump", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_trap", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_unique", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_untyped_call", "(void)", "false", "Target Hook" },
{ "*", "bool", "TARGET_" "have_untyped_return", "(void)", "false", "Target Hook" },
# 6838 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def" 2




# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def" 1
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def"
{ "*", "rtx_insn *", "TARGET_" "gen_allocate_stack", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_atomic_test_and_set", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_builtin_longjmp", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_builtin_setjmp_receiver", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_builtin_setjmp_setup", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_canonicalize_funcptr_for_compare", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_call", "(rtx x0, rtx opt1, rtx opt2, rtx opt3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_call_pop", "(rtx x0, rtx opt1, rtx opt2, rtx opt3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_call_value", "(rtx x0, rtx x1, rtx opt2, rtx opt3, rtx opt4)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_call_value_pop", "(rtx x0, rtx x1, rtx opt2, rtx opt3, rtx opt4)", "NULL", "Target Hook" },

{ "*", "rtx_insn *", "TARGET_" "gen_casesi", "(rtx x0, rtx x1, rtx x2, rtx x3, rtx x4)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_check_stack", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_clear_cache", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_doloop_begin", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_doloop_end", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_eh_return", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_epilogue", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_exception_receiver", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_extv", "(rtx x0, rtx x1, rtx x2, rtx x3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_extzv", "(rtx x0, rtx x1, rtx x2, rtx x3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_indirect_jump", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_insv", "(rtx x0, rtx x1, rtx x2, rtx x3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_jump", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_load_multiple", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_mem_thread_fence", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_memory_barrier", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_memory_blockage", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_movstr", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_nonlocal_goto", "(rtx x0, rtx x1, rtx x2, rtx x3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_nonlocal_goto_receiver", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_oacc_dim_pos", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_oacc_dim_size", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_oacc_fork", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_oacc_join", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_enter", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_exit", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_lane", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_last_lane", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_ordered", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_vote_any", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_xchg_bfly", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_omp_simt_xchg_idx", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_prefetch", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_probe_stack", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_probe_stack_address", "(rtx x0)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_prologue", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_ptr_extend", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_reload_load_address", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_restore_stack_block", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_restore_stack_function", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_restore_stack_nonlocal", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_return", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_save_stack_block", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_save_stack_function", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_save_stack_nonlocal", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_sibcall", "(rtx x0, rtx opt1, rtx opt2, rtx opt3)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_sibcall_epilogue", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_sibcall_value", "(rtx x0, rtx x1, rtx opt2, rtx opt3, rtx opt4)", "NULL", "Target Hook" },

{ "*", "rtx_insn *", "TARGET_" "gen_simple_return", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_split_stack_prologue", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_split_stack_space_check", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_stack_protect_combined_set", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_stack_protect_set", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_stack_protect_combined_test", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_stack_protect_test", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_store_multiple", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_tablejump", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_trap", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_unique", "(void)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_untyped_call", "(rtx x0, rtx x1, rtx x2)", "NULL", "Target Hook" },
{ "*", "rtx_insn *", "TARGET_" "gen_untyped_return", "(rtx x0, rtx x1)", "NULL", "Target Hook" },
# 6843 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def" 2




# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def" 1
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-insns.def"
{ "*", "enum insn_code", "TARGET_" "code_for_allocate_stack", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_atomic_test_and_set", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_builtin_longjmp", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_builtin_setjmp_receiver", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_builtin_setjmp_setup", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_canonicalize_funcptr_for_compare", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_call", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_call_pop", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_call_value", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_call_value_pop", 0, "CODE_FOR_nothing", "Target Hook" },

{ "*", "enum insn_code", "TARGET_" "code_for_casesi", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_check_stack", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_clear_cache", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_doloop_begin", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_doloop_end", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_eh_return", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_epilogue", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_exception_receiver", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_extv", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_extzv", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_indirect_jump", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_insv", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_jump", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_load_multiple", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_mem_thread_fence", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_memory_barrier", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_memory_blockage", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_movstr", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_nonlocal_goto", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_nonlocal_goto_receiver", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_oacc_dim_pos", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_oacc_dim_size", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_oacc_fork", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_oacc_join", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_enter", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_exit", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_lane", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_last_lane", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_ordered", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_vote_any", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_xchg_bfly", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_omp_simt_xchg_idx", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_prefetch", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_probe_stack", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_probe_stack_address", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_prologue", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_ptr_extend", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_reload_load_address", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_restore_stack_block", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_restore_stack_function", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_restore_stack_nonlocal", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_return", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_save_stack_block", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_save_stack_function", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_save_stack_nonlocal", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_sibcall", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_sibcall_epilogue", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_sibcall_value", 0, "CODE_FOR_nothing", "Target Hook" },

{ "*", "enum insn_code", "TARGET_" "code_for_simple_return", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_split_stack_prologue", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_split_stack_space_check", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_stack_protect_combined_set", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_stack_protect_set", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_stack_protect_combined_test", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_stack_protect_test", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_store_multiple", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_tablejump", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_trap", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_unique", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_untyped_call", 0, "CODE_FOR_nothing", "Target Hook" },
{ "*", "enum insn_code", "TARGET_" "code_for_untyped_return", 0, "CODE_FOR_nothing", "Target Hook" },
# 6848 "/home/giulianob/gcc_git_gnu/gcc/gcc/target.def" 2


{ "If selftests are enabled, run any selftests for this target.", "void", "TARGET_" "run_target_selftests", "(void)", "NULL", "Target Hook" },






{ 0, 0, "", 0, 0, "Target Hook" },
# 35 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def" 1
# 20 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-hooks-macros.h" 1
# 21 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def" 2




{ 0, 0, "TARGETCM_INITIALIZER", 0, 0, "C Target Hook" },
# 35 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ "", "bool", "TARGET_" "handle_c_option", "(size_t code, const char *arg, int value)", "default_handle_c_option", "C Target Hook" },
# 44 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ "Targets may provide a string object type that can be used within and between C, C++ and their respective Objective-C dialects. A string object might, for example, embed encoding and length information. These objects are considered opaque to the compiler and handled as references. An ideal implementation makes the composition of the string object match that of the Objective-C @code{NSString} (@code{NXString} for GNUStep), allowing efficient interworking between C-only and Objective-C code. If a target implements string objects then this hook should return a reference to such an object constructed from the normal `C' string representation provided in @var{string}. At present, the hook is used by Objective-C only, to obtain a common-format string object when the target provides one.", "tree", "TARGET_" "objc_construct_string_object", "(tree string)", "NULL", "C Target Hook" },
# 61 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ "Declare that Objective C class @var{classname} is referenced  by the current TU.", "void", "TARGET_" "objc_declare_unresolved_class_reference", "(const char *classname)", "NULL", "C Target Hook" },






{ "Declare that Objective C class @var{classname} is defined  by the current TU.", "void", "TARGET_" "objc_declare_class_definition", "(const char *classname)", "NULL", "C Target Hook" },






{ "If a target implements string objects then this hook should return @code{true} if @var{stringref} is a valid reference to such an object.", "bool", "TARGET_" "string_object_ref_type_p", "(const_tree stringref)", "hook_bool_const_tree_false", "C Target Hook" },






{ "If a target implements string objects then this hook should should  provide a facility to check the function arguments in @var{args_list}  against the format specifiers in @var{format_arg} where the type of  @var{format_arg} is one recognized as a valid string reference type.", "void", "TARGET_" "check_string_object_format_arg", "(tree format_arg, tree args_list)", "NULL", "C Target Hook" },
# 91 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ "Define this hook to return the name of a header file to be included at the start of all compilations, as if it had been included with @code{#include <@var{file}>}.  If this hook returns @code{NULL}, or is not defined, or the header is not found, or if the user specifies @option{-ffreestanding} or @option{-nostdinc}, no header is included.\n\n This hook can be used together with a header provided by the system C library to implement ISO C requirements for certain macros to be predefined that describe properties of the whole implementation rather than just the compiler.", "const char *", "TARGET_" "c_preinclude", "(void)", "hook_constcharptr_void_null", "C Target Hook" },
# 106 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ "Define this hook to add target-specific C++ implicit extern C functions. If this function returns true for the name of a file-scope function, that function implicitly gets extern \"C\" linkage rather than whatever language linkage the declaration would normally have.  An example of such function is WinMain on Win32 targets.", "bool", "TARGET_" "cxx_implicit_extern_c", "(const char*)", "NULL", "C Target Hook" },
# 116 "/home/giulianob/gcc_git_gnu/gcc/gcc/c-family/c-target.def"
{ 0, 0, "", 0, 0, "C Target Hook" },
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/common/common-target.def" 1
# 20 "/home/giulianob/gcc_git_gnu/gcc/gcc/common/common-target.def"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-hooks-macros.h" 1
# 21 "/home/giulianob/gcc_git_gnu/gcc/gcc/common/common-target.def" 2




{ 0, 0, "TARGETM_COMMON_INITIALIZER", 0, 0, "Common Target Hook" },






{ "", "bool", "TARGET_" "handle_option", "(struct gcc_options *opts, struct gcc_options *opts_set, const struct cl_decoded_option *decoded, location_t loc)", "default_target_handle_option", "Common Target Hook" },







{ "Set target-dependent initial values of fields in @var{opts}.", "void", "TARGET_" "option_init_struct", "(struct gcc_options *opts)", "hook_void_gcc_optionsp", "Common Target Hook" },






{ "", "const struct default_options *", "TARGET_" "option_optimization_table", 0, "empty_optimization_table", "Common Target Hook" },





{ "", "int", "TARGET_" "default_target_flags", 0, "0", "Common Target Hook" },





{ "", "enum unwind_info_type", "TARGET_" "except_unwind_info", "(struct gcc_options *opts)", "default_except_unwind_info", "Common Target Hook" },





{ "Whether this target supports splitting the stack when the options described in @var{opts} have been passed.  This is called after options have been parsed, so the target may reject splitting the stack in some configurations.  The default version of this hook returns false.  If @var{report} is true, this function may issue a warning or error; if @var{report} is false, it must simply return a value", "bool", "TARGET_" "supports_split_stack", "(bool report, struct gcc_options *opts)", "hook_bool_bool_gcc_optionsp_false", "Common Target Hook" },
# 76 "/home/giulianob/gcc_git_gnu/gcc/gcc/common/common-target.def"
{ "The hook is used for options that have a non-trivial list of possible option values.  OPTION_CODE is option code of opt_code enum type.  PREFIX is used for bash completion and allows an implementation to return more specific completion based on the prefix.  All string values should be allocated from heap memory and consumers should release them.  The result will be pruned to cases with PREFIX if not NULL.", "vec<const char *>", "TARGET_" "get_valid_option_values", "(int option_code, const char *prefix)", "default_get_valid_option_values", "Common Target Hook" },
# 90 "/home/giulianob/gcc_git_gnu/gcc/gcc/common/common-target.def"
{ "", "bool", "TARGET_" "unwind_tables_default", 0, "false", "Common Target Hook" },





{ "", "bool", "TARGET_" "have_named_sections", 0, "true", "Common Target Hook" },




{ "True if @file{..} components should always be removed from directory names computed relative to GCC's internal directories, false (default) if such components should be preserved and directory names containing them passed to other tools such as the linker.", "bool", "TARGET_" "always_strip_dotdot", 0, "false", "Common Target Hook" },







{ 0, 0, "", 0, 0, "Common Target Hook" },
# 37 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/d/d-target.def" 1
# 21 "/home/giulianob/gcc_git_gnu/gcc/gcc/d/d-target.def"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/target-hooks-macros.h" 1
# 22 "/home/giulianob/gcc_git_gnu/gcc/gcc/d/d-target.def" 2




{ 0, 0, "TARGETDM_INITIALIZER", 0, 0, "D Target Hook" },





{ "Declare all environmental version identifiers relating to the target CPU\nusing the function @code{builtin_version}, which takes a string representing\nthe name of the version.  Version identifiers predefined by this hook apply\nto all modules that are being compiled and imported.", "void", "TARGET_" "d_cpu_versions", "(void)", "hook_void_void", "D Target Hook" },
# 42 "/home/giulianob/gcc_git_gnu/gcc/gcc/d/d-target.def"
{ "Similarly to @code{TARGET_D_CPU_VERSIONS}, but is used for versions\nrelating to the target operating system.", "void", "TARGET_" "d_os_versions", "(void)", "hook_void_void", "D Target Hook" },







{ "Returns the size of the data structure used by the target operating system\nfor critical sections and monitors.  For example, on Microsoft Windows this\nwould return the @code{sizeof(CRITICAL_SECTION)}, while other platforms that\nimplement pthreads would return @code{sizeof(pthread_mutex_t)}.", "unsigned", "TARGET_" "d_critsec_size", "(void)", "hook_uint_void_0", "D Target Hook" },
# 60 "/home/giulianob/gcc_git_gnu/gcc/gcc/d/d-target.def"
{ 0, 0, "", 0, 0, "D Target Hook" },
# 38 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 2

};




static void
emit_findices (const char *doc, const char *hook_name)
{
  const char *end = strstr (doc, "\n\n");
  const char *fcode;

  while ((fcode = strstr (doc, "@Fcode{")) && (!end || fcode < end))
    {
      fcode += strlen ("@Fcode{");
      doc = strchr (fcode, '}');
      if (!doc)
 fatal ("Malformed @Fcode for hook %s\n", hook_name);
      printf ("@findex %.*s\n", (int) (doc - fcode), fcode);
      doc = fcode;
    }
}


static char *
upstrdup (const char *in)
{
  char *p, *ret = xstrdup (in);
  for (p = ret; *p; p++)
    *p = _sch_toupper[(*p) & 0xff];
  return ret;
}



struct s_hook
{
  char *name;
  int pos;
};

static hashval_t
s_hook_hash (const void *p)
{
  const struct s_hook *s_hook = (const struct s_hook *)p;
  return htab_hash_string (s_hook->name);
}

static int
s_hook_eq_p (const void *p1, const void *p2)
{
  return (strcmp (((const struct s_hook *) p1)->name,
    ((const struct s_hook *) p2)->name) == 0);
}
# 116 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
static void
emit_documentation (const char *in_fname)
{
  int i, j;
  char buf[1000];
  htab_t start_hooks = htab_create (99, s_hook_hash, s_hook_eq_p, (htab_del) 0);
  FILE *f;


  f = fopen_unlocked (in_fname, "r");
  if (!f)
    {
      perror ("");
      fatal ("Couldn't open input file");
    }
  while (fscanf (f, "%*[^@]"), buf[0] = '\0',
  fscanf (f, "@%5[^ \n]", buf) != 
# 132 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 3 4
                                 (-1)
# 132 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
                                    )
    {
      void **p;
      struct s_hook *shp;

      if (strcmp (buf, "hook") != 0)
 continue;
      buf[0] = '\0';
      fscanf (f, "%999s", buf);
      shp = ((struct s_hook *) xmalloc (sizeof (struct s_hook)));
      shp->name = upstrdup (buf);
      shp->pos = -1;
      p = htab_find_slot (start_hooks, shp, INSERT);
      if (*p != ((void *) 0))
 fatal ("Duplicate placement for hook %s\n", shp->name);
      *(struct s_hook **) p = shp;
    }
  fclose (f);

  for (i = 0; i < (int) (sizeof hook_array / sizeof hook_array[0]); i++)
    {
      struct s_hook sh, *shp;
      void *p;

      if (!hook_array[i].doc || strcmp (hook_array[i].doc, "*") == 0)
 continue;
      sh.name = upstrdup (hook_array[i].name);
      p = htab_find (start_hooks, &sh);
      if (p)
 {
   shp = (struct s_hook *) p;
   if (shp->pos >= 0)
     fatal ("Duplicate hook %s\n", sh.name);
   shp->pos = i;
 }
      else
 fatal ("No place specified to document hook %s\n", sh.name);
      free (sh.name);
    }


  f = fopen_unlocked (in_fname, "r");
  if (!f)
    {
      perror ("");
      fatal ("Couldn't open input file");
    }
  for (;;)
    {
      struct s_hook sh, *shp;
      int c = getc_unlocked (f);
      char *name;

      if (c == 
# 185 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c" 3 4
              (-1)
# 185 "/home/giulianob/gcc_git_gnu/gcc/gcc/genhooks.c"
                 )
 break;
      if (c != '@')
 {
   putchar_unlocked (c);
   continue;
 }
      buf[0] = '\0';
      fscanf (f, "%5[^ \n]", buf);
      if (strcmp (buf, "hook") != 0)
 {
   printf ("@%s", buf);
   continue;
 }
      fscanf (f, "%999s", buf);
      sh.name = name = upstrdup (buf);
      shp = (struct s_hook *) htab_find (start_hooks, &sh);
      if (!shp || shp->pos < 0)
 fatal ("No documentation for hook %s\n", sh.name);
      i = shp->pos;
      do
 {
   const char *q, *e;
   const char *deftype;
   const char *doc, *fcode, *p_end;



   if (*hook_array[i].doc == '*')
     printf ("%s", hook_array[i].doc + 1);
   else
     {
       if (i != shp->pos)
  printf ("\n\n");
       emit_findices (hook_array[i].doc, name);



       deftype = hook_array[i].param ? "deftypefn" : "deftypevr";
       printf ("@%s {%s} ", deftype, hook_array[i].docname);
       if (strchr (hook_array[i].type, ' '))
  printf ("{%s}", hook_array[i].type);
       else
  printf ("%s", hook_array[i].type);
       printf (" %s", name);
       if (hook_array[i].param)
  {


    printf (" ");
    for (q = hook_array[i].param; (e = strpbrk (q, " *,)"));
         q = e + 1)


      if (*e == ' ' || *e == '*' || *q == '(')
        printf ("%.*s", (int) (e - q + 1), q);
      else
        printf ("@var{%.*s}%c", (int) (e - q), q, *e);
  }


       for (j = i + 1;
     j < (int) (sizeof hook_array / sizeof hook_array[0])
     && hook_array[j].doc == 0 && hook_array[j].type; j++)
  {
    char *namex = upstrdup (hook_array[j].name);

    printf ("\n@%sx {%s} {%s} %s",
     deftype, hook_array[j].docname,
     hook_array[j].type, namex);
  }
       if (hook_array[i].doc[0])
  {
    printf ("\n");

    for (doc = hook_array[i].doc; *doc; doc = p_end)
      {

        p_end = strstr (doc, "\n\n");
        p_end = (p_end ? p_end + 2 : doc + strlen (doc));

        for (; (fcode = strstr (doc, "@Fcode{")) && fcode < p_end;
      doc = fcode + 2)
   printf ("%.*s@", (int) (fcode - doc), doc);
        printf ("%.*s", (int) (p_end - doc), doc);

        emit_findices (p_end, name);
      }
    printf ("\n@end %s", deftype);
  }
     }
   if (++i >= (int) (sizeof hook_array / sizeof hook_array[0])
       || !hook_array[i].doc)
     break;
   free (name);
   sh.name = name = upstrdup (hook_array[i].name);
 }
      while (!htab_find (start_hooks, &sh));
      free (name);
    }
}





static void
emit_init_macros (const char *docname)
{
  int i;
  const int MAX_NEST = 2;
  int print_nest, nest = 0;

  for (print_nest = 0; print_nest <= MAX_NEST; print_nest++)
    {
      for (i = 0; i < (int) (sizeof hook_array / sizeof hook_array[0]); i++)
 {
   char *name = upstrdup (hook_array[i].name);

   if (strcmp (hook_array[i].docname, docname) != 0)
     continue;

   if (!hook_array[i].type)
     {
       if (*name)
  {
    if (nest && nest == print_nest)
      printf ("    %s, \\\n", name);
    nest++;
    if (nest > MAX_NEST)
      fatal ("Unexpected nesting of %s\n", name);
    if (nest == print_nest)
      printf ("\n#define %s \\\n  { \\\n", name);
  }
       else
  {
    if (nest == print_nest)
      printf ("  }\n");
    nest--;
  }
       continue;
     }
   if (print_nest == 0)
     {

       printf ("#ifndef %s\n#define %s %s\n#endif\n",
        name, name, hook_array[i].init);
     }
   if (nest == print_nest)
     printf ("    %s, \\\n", name);
 }
    }
}

int
main (int argc, char **argv)
{
  progname = "genhooks";

  if (argc >= 3)
    emit_documentation (argv[2]);
  else
    emit_init_macros (argv[1]);
  return 0;
}
