# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
# 1 "/home/giulianob/gcc_git_gnu/build_temp/gcc//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
# 21 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
# 1 "./config.h" 1





# 1 "./auto-host.h" 1
# 7 "./config.h" 2

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h" 1
# 40 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h"
extern "C" {
# 433 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h"
}
# 9 "./config.h" 2
# 22 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2




# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 1
# 32 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4

# 40 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 33 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 43 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 44 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) throw ();







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) throw () __asm__ ("" "__isoc99_sscanf")

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4
# 873 "/usr/include/stdio.h" 3 4
}
# 47 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 103 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"

# 103 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 187 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}
# 209 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h" 1
# 57 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 174 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int isalnum (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalnum; }
extern __inline __attribute__ ((__gnu_inline__)) int isalpha (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISalpha; }
extern __inline __attribute__ ((__gnu_inline__)) int iscntrl (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _IScntrl; }
extern __inline __attribute__ ((__gnu_inline__)) int isdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISdigit; }
extern __inline __attribute__ ((__gnu_inline__)) int islower (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISlower; }
extern __inline __attribute__ ((__gnu_inline__)) int isgraph (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISgraph; }
extern __inline __attribute__ ((__gnu_inline__)) int isprint (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISprint; }
extern __inline __attribute__ ((__gnu_inline__)) int ispunct (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISpunct; }
extern __inline __attribute__ ((__gnu_inline__)) int isspace (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISspace; }
extern __inline __attribute__ ((__gnu_inline__)) int isupper (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISupper; }
extern __inline __attribute__ ((__gnu_inline__)) int isxdigit (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISxdigit; }

extern __inline __attribute__ ((__gnu_inline__)) int isblank (int __c) throw () { return (*__ctype_b_loc ())[(int) (__c)] & (unsigned short int) _ISblank; }
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) tolower (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) toupper (int __c) throw ()
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 237 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 238 "/usr/include/ctype.h" 2 3 4
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 123 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/safe-ctype.h" 2
# 210 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 214 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 235 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/c++/10/cstring" 1 3
# 39 "/usr/include/c++/10/cstring" 3
       
# 40 "/usr/include/c++/10/cstring" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 1 3
# 262 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 284 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 522 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/os_defines.h" 1 3
# 523 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/10/bits/cpu_defines.h" 1 3
# 526 "/usr/include/x86_64-linux-gnu/c++/10/bits/c++config.h" 2 3
# 42 "/usr/include/c++/10/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}
# 99 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 204 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}
# 261 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 369 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4
}
# 43 "/usr/include/c++/10/cstring" 2 3
# 71 "/usr/include/c++/10/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/include/c++/10/cstring" 3

}
}
# 236 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/c++/10/new" 1 3
# 38 "/usr/include/c++/10/new" 3
       
# 39 "/usr/include/c++/10/new" 3


# 1 "/usr/include/c++/10/exception" 1 3
# 33 "/usr/include/c++/10/exception" 3
       
# 34 "/usr/include/c++/10/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception.h" 1 3
# 34 "/usr/include/c++/10/bits/exception.h" 3
       
# 35 "/usr/include/c++/10/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/10/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/10/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/include/c++/10/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 137 "/usr/include/c++/10/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/10/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/10/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/10/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/typeinfo" 1 3
# 32 "/usr/include/c++/10/typeinfo" 3
       
# 33 "/usr/include/c++/10/typeinfo" 3



# 1 "/usr/include/c++/10/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/10/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/10/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/10/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/10/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/10/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/usr/include/c++/10/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10/new" 1 3
# 41 "/usr/include/c++/10/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 118 "/usr/include/c++/10/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 145 "/usr/include/c++/10/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
# 213 "/usr/include/c++/10/bits/exception_ptr.h" 3
      return exception_ptr();

    }


}

}

#pragma GCC visibility pop
# 148 "/usr/include/c++/10/exception" 2 3
# 1 "/usr/include/c++/10/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/10/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/10/bits/move.h" 1 3
# 38 "/usr/include/c++/10/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/10/type_traits" 1 3
# 32 "/usr/include/c++/10/type_traits" 3
       
# 33 "/usr/include/c++/10/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/10/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 188 "/usr/include/c++/10/type_traits" 3
  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 284 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 364 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 604 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 623 "/usr/include/c++/10/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 770 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };
# 1001 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1410 "/usr/include/c++/10/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1508 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1730 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1806 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1884 "/usr/include/c++/10/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1932 "/usr/include/c++/10/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2067 "/usr/include/c++/10/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2106 "/usr/include/c++/10/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2239 "/usr/include/c++/10/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2624 "/usr/include/c++/10/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop
# 3455 "/usr/include/c++/10/type_traits" 3

}
# 58 "/usr/include/c++/10/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/include/c++/10/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/10/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/include/c++/10/exception" 2 3
# 42 "/usr/include/c++/10/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/include/c++/10/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 174 "/usr/include/c++/10/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 230 "/usr/include/c++/10/new" 3
#pragma GCC visibility pop
# 237 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/c++/10/utility" 1 3
# 58 "/usr/include/c++/10/utility" 3
       
# 59 "/usr/include/c++/10/utility" 3
# 69 "/usr/include/c++/10/utility" 3
# 1 "/usr/include/c++/10/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/10/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/10/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/10/utility" 2 3
# 1 "/usr/include/c++/10/bits/stl_pair.h" 1 3
# 69 "/usr/include/c++/10/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/10/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/10/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/10/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };
# 464 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/usr/include/c++/10/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/10/bits/stl_pair.h" 3

}
# 71 "/usr/include/c++/10/utility" 2 3





# 1 "/usr/include/c++/10/initializer_list" 1 3
# 33 "/usr/include/c++/10/initializer_list" 3
       
# 34 "/usr/include/c++/10/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/usr/include/c++/10/utility" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/include/c++/10/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 473 "/usr/include/c++/10/utility" 3

}
# 238 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 259 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/c++/10/stdlib.h" 1 3
# 36 "/usr/include/c++/10/stdlib.h" 3
# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 75 "/usr/include/c++/10/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 610 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/10/cstdlib" 2 3

# 1 "/usr/include/c++/10/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/10/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/10/bits/std_abs.h" 3
# 46 "/usr/include/c++/10/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/usr/include/c++/10/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/10/cstdlib" 2 3
# 121 "/usr/include/c++/10/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/10/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/10/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/10/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 260 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2







# 1 "/usr/include/c++/10/cstdlib" 1 3
# 39 "/usr/include/c++/10/cstdlib" 3
       
# 40 "/usr/include/c++/10/cstdlib" 3
# 268 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 295 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) throw ();
# 1171 "/usr/include/unistd.h" 2 3 4

}
# 296 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 196 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/10/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4
extern "C" {


# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 210 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();



extern int raise (int __sig) throw ();



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 170 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 185 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     throw ();
# 286 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[(64 + 1)];
extern const char *const sys_siglist[(64 + 1)];



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 292 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) throw ();




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 328 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));






extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();





# 1 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 375 "/usr/include/signal.h" 2 3 4

}
# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 300 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2






# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h" 1 3 4
# 307 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 337 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 66 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) throw () __attribute__ ((__nonnull__ (1)));







extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 187 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 338 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 339 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 350 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern "C" {




extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) throw ();





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) throw ();
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) throw ();
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4
}
# 351 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 397 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/wait.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern "C" {
# 77 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern __pid_t wait (int *__stat_loc);
# 100 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);
# 121 "/usr/include/x86_64-linux-gnu/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);






struct rusage;






extern __pid_t wait3 (int *__stat_loc, int __options,
        struct rusage * __usage) throw ();




extern __pid_t wait4 (__pid_t __pid, int *__stat_loc, int __options,
        struct rusage *__usage) throw ();



}
# 398 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 428 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-map-flags-generic.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 113 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 3 4
extern "C" {



int memfd_create (const char *__name, unsigned int __flags) throw ();



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) throw ();





int pkey_alloc (unsigned int __flags, unsigned int __access_rights) throw ();



int pkey_set (int __key, unsigned int __access_rights) throw ();



int pkey_get (int __key) throw ();



int pkey_free (int __key) throw ();



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) throw ();

}
# 114 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 2 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4




extern "C" {
# 57 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
# 70 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (const void *__addr, size_t __len) throw ();


extern int munlock (const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
# 133 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);

}
# 429 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 440 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/resource.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/resource.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 3 4
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };


    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/usr/include/x86_64-linux-gnu/bits/resource.h" 2 3 4







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};


extern "C" {




extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) throw ();
# 217 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) throw ();



}
# 25 "/usr/include/x86_64-linux-gnu/sys/resource.h" 2 3 4






extern "C" {
# 42 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
typedef int __rlimit_resource_t;
typedef int __rusage_who_t;
typedef int __priority_which_t;





extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) throw ();
# 61 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) throw ();






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) throw ();
# 81 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) throw ();




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) throw ();





extern int getpriority (__priority_which_t __which, id_t __who) throw ();



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     throw ();

}
# 441 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/times.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/times.h" 3 4
extern "C" {


struct tms
  {
    clock_t tms_utime;
    clock_t tms_stime;

    clock_t tms_cutime;
    clock_t tms_cstime;
  };






extern clock_t times (struct tms *__buffer) throw ();

}
# 445 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 453 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"

# 453 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 521 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4

# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stdint.h" 2 3 4
# 526 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2



# 1 "/usr/include/inttypes.h" 1 3 4
# 266 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__leaf__)) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__leaf__)) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base) throw ()

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const wchar_t * __restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__leaf__)) wcstoimax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const wchar_t *
          __restrict __nptr,
          wchar_t **
          __restrict __endptr,
          int __base, int __group)
  throw () __attribute__ ((__nonnull__ (1))) ;

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__leaf__)) wcstoumax (const wchar_t *__restrict nptr, wchar_t **__restrict endptr, int base) throw ()

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 432 "/usr/include/inttypes.h" 3 4
}
# 530 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2




# 533 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern "C" {
# 576 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
}
# 599 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
extern "C" {


int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  throw () __attribute__ ((__nonnull__ (2, 5)));

}
# 40 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat (const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat (const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}






}
# 600 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 671 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h" 1
# 29 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h" 1
# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"

# 36 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"
extern "C" {


# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/ansidecl.h" 1
# 40 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h" 2


typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, const void *);
extern void htab_remove_elt_with_hash (htab_t, const void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);




}
# 30 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h" 2


extern "C" {
# 84 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);


}
# 672 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 683 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4

# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4
extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();

}
# 28 "/usr/include/dlfcn.h" 2 3 4
# 44 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;







extern "C" {



extern void *dlopen (const char *__file, int __mode) throw ();



extern int dlclose (void *__handle) throw () __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) throw () __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) throw ();



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) throw ();





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     throw () __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) throw () __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     throw () __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;





  __extension__ union
  {
    Dl_serpath dls_serpath[0];
    Dl_serpath __dls_serpath_pad[1];
  };



} Dl_serinfo;



}
# 684 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 692 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h" 1
# 39 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"

# 39 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern "C" {





# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 46 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h" 2
# 55 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 123 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);



extern int is_valid_fd (int fd);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 157 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 193 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 205 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char * getpwd (void);
# 218 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));




extern char *make_temp_file_with_prefix (const char *, const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 292 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1))) __attribute__ ((warn_unused_result));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (2))) __attribute__ ((warn_unused_result));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1, 2))) __attribute__ ((warn_unused_result));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 391 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 428 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 528 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 543 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 618 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 637 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);



extern void *bsearch_r (const void *, const void *,
   size_t, size_t,
   int (*)(const void *, const void *, void *),
   void *);
# 661 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
# 673 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 722 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 735 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 762 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/libiberty.h"
}
# 693 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2
# 763 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
extern void fancy_abort (const char *, int, const char *)
      __attribute__ ((__noreturn__)) __attribute__ ((__cold__));
# 894 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        




        






        




        


        
# 963 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        






        
# 1055 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        
# 1073 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        


        



        
# 1091 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        
# 1107 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
        



       
# 1224 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h" 1
# 77 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
typedef long __gcc_host_wide_int__;
# 141 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
static inline unsigned long
least_bit_hwi (unsigned long x)
{
  return (x & -x);
}



static inline bool
pow2_or_zerop (unsigned long x)
{
  return least_bit_hwi (x) == x;
}



static inline bool
pow2p_hwi (unsigned long x)
{
  return x && pow2_or_zerop (x);
}
# 184 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
static inline int
clz_hwi (unsigned long x)
{
  if (x == 0)
    return 64;

  return __builtin_clzl (x);





}

static inline int
ctz_hwi (unsigned long x)
{
  if (x == 0)
    return 64;

  return __builtin_ctzl (x);





}

static inline int
ffs_hwi (unsigned long x)
{

  return __builtin_ffsl (x);





}

static inline int
popcount_hwi (unsigned long x)
{

  return __builtin_popcountl (x);





}

static inline int
floor_log2 (unsigned long x)
{
  return 64 - 1 - clz_hwi (x);
}

static inline int
ceil_log2 (unsigned long x)
{
  return x == 0 ? 0 : floor_log2 (x - 1) + 1;
}

static inline int
exact_log2 (unsigned long x)
{
  return pow2p_hwi (x) ? ctz_hwi (x) : -1;
}







extern long abs_hwi (long);
extern unsigned long absu_hwi (long);
extern long gcd (long, long);
extern long pos_mul_hwi (long, long);
extern long mul_hwi (long, long);
extern long least_common_multiple (long, long);



static inline int
ctz_or_zero (unsigned long x)
{
  return ffs_hwi (x) - 1;
}



static inline long
sext_hwi (long src, unsigned int prec)
{
  if (prec == 64)
    return src;
  else

    {






      ((void)(!(prec < 64) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 291, __FUNCTION__), 0 : 0));
      int shift = 64 - prec;
      return ((long) ((unsigned long) src << shift)) >> shift;
    }
# 304 "/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h"
}


static inline unsigned long
zext_hwi (unsigned long src, unsigned int prec)
{
  if (prec == 64)
    return src;
  else
    {
      ((void)(!(prec < 64) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 314, __FUNCTION__), 0 : 0));
      return src & ((1UL << prec) - 1);
    }
}



inline long
abs_hwi (long x)
{
  ((void)(!(x != (long) (1UL << (64 - 1))) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/hwint.h", 324, __FUNCTION__), 0 : 0));
  return x >= 0 ? x : -x;
}



inline unsigned long
absu_hwi (long x)
{
  return x >= 0 ? (unsigned long)x : -(unsigned long)x;
}
# 1225 "/home/giulianob/gcc_git_gnu/gcc/gcc/system.h" 2

typedef int sort_r_cmp_fn (const void *, const void *, void *);
void qsort_chk (void *, size_t, size_t, sort_r_cmp_fn *, void *);
void gcc_sort_r (void *, size_t, size_t, sort_r_cmp_fn *, void *);
void gcc_qsort (void *, size_t, size_t, int (*)(const void *, const void *));
void gcc_stablesort (void *, size_t, size_t,
       int (*)(const void *, const void *));
# 27 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/errors.h" 1
# 31 "/home/giulianob/gcc_git_gnu/gcc/gcc/errors.h"
extern void warning (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void error (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void fatal (const char *, ...) __attribute__ ((__noreturn__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern void internal_error (const char *, ...) __attribute__ ((__noreturn__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__cold__));
extern const char *trim_filename (const char *);

extern int have_error;
extern const char *progname;
# 28 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h" 1
# 26 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
extern "C" {
# 35 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
extern char *optarg;
# 49 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
extern int optind;




extern int opterr;



extern int optopt;
# 81 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
struct option
{

  const char *name;





  int has_arg;
  int *flag;
  int val;
};
# 120 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
          const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind);


extern int _getopt_internal (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind,
        int long_only);
# 140 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/getopt.h"
}
# 29 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/version.h" 1


extern const char version_string[];
extern const char pkgversion_string[];
extern const char bug_report_url[];
# 30 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex.h" 1
# 27 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex.h"
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h" 1
# 29 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
extern "C" {
# 45 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
typedef long int s_reg_t;
typedef unsigned long int active_reg_t;






typedef unsigned long int reg_syntax_t;
# 173 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
extern reg_syntax_t xre_syntax_options;
# 290 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
typedef enum
{

  REG_ENOSYS = -1,


  REG_NOERROR = 0,
  REG_NOMATCH,



  REG_BADPAT,
  REG_ECOLLATE,
  REG_ECTYPE,
  REG_EESCAPE,
  REG_ESUBREG,
  REG_EBRACK,
  REG_EPAREN,
  REG_EBRACE,
  REG_BADBR,
  REG_ERANGE,
  REG_ESPACE,
  REG_BADRPT,


  REG_EEND,
  REG_ESIZE,
  REG_ERPAREN
} reg_errcode_t;
# 330 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
struct re_pattern_buffer
{




  unsigned char *buffer;


  unsigned long int allocated;


  unsigned long int used;


  reg_syntax_t syntax;




  char *fastmap;





  char * translate;


  size_t re_nsub;






  unsigned can_be_null : 1;
# 375 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;


};

typedef struct re_pattern_buffer regex_t;


typedef int xregoff_t;




struct re_registers
{
  unsigned num_regs;
  xregoff_t *start;
  xregoff_t *end;
};
# 425 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
typedef struct
{
  xregoff_t rm_so;
  xregoff_t rm_eo;
} regmatch_t;
# 441 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
extern reg_syntax_t xre_set_syntax (reg_syntax_t syntax);




extern const char *xre_compile_pattern (const char *pattern, size_t length,
                                       struct re_pattern_buffer *buffer);





extern int xre_compile_fastmap (struct re_pattern_buffer *buffer);







extern int xre_search (struct re_pattern_buffer *buffer, const char *string,
                      int length, int start, int range,
                      struct re_registers *regs);




extern int xre_search_2 (struct re_pattern_buffer *buffer, const char *string1,
                        int length1, const char *string2, int length2,
                        int start, int range, struct re_registers *regs,
                        int stop);




extern int xre_match (struct re_pattern_buffer *buffer, const char *string,
                     int length, int start, struct re_registers *regs);



extern int xre_match_2 (struct re_pattern_buffer *buffer, const char *string1,
                       int length1, const char *string2, int length2,
                       int start, struct re_registers *regs, int stop);
# 498 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
extern void xre_set_registers (struct re_pattern_buffer *buffer,
                              struct re_registers *regs,
                              unsigned num_regs, xregoff_t *starts,
                              xregoff_t *ends);




extern char *xre_comp (const char *);
extern int xre_exec (const char *);
# 534 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex2.h"
extern int xregcomp (regex_t *__restrict __preg,
                    const char *__restrict __pattern,
                    int __cflags);


__extension__

extern int xregexec (const regex_t *__restrict __preg,
                    const char *__restrict __string, size_t __nmatch,
                    regmatch_t __pmatch[],
                    int __eflags);

extern size_t xregerror (int __errcode, const regex_t *__preg,
                        char *__errbuf, size_t __errbuf_size);

extern void xregfree (regex_t *__preg);



}
# 28 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/xregex.h" 2
# 31 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h" 1
# 111 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/10/include/stddef.h" 1 3 4
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h" 2
# 153 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h"
extern "C" {


struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};

struct obstack
{
  size_t chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  union
  {
    size_t i;
    void *p;
  } temp;
  size_t alignment_mask;


  union
  {
    void *(*plain) (size_t);
    void *(*extra) (void *, size_t);
  } chunkfun;
  union
  {
    void (*plain) (void *);
    void (*extra) (void *, void *);
  } freefun;

  void *extra_arg;
  unsigned use_extra_arg : 1;
  unsigned maybe_empty_object : 1;



  unsigned alloc_failed : 1;


};



extern void _obstack_newchunk (struct obstack *, size_t);
extern void _obstack_free (struct obstack *, void *);
extern int _obstack_begin (struct obstack *,
                           size_t, size_t,
                           void *(*) (size_t), void (*) (void *));
extern int _obstack_begin_1 (struct obstack *,
                             size_t, size_t,
                             void *(*) (void *, size_t),
                             void (*) (void *, void *), void *);
extern size_t _obstack_memory_used (struct obstack *)
  
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h" 3 4
 __attribute__ ((__pure__))
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h"
                   ;






extern void (*obstack_alloc_failed_handler) (void);


extern int obstack_exit_failure;
# 532 "/home/giulianob/gcc_git_gnu/gcc/gcc/../include/obstack.h"
}
# 32 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2
# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h" 1
# 29 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h"
typedef unsigned lang_bitmap;




struct input_file_st
{
  struct outf* inpoutf;

  lang_bitmap inpbitmap;
  bool inpisplugin;
  char inpname[1];

};
typedef struct input_file_st input_file;



struct fileloc
{
  const input_file *file;
  int line;
};



extern const input_file** gt_files;
extern size_t num_gt_files;





extern input_file* this_file;
extern input_file* system_h_file;




input_file* input_file_by_name (const char* name);



const char *get_file_srcdir_relative_path (const input_file *inpf);


static inline const char*
get_input_file_name (const input_file *inpf)
{
  if (inpf)
      return inpf->inpname;
  return nullptr;
}
# 92 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h"
static inline lang_bitmap
get_lang_bitmap (const input_file* inpf)
{
  if (inpf == nullptr)
    return 0;
  return inpf->inpbitmap;
}



static inline void
set_lang_bitmap (input_file* inpf, lang_bitmap n)
{
  ((void)(!(inpf) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h", 105, __FUNCTION__), 0 : 0));
  inpf->inpbitmap = n;
}


extern const char **lang_dir_names;
extern size_t num_lang_dirs;


typedef struct pair *pair_p;
typedef struct type *type_p;
typedef const struct type *const_type_p;
typedef struct options *options_p;


extern int lexer_toplevel_done;
extern struct fileloc lexer_line;



extern pair_p typedefs;
extern type_p structures;
extern pair_p variables;



enum write_types_kinds
{
  WTK_GGC,
  WTK_PCH,

  NUM_WTK
};



enum typekind {
  TYPE_NONE=0,
  TYPE_UNDEFINED,


  TYPE_SCALAR,
  TYPE_STRING,
  TYPE_STRUCT,
  TYPE_UNION,
  TYPE_POINTER,
  TYPE_ARRAY,
  TYPE_LANG_STRUCT,


  TYPE_USER_STRUCT


};


enum option_kind {
  OPTION_NONE=0,
  OPTION_STRING,

  OPTION_TYPE,
  OPTION_NESTED
};



struct options {
  struct options *next;
  const char *name;
  enum option_kind kind;
  union {
    const char* string;
    type_p type;
    struct nested_ptr_data* nested;
  } info;
};



struct nested_ptr_data {
  type_p type;
  const char *convert_to;
  const char *convert_from;
};





options_p create_string_option (options_p next, const char* name,
                                const char* info);


options_p create_type_option (options_p next, const char* name,
                              type_p info);


options_p create_nested_option (options_p next, const char* name,
    struct nested_ptr_data* info);


options_p create_nested_ptr_option (options_p next, type_p t,
        const char *to, const char *from);


struct pair {
  pair_p next;
  const char *name;
  type_p type;
  struct fileloc line;
  options_p opt;
};





enum gc_used_enum {


  GC_UNUSED=0,



  GC_USED,






  GC_MAYBE_POINTED_TO,



  GC_POINTED_TO
};


struct type {

  enum typekind kind;






  type_p next;





  int state_number;




  type_p pointer_to;



  enum gc_used_enum gc_used;


  union {



    type_p p;



    struct {
      const char *tag;
      struct fileloc line;
      pair_p fields;
      options_p opt;
      lang_bitmap bitmap;






      type_p lang_struct;

      type_p base_class;






      type_p first_subclass;

      type_p next_sibling_class;



      bool wrote_user_func_for_ptr[NUM_WTK];
    } s;


    bool scalar_is_char;


    struct {
      type_p p;
      const char *len;
    } a;

  } u;
};


extern struct type string_type;



extern struct type scalar_nonchar;
extern struct type scalar_char;
# 338 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h"
static inline bool
union_or_struct_p (enum typekind kind)
{
  return (kind == TYPE_UNION
   || kind == TYPE_STRUCT
          || kind == TYPE_LANG_STRUCT
   || kind == TYPE_USER_STRUCT);
}

static inline bool
union_or_struct_p (const_type_p x)
{
  return union_or_struct_p (x->kind);
}


static inline struct fileloc*
type_fileloc (type_p t)
{
  if (!t)
    return nullptr;
  if (union_or_struct_p (t))
    return &t->u.s.line;
  return nullptr;
}


struct outf
{
  struct outf *next;
  const char *name;
  size_t buflength;
  size_t bufused;
  char *buf;
};
typedef struct outf *outf_p;


extern outf_p output_files;



extern outf_p header_file;


void
oprintf (outf_p o, const char *S, ...)
  __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__nonnull__ (2)));






outf_p get_output_file_with_visibility (input_file* inpf);




const char *get_output_file_name (input_file *inpf);



extern const char *srcdir;


extern size_t srcdir_len;


extern const char *read_state_filename;
extern const char *write_state_filename;



void read_state (const char* path);

void write_state (const char* path);



extern void error_at_line
(const struct fileloc *pos, const char *msg, ...) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__nonnull__ (2)));


extern void do_typedef (const char *s, type_p t, struct fileloc *pos);
extern void do_scalar_typedef (const char *s, struct fileloc *pos);
extern type_p resolve_typedef (const char *s, struct fileloc *pos);
extern void add_subclass (type_p base, type_p subclass);
extern type_p new_structure (const char *name, enum typekind kind,
        struct fileloc *pos, pair_p fields,
        options_p o, type_p base);
type_p create_user_defined_type (const char *, struct fileloc *);
extern type_p find_structure (const char *s, enum typekind kind);
extern type_p create_scalar_type (const char *name);
extern type_p create_pointer (type_p t);
extern type_p create_array (type_p t, const char *len);
extern pair_p create_field_at (pair_p next, type_p type,
          const char *name, options_p opt,
          struct fileloc *pos);
extern pair_p nreverse_pairs (pair_p list);
extern type_p adjust_field_type (type_p, options_p);
extern void note_variable (const char *s, type_p t, options_p o,
      struct fileloc *pos);


extern int yylex (const char **yylval);
extern void yybegin (const char *fname);
extern void yyend (void);
extern void parse_file (const char *name);
extern bool hit_error;


enum gty_token
{
  EOF_TOKEN = 0,



  CHAR_TOKEN_OFFSET = 
# 456 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h" 3 4
                     (0x7f * 2 + 1) 
# 456 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.h"
                               + 1,
  GTY_TOKEN = CHAR_TOKEN_OFFSET,
  TYPEDEF,
  EXTERN,
  STATIC,
  UNION,
  STRUCT,
  ENUM,
  ELLIPSIS,
  PTR_ALIAS,
  NESTED_PTR,
  USER_GTY,
  NUM,
  SCALAR,
  ID,
  STRING,
  CHAR,
  ARRAY,
  IGNORABLE_CXX_KEYWORD,



  FIRST_TOKEN_WITH_VALUE = USER_GTY
};



extern int verbosity_level;





extern int do_dump;



extern int do_debug;




void dbgprint_count_type_at (const char *, int, const char *, type_p);







extern bool
opts_have (options_p opts, const char *str);
# 33 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2






outf_p output_files;



outf_p header_file;



static char *inputlist;



static input_file **plugin_files;
static size_t nb_plugin_files;


static outf_p plugin_output;
static char *plugin_output_filename;


const char *srcdir;
size_t srcdir_len;


const char *read_state_filename;
const char *write_state_filename;


int do_dump;
int do_debug;


int verbosity_level;



static int type_count;




static const char* backup_dir;


static outf_p create_file (const char *, const char *);

static const char *get_file_basename (const input_file *);
static const char *get_file_realbasename (const input_file *);

static int get_prefix_langdir_index (const char *);
static const char *get_file_langdir (const input_file *);

static void dump_pair (int indent, pair_p p);
static void dump_type (int indent, type_p p);
static void dump_type_list (int indent, type_p p);



bool hit_error = false;

static void gen_rtx_next (void);
static void write_rtx_next (void);
static void open_base_files (void);
static void close_output_files (void);



void
error_at_line (const struct fileloc *pos, const char *msg, ...)
{
  va_list ap;

  ((void)(!(pos != nullptr && pos->file != nullptr) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 111, __FUNCTION__), 0 : 0));
  
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 __builtin_va_start(
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 ap
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 ,
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 msg
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 )
# 112 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                   ;

  fprintf (
# 114 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
          stderr
# 114 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                , "%s:%d: ", get_input_file_name (pos->file), pos->line);
  vfprintf (
# 115 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
           stderr
# 115 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                 , msg, ap);
  fputc_unlocked ('\n', 
# 116 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 116 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 );
  hit_error = true;

  
# 119 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 __builtin_va_end(
# 119 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 ap
# 119 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 )
# 119 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
            ;
}



static const_type_p
get_ultimate_base_class (const_type_p s)
{
  while (s->u.s.base_class)
    s = s->u.s.base_class;
  return s;
}

static type_p
get_ultimate_base_class (type_p s)
{
  while (s->u.s.base_class)
    s = s->u.s.base_class;
  return s;
}




const input_file **gt_files;
size_t num_gt_files;




input_file* this_file;

input_file* system_h_file;


const char **lang_dir_names;
size_t num_lang_dirs;



static outf_p *base_files;



void
dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)
{
  int nb_types = 0, nb_scalar = 0, nb_string = 0;
  int nb_struct = 0, nb_union = 0, nb_array = 0, nb_pointer = 0;
  int nb_lang_struct = 0;
  int nb_user_struct = 0, nb_undefined = 0;
  type_p p = nullptr;
  for (p = t; p; p = p->next)
    {
      nb_types++;
      switch (p->kind)
 {
 case TYPE_UNDEFINED:
   nb_undefined++;
   break;
 case TYPE_SCALAR:
   nb_scalar++;
   break;
 case TYPE_STRING:
   nb_string++;
   break;
 case TYPE_STRUCT:
   nb_struct++;
   break;
 case TYPE_USER_STRUCT:
   nb_user_struct++;
   break;
 case TYPE_UNION:
   nb_union++;
   break;
 case TYPE_POINTER:
   nb_pointer++;
   break;
 case TYPE_ARRAY:
   nb_array++;
   break;
 case TYPE_LANG_STRUCT:
   nb_lang_struct++;
   break;
 case TYPE_NONE:
   (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 204, __FUNCTION__));
 }
    }
  fprintf (
# 207 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
          stderr
# 207 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                , "\n" "%s:%d: %s: @@%%@@ %d types ::\n",
    lbasename (fil), lin, msg, nb_types);
  if (nb_scalar > 0 || nb_string > 0)
    fprintf (
# 210 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 210 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d scalars, %d strings\n", nb_scalar, nb_string);
  if (nb_struct > 0 || nb_union > 0)
    fprintf (
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 212 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d structs, %d unions\n", nb_struct, nb_union);
  if (nb_pointer > 0 || nb_array > 0)
    fprintf (
# 214 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 214 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d pointers, %d arrays\n", nb_pointer, nb_array);
  if (nb_lang_struct > 0)
    fprintf (
# 216 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 216 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d lang_structs\n", nb_lang_struct);
  if (nb_user_struct > 0)
    fprintf (
# 218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d user_structs\n", nb_user_struct);
  if (nb_undefined > 0)
    fprintf (
# 220 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
            stderr
# 220 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  , "@@%%@@ %d undefined types\n", nb_undefined);
  fprintf (
# 221 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
          stderr
# 221 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                , "\n");
}





static size_t
measure_input_list (FILE *list)
{
  size_t n = 0;
  int c;
  bool atbol = true;
  num_lang_dirs = 0;
  num_gt_files = plugin_files ? nb_plugin_files : 0;
  while ((c = getc_unlocked (list)) != 
# 236 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                             (-1)
# 236 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                )
    {
      n++;
      if (atbol)
 {
   if (c == '[')
     num_lang_dirs++;
   else
     {

       n += sizeof (lang_bitmap);
       num_gt_files++;
     }
   atbol = false;
 }

      if (c == '\n')
 atbol = true;
    }

  rewind (list);
  return n;
}
# 267 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static bool
read_input_line (FILE *list, char **herep, char **linep, struct fileloc *pos)
{
  char *here = *herep;
  char *line;
  int c = getc_unlocked (list);


  while (c == '\n' || c == ' ')
    c = getc_unlocked (list);

  if (c == 
# 278 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
          (-1)
# 278 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
             )
    {
      *linep = 0;
      return false;
    }
  else if (c == '[')
    {

      c = getc_unlocked (list);
      line = here;
      while (c != ']' && c != '\n' && c != 
# 288 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                          (-1)
# 288 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                             )
 {
   *here++ = c;
   c = getc_unlocked (list);
 }
      *here++ = '\0';

      if (c == ']')
 {
   c = getc_unlocked (list);
   if (c != '\n' && c != 
# 298 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                        (-1)
# 298 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                           )
     error_at_line (pos, "junk on line after language tag [%s]", line);
 }
      else
 error_at_line (pos, "missing close bracket for language tag [%s",
         line);

      *herep = here;
      *linep = line;
      return true;
    }
  else
    {

      memset (here, 0, sizeof (lang_bitmap));
      here += sizeof (lang_bitmap);
      line = here;
      do
 {
   *here++ = c;
   c = getc_unlocked (list);
 }
      while (c != 
# 320 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                 (-1) 
# 320 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                     && c != '\n');
      *here++ = '\0';
      *herep = here;
      *linep = line;
      return false;
    }
}
# 336 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
read_input_list (const char *listname)
{
  FILE *list = fopen_unlocked (listname, "r");
  if (!list)
    fatal ("cannot open %s: %s", listname, xstrerror (
# 341 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                                     (*__errno_location ())
# 341 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                                          ));
  else
    {
      struct fileloc epos;
      size_t bufsz = measure_input_list (list);
      char *buf = ((char *) xmalloc (sizeof (char) * (bufsz)));
      char *here = buf;
      char *committed = buf;
      char *limit = buf + bufsz;
      char *line;
      bool is_language;
      size_t langno = 0;
      size_t nfiles = 0;
      lang_bitmap curlangs = (1 << num_lang_dirs) - 1;

      epos.file = input_file_by_name (listname);
      epos.line = 0;

      lang_dir_names = ((const char * *) xmalloc (sizeof (const char *) * (num_lang_dirs)));
      gt_files = ((const input_file * *) xmalloc (sizeof (const input_file *) * (num_gt_files)));

      for (;;)
 {
 next_line:
   epos.line++;
   committed = here;
   is_language = read_input_line (list, &here, &line, &epos);
   ((void)(!(here <= limit) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 368, __FUNCTION__), 0 : 0));
   if (line == 0)
     break;
   else if (is_language)
     {
       size_t i;
       ((void)(!(langno <= num_lang_dirs) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 374, __FUNCTION__), 0 : 0));
       for (i = 0; i < langno; i++)
  if (strcmp (lang_dir_names[i], line) == 0)
    {
      error_at_line (&epos, "duplicate language tag [%s]",
       line);
      curlangs = 1 << i;
      here = committed;
      goto next_line;
    }

       curlangs = 1 << langno;
       lang_dir_names[langno++] = line;
     }
   else
     {
       size_t i;
       input_file *inpf = input_file_by_name (line);
       ((void)(!(nfiles <= num_gt_files) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 392, __FUNCTION__), 0 : 0));
       for (i = 0; i < nfiles; i++)


  if (gt_files[i] == inpf)
    {


      lang_bitmap bmap = get_lang_bitmap (inpf);
      if (bmap & curlangs)
        error_at_line (&epos,
         "file %s specified more than once "
         "for language %s", line,
         langno ==
         0 ? "(all)" : lang_dir_names[langno -
          1]);

      bmap |= curlangs;
      set_lang_bitmap (inpf, bmap);
      here = committed;
      goto next_line;
    }

       set_lang_bitmap (inpf, curlangs);
       gt_files[nfiles++] = inpf;
     }
 }


      num_lang_dirs = langno;

      if (plugin_files)
 {
   size_t i;
   for (i = 0; i < nb_plugin_files; i++)
     gt_files[nfiles++] = plugin_files[i];
 }
      num_gt_files = nfiles;
    }





  {
    size_t f;
    for (f = 0; f < num_gt_files; f++)
      {
 lang_bitmap bitmap = get_lang_bitmap (gt_files[f]);
 const char *basename = get_file_basename (gt_files[f]);
 const char *slashpos = strchr (basename, '/');







 if (slashpos)
   {
     size_t l;
     for (l = 0; l < num_lang_dirs; l++)
       if ((size_t) (slashpos - basename) == strlen (lang_dir_names[l])
    && memcmp (basename, lang_dir_names[l],
        strlen (lang_dir_names[l])) == 0)
  {
    if (!(bitmap & (1 << l)))
      error ("%s is in language directory '%s' but is not "
      "tagged for that language",
      basename, lang_dir_names[l]);
    break;
  }
   }
      }
  }

  if (ferror_unlocked (list))
    fatal ("error reading %s: %s", listname, xstrerror (
# 469 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                                       (*__errno_location ())
# 469 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                                            ));

  fclose (list);
}





struct type string_type = {
  TYPE_STRING, 0, 0, 0, GC_USED, {0}
};




struct type scalar_nonchar = {
  TYPE_SCALAR, 0, 0, 0, GC_USED, {0}
};

struct type scalar_char = {
  TYPE_SCALAR, 0, 0, 0, GC_USED, {0}
};



pair_p typedefs = nullptr;
type_p structures = nullptr;
pair_p variables = nullptr;

static type_p adjust_field_tree_exp (type_p t, options_p opt);
static type_p adjust_field_rtx_def (type_p t, options_p opt);



void
do_typedef (const char *s, type_p t, struct fileloc *pos)
{
  pair_p p;





  if (!strcmp (s, "CUMULATIVE_ARGS") && pos->file != this_file)
    return;

  for (p = typedefs; p != nullptr; p = p->next)
    if (strcmp (p->name, s) == 0)
      {
 if (p->type != t && strcmp (s, "result_type") != 0)
   {
     error_at_line (pos, "type `%s' previously defined", s);
     error_at_line (&p->line, "previously defined here");
   }
 return;
      }

  p = ((struct pair *) xmalloc (sizeof (struct pair)));
  p->next = typedefs;
  p->name = s;
  p->type = t;
  p->line = *pos;
  p->opt = nullptr;
  typedefs = p;
}





void
do_scalar_typedef (const char *s, struct fileloc *pos)
{
  do_typedef (s, &scalar_nonchar, pos);
}



static char *
strtoken (char *str, const char *delim, char **next)
{
  char *p;

  if (str == nullptr)
    str = *next;


  str += strspn (str, delim);
  if (*str == '\0')

    return nullptr;


  p = str;


  str += strcspn (str, delim);
  if (*str == '\0')

    *next = str;
  else
    {

      *str = '\0';

      *next = str + 1;
    }

  return p;
}



type_p
create_user_defined_type (const char *type_name, struct fileloc *pos)
{
  type_p ty = find_structure (type_name, TYPE_USER_STRUCT);




  ty->kind = TYPE_USER_STRUCT;

  ty->u.s.line = *pos;
  ty->u.s.bitmap = get_lang_bitmap (pos->file);
  do_typedef (type_name, ty, pos);





  char *str = xstrdup (type_name);
  char *open_bracket = strchr (str, '<');
  if (open_bracket)
    {




      char *arg = open_bracket + 1;


      char *next = nullptr;
      char *type_id = strtoken (arg, ",>", &next);
      pair_p fields = 0;
      while (type_id)
 {




   const char *star = strchr (type_id, '*');
   int is_ptr = (star != nullptr);
   size_t offset_to_star = star - type_id;
   if (is_ptr)
     offset_to_star = star - type_id;

   if (strstr (type_id, "char*"))
     {
   type_id = strtoken (0, ",>", &next);
   continue;
     }

   char *field_name = xstrdup (type_id);

   type_p arg_type;
   if (is_ptr)
     {

       *(field_name + offset_to_star) = '\0';

       arg_type = find_structure (field_name, TYPE_STRUCT);
       arg_type = create_pointer (arg_type);
     }
   else
     arg_type = resolve_typedef (field_name, pos);

   fields = create_field_at (fields, arg_type, field_name, 0, pos);
   type_id = strtoken (0, ",>", &next);
 }


      ty->u.s.fields = fields;
    }
  free (str);

  return ty;
}





static type_p
type_for_name (const char *s)
{
  pair_p p;







  if (strncmp (s, "gcc::", 5) == 0)
    s += 5;

  for (p = typedefs; p != nullptr; p = p->next)
    if (strcmp (p->name, s) == 0)
      return p->type;
  return nullptr;
}





static type_p
create_undefined_type (const char *s, struct fileloc *pos)
{
  type_p ty = find_structure (s, TYPE_UNDEFINED);
  ty->u.s.line = *pos;
  ty->u.s.bitmap = get_lang_bitmap (pos->file);
  do_typedef (s, ty, pos);
  return ty;
}




type_p
resolve_typedef (const char *s, struct fileloc *pos)
{
  bool is_template_instance = (strchr (s, '<') != nullptr);
  type_p p = type_for_name (s);
# 716 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
  if (!p)
    p = (is_template_instance)
 ? create_user_defined_type (s, pos)
 : create_undefined_type (s, pos);

  return p;
}



void add_subclass (type_p base, type_p subclass)
{
  ((void)(!(union_or_struct_p (base)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 728, __FUNCTION__), 0 : 0));
  ((void)(!(union_or_struct_p (subclass)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 729, __FUNCTION__), 0 : 0));

  subclass->u.s.next_sibling_class = base->u.s.first_subclass;
  base->u.s.first_subclass = subclass;
}





type_p
new_structure (const char *name, enum typekind kind, struct fileloc *pos,
        pair_p fields, options_p o, type_p base_class)
{
  type_p si;
  type_p s = nullptr;
  lang_bitmap bitmap = get_lang_bitmap (pos->file);
  bool isunion = (kind == TYPE_UNION);
  type_p *p = &structures;

  ((void)(!(union_or_struct_p (kind)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 749, __FUNCTION__), 0 : 0));

  for (si = structures; si != nullptr; p = &si->next, si = *p)
    if (strcmp (name, si->u.s.tag) == 0 && ((si)->kind == TYPE_UNION || ((si)->kind == TYPE_LANG_STRUCT && (si)->u.s.lang_struct->kind == TYPE_UNION)) == isunion)
      {
 type_p ls = nullptr;
 if (si->kind == TYPE_LANG_STRUCT)
   {
     ls = si;

     for (si = ls->u.s.lang_struct; si != nullptr; si = si->next)
       if (si->u.s.bitmap == bitmap)
  s = si;
   }
 else if (si->u.s.line.file != nullptr && si->u.s.bitmap != bitmap)
   {
     ls = si;
     type_count++;
     si = ((struct type *) xcalloc (1, sizeof (struct type)));
     memcpy (si, ls, sizeof (struct type));
     ls->kind = TYPE_LANG_STRUCT;
     ls->u.s.lang_struct = si;
     ls->u.s.fields = nullptr;
     si->next = nullptr;
     si->state_number = -type_count;
     si->pointer_to = nullptr;
     si->u.s.lang_struct = ls;
   }
 else
   s = si;

 if (ls != nullptr && s == nullptr)
   {
     type_count++;
     s = ((struct type *) xcalloc (1, sizeof (struct type)));
     s->state_number = -type_count;
     s->next = ls->u.s.lang_struct;
     ls->u.s.lang_struct = s;
     s->u.s.lang_struct = ls;
   }
 break;
      }

  if (s == nullptr)
    {
      type_count++;
      s = ((struct type *) xcalloc (1, sizeof (struct type)));
      s->state_number = -type_count;
      *p = s;
    }

  if (s->u.s.lang_struct && (s->u.s.lang_struct->u.s.bitmap & bitmap))
    {
      error_at_line (pos, "duplicate definition of '%s %s'",
       isunion ? "union" : "struct", s->u.s.tag);
      error_at_line (&s->u.s.line, "previous definition here");
    }

  s->kind = kind;
  s->u.s.tag = name;
  s->u.s.line = *pos;
  s->u.s.fields = fields;
  s->u.s.opt = o;
  s->u.s.bitmap = bitmap;
  if (s->u.s.lang_struct)
    s->u.s.lang_struct->u.s.bitmap |= bitmap;
  s->u.s.base_class = base_class;
  if (base_class)
    add_subclass (base_class, s);

  return s;
}






type_p
find_structure (const char *name, enum typekind kind)
{
  type_p s;
  bool isunion = (kind == TYPE_UNION);
  type_p *p = &structures;

  ((void)(!(kind == TYPE_UNDEFINED || union_or_struct_p (kind)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 834, __FUNCTION__), 0 : 0));

  for (s = structures; s != nullptr; p = &s->next, s = *p)
    if (strcmp (name, s->u.s.tag) == 0 && ((s)->kind == TYPE_UNION || ((s)->kind == TYPE_LANG_STRUCT && (s)->u.s.lang_struct->kind == TYPE_UNION)) == isunion)
      return s;

  type_count++;
  s = ((struct type *) xcalloc (1, sizeof (struct type)));
  s->state_number = -type_count;
  s->kind = kind;
  s->u.s.tag = name;
  *p = s;
  return s;
}



type_p
create_scalar_type (const char *name)
{
  if (!strcmp (name, "char") || !strcmp (name, "unsigned char"))
    return &scalar_char;
  else
    return &scalar_nonchar;
}




type_p
create_pointer (type_p t)
{
  if (!t->pointer_to)
    {
      type_p r = ((struct type *) xcalloc (1, sizeof (struct type)));
      type_count++;
      r->state_number = -type_count;
      r->kind = TYPE_POINTER;
      r->u.p = t;
      t->pointer_to = r;
    }
  return t->pointer_to;
}



type_p
create_array (type_p t, const char *len)
{
  type_p v;

  type_count++;
  v = ((struct type *) xcalloc (1, sizeof (struct type)));
  v->kind = TYPE_ARRAY;
  v->state_number = -type_count;
  v->u.a.p = t;
  v->u.a.len = len;
  return v;
}



options_p
create_string_option (options_p next, const char *name, const char *info)
{
  options_p o = ((struct options *) xmalloc (sizeof (struct options)));
  o->kind = OPTION_STRING;
  o->next = next;
  o->name = name;
  o->info.string = info;
  return o;
}



options_p
create_type_option (options_p next, const char* name, type_p info)
{
  options_p o = ((struct options *) xmalloc (sizeof (struct options)));
  o->next = next;
  o->name = name;
  o->kind = OPTION_TYPE;
  o->info.type = info;
  return o;
}



options_p
create_nested_option (options_p next, const char* name,
                      struct nested_ptr_data* info)
{
  options_p o;
  o = ((struct options *) xmalloc (sizeof (struct options)));
  o->next = next;
  o->name = name;
  o->kind = OPTION_NESTED;
  o->info.nested = info;
  return o;
}


options_p
create_nested_ptr_option (options_p next, type_p t,
     const char *to, const char *from)
{
  struct nested_ptr_data *d = ((struct nested_ptr_data *) xmalloc (sizeof (struct nested_ptr_data)));

  d->type = adjust_field_type (t, 0);
  d->convert_to = to;
  d->convert_from = from;
  return create_nested_option (next, "nested_ptr", d);
}



void
note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)
{
  pair_p n;
  n = ((struct pair *) xmalloc (sizeof (struct pair)));
  n->name = s;
  n->type = t;
  n->line = *pos;
  n->opt = o;
  n->next = variables;
  variables = n;
}


static pair_p
create_field_all (pair_p next, type_p type, const char *name, options_p opt,
    const input_file *inpf, int line)
{
  pair_p field;

  field = ((struct pair *) xmalloc (sizeof (struct pair)));
  field->next = next;
  field->type = type;
  field->name = name;
  field->opt = opt;
  field->line.file = inpf;
  field->line.line = line;
  return field;
}




pair_p
create_field_at (pair_p next, type_p type, const char *name, options_p opt,
   struct fileloc *pos)
{
  return create_field_all (next, adjust_field_type (type, opt),
      name, opt, pos->file, pos->line);
}
# 999 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static pair_p
create_optional_field_ (pair_p next, type_p type, const char *name,
   const char *cond, int line)
{
  static int id = 1;
  pair_p union_fields;
  type_p union_type;




  union_fields = create_field_all (nullptr,type,"", 0, this_file, 1010);
  union_fields->opt =
    create_string_option (union_fields->opt, "dot", "");
  union_fields->opt =
    create_string_option (union_fields->opt, "tag", "1");
  union_type =
    new_structure (xasprintf ("%s_%d", "fake_union", id++), TYPE_UNION,
                   &lexer_line, union_fields, nullptr, nullptr);



  return create_field_all (next, union_type, name,
      create_string_option (0, "desc", cond),
      this_file, line);
}





pair_p
nreverse_pairs (pair_p list)
{
  pair_p prev = 0, p, next;
  for (p = list; p; p = next)
    {
      next = p->next;
      p->next = prev;
      prev = p;
    }
  return prev;
}







enum rtx_code
{

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def" 1
# 81 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
UNKNOWN ,






VALUE ,



DEBUG_EXPR ,






EXPR_LIST ,



INSN_LIST ,


INT_LIST ,
# 126 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
SEQUENCE ,


ADDRESS ,
# 142 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
DEBUG_INSN ,


INSN ,



JUMP_INSN ,






CALL_INSN ,






JUMP_TABLE_DATA ,


BARRIER ,







CODE_LABEL ,






NOTE ,
# 194 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
COND_EXEC ,


PARALLEL ,







ASM_INPUT ,
# 219 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
ASM_OPERANDS ,
# 237 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
UNSPEC ,


UNSPEC_VOLATILE ,







ADDR_VEC ,
# 272 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
ADDR_DIFF_VEC ,
# 283 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
PREFETCH ,
# 295 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
SET ,
# 304 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
USE ,
# 313 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
CLOBBER ,





CALL ,



RETURN ,





SIMPLE_RETURN ,



EH_RETURN ,





TRAP_IF ,






CONST_INT ,


CONST_WIDE_INT ,


CONST_POLY_INT ,


CONST_FIXED ,





CONST_DOUBLE ,


CONST_VECTOR ,




CONST_STRING ,





CONST ,



PC ,







REG ,





SCRATCH ,



SUBREG ,
# 410 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
STRICT_LOW_PART ,





CONCAT ,





CONCATN ,




MEM ,



LABEL_REF ,





SYMBOL_REF ,






CC0 ,
# 456 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
IF_THEN_ELSE ,


COMPARE ,


PLUS ,


MINUS ,


NEG ,

MULT ,


SS_MULT ,

US_MULT ,


DIV ,

SS_DIV ,

US_DIV ,


MOD ,


UDIV ,
UMOD ,


AND ,
IOR ,
XOR ,
NOT ,




ASHIFT ,
ROTATE ,
ASHIFTRT ,
LSHIFTRT ,
ROTATERT ,
# 513 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
SMIN ,
SMAX ,
UMIN ,
UMAX ,
# 525 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
PRE_DEC ,
PRE_INC ,
POST_DEC ,
POST_INC ,
# 542 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
PRE_MODIFY ,
POST_MODIFY ,







NE ,
EQ ,
GE ,
GT ,
LE ,
LT ,
LTGT ,
GEU ,
GTU ,
LEU ,
LTU ,


UNORDERED ,
ORDERED ,


UNEQ ,
UNGE ,
UNGT ,
UNLE ,
UNLT ,




SIGN_EXTEND ,


ZERO_EXTEND ,


TRUNCATE ,


FLOAT_EXTEND ,
FLOAT_TRUNCATE ,


FLOAT ,







FIX ,


UNSIGNED_FLOAT ,




UNSIGNED_FIX ,
# 616 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
FRACT_CONVERT ,






UNSIGNED_FRACT_CONVERT ,







SAT_FRACT ,





UNSIGNED_SAT_FRACT ,


ABS ,


SQRT ,


BSWAP ,




FFS ,



CLRSB ,


CLZ ,


CTZ ,


POPCOUNT ,


PARITY ,
# 679 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
SIGN_EXTRACT ,



ZERO_EXTRACT ,




HIGH ,



LO_SUM ,






VEC_MERGE ,





VEC_SELECT ,




VEC_CONCAT ,





VEC_DUPLICATE ,




VEC_SERIES ,


SS_PLUS ,


US_PLUS ,


SS_MINUS ,


SS_NEG ,

US_NEG ,


SS_ABS ,


SS_ASHIFT ,


US_ASHIFT ,


US_MINUS ,


SS_TRUNCATE ,


US_TRUNCATE ,


FMA ,


VAR_LOCATION ,



DEBUG_IMPLICIT_PTR ,




ENTRY_VALUE ,



DEBUG_PARAMETER_REF ,


DEBUG_MARKER ,
# 1053 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2

  NUM_RTX_CODE
};

static const char *const rtx_name[NUM_RTX_CODE] = {

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def" 1
# 81 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"UnKnown" ,






"value" ,



"debug_expr" ,






"expr_list" ,



"insn_list" ,


"int_list" ,
# 126 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"sequence" ,


"address" ,
# 142 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"debug_insn" ,


"insn" ,



"jump_insn" ,






"call_insn" ,






"jump_table_data" ,


"barrier" ,







"code_label" ,






"note" ,
# 194 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"cond_exec" ,


"parallel" ,







"asm_input" ,
# 219 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"asm_operands" ,
# 237 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"unspec" ,


"unspec_volatile" ,







"addr_vec" ,
# 272 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"addr_diff_vec" ,
# 283 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"prefetch" ,
# 295 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"set" ,
# 304 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"use" ,
# 313 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"clobber" ,





"call" ,



"return" ,





"simple_return" ,



"eh_return" ,





"trap_if" ,






"const_int" ,


"const_wide_int" ,


"const_poly_int" ,


"const_fixed" ,





"const_double" ,


"const_vector" ,




"const_string" ,





"const" ,



"pc" ,







"reg" ,





"scratch" ,



"subreg" ,
# 410 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"strict_low_part" ,





"concat" ,





"concatn" ,




"mem" ,



"label_ref" ,





"symbol_ref" ,






"cc0" ,
# 456 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"if_then_else" ,


"compare" ,


"plus" ,


"minus" ,


"neg" ,

"mult" ,


"ss_mult" ,

"us_mult" ,


"div" ,

"ss_div" ,

"us_div" ,


"mod" ,


"udiv" ,
"umod" ,


"and" ,
"ior" ,
"xor" ,
"not" ,




"ashift" ,
"rotate" ,
"ashiftrt" ,
"lshiftrt" ,
"rotatert" ,
# 513 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"smin" ,
"smax" ,
"umin" ,
"umax" ,
# 525 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"pre_dec" ,
"pre_inc" ,
"post_dec" ,
"post_inc" ,
# 542 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"pre_modify" ,
"post_modify" ,







"ne" ,
"eq" ,
"ge" ,
"gt" ,
"le" ,
"lt" ,
"ltgt" ,
"geu" ,
"gtu" ,
"leu" ,
"ltu" ,


"unordered" ,
"ordered" ,


"uneq" ,
"unge" ,
"ungt" ,
"unle" ,
"unlt" ,




"sign_extend" ,


"zero_extend" ,


"truncate" ,


"float_extend" ,
"float_truncate" ,


"float" ,







"fix" ,


"unsigned_float" ,




"unsigned_fix" ,
# 616 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"fract_convert" ,






"unsigned_fract_convert" ,







"sat_fract" ,





"unsigned_sat_fract" ,


"abs" ,


"sqrt" ,


"bswap" ,




"ffs" ,



"clrsb" ,


"clz" ,


"ctz" ,


"popcount" ,


"parity" ,
# 679 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"sign_extract" ,



"zero_extract" ,




"high" ,



"lo_sum" ,






"vec_merge" ,





"vec_select" ,




"vec_concat" ,





"vec_duplicate" ,




"vec_series" ,


"ss_plus" ,


"us_plus" ,


"ss_minus" ,


"ss_neg" ,

"us_neg" ,


"ss_abs" ,


"ss_ashift" ,


"us_ashift" ,


"us_minus" ,


"ss_truncate" ,


"us_truncate" ,


"fma" ,


"var_location" ,



"debug_implicit_ptr" ,




"entry_value" ,



"debug_parameter_ref" ,


"debug_marker" ,
# 1060 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2

};

static const char *const rtx_format[NUM_RTX_CODE] = {

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def" 1
# 81 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"*" ,






"0" ,



"0" ,






"ee" ,



"ue" ,


"ie" ,
# 126 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"E" ,


"i" ,
# 142 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"uuBeiie" ,


"uuBeiie" ,



"uuBeiie0" ,






"uuBeiiee" ,






"uuBe0000" ,


"uu00000" ,







"uuB00is" ,






"uuB0ni" ,
# 194 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"ee" ,


"E" ,







"si" ,
# 219 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"ssiEEEi" ,
# 237 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"Ei" ,


"Ei" ,







"E" ,
# 272 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"eEee0" ,
# 283 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"eee" ,
# 295 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"ee" ,
# 304 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"e" ,
# 313 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"e" ,





"ee" ,



"" ,





"" ,



"" ,





"ee" ,






"w" ,


"" ,


"" ,


"www" ,





"ww" ,


"E" ,




"s" ,





"e" ,



"" ,







"r" ,





"" ,



"ep" ,
# 410 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"e" ,





"ee" ,





"E" ,




"e0" ,



"u" ,





"s0" ,






"" ,
# 456 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"eee" ,


"ee" ,


"ee" ,


"ee" ,


"e" ,

"ee" ,


"ee" ,

"ee" ,


"ee" ,

"ee" ,

"ee" ,


"ee" ,


"ee" ,
"ee" ,


"ee" ,
"ee" ,
"ee" ,
"e" ,




"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
# 513 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"ee" ,
"ee" ,
"ee" ,
"ee" ,
# 525 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"e" ,
"e" ,
"e" ,
"e" ,
# 542 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"ee" ,
"ee" ,







"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,


"ee" ,
"ee" ,


"ee" ,
"ee" ,
"ee" ,
"ee" ,
"ee" ,




"e" ,


"e" ,


"e" ,


"e" ,
"e" ,


"e" ,







"e" ,


"e" ,




"e" ,
# 616 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"e" ,






"e" ,







"e" ,





"e" ,


"e" ,


"e" ,


"e" ,




"e" ,



"e" ,


"e" ,


"e" ,


"e" ,


"e" ,
# 679 "/home/giulianob/gcc_git_gnu/gcc/gcc/rtl.def"
"eee" ,



"eee" ,




"e" ,



"ee" ,






"eee" ,





"ee" ,




"ee" ,





"e" ,




"ee" ,


"ee" ,


"ee" ,


"ee" ,


"e" ,

"e" ,


"e" ,


"ee" ,


"ee" ,


"ee" ,


"e" ,


"e" ,


"eee" ,


"te" ,



"t" ,




"0" ,



"t" ,


"" ,
# 1066 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2

};

static int rtx_next_new[NUM_RTX_CODE];



enum insn_note
{

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/insn-notes.def" 1
# 35 "/home/giulianob/gcc_git_gnu/gcc/gcc/insn-notes.def"
NOTE_INSN_DELETED,


NOTE_INSN_DELETED_LABEL,



NOTE_INSN_DELETED_DEBUG_LABEL,



NOTE_INSN_BLOCK_BEG,
NOTE_INSN_BLOCK_END,




NOTE_INSN_FUNCTION_BEG,


NOTE_INSN_PROLOGUE_END,


NOTE_INSN_EPILOGUE_BEG,



NOTE_INSN_EH_REGION_BEG,
NOTE_INSN_EH_REGION_END,


NOTE_INSN_VAR_LOCATION,


NOTE_INSN_BEGIN_STMT,



NOTE_INSN_INLINE_ENTRY,






NOTE_INSN_BASIC_BLOCK,



NOTE_INSN_SWITCH_TEXT_SECTIONS,



NOTE_INSN_CFI,



NOTE_INSN_CFI_LABEL,



NOTE_INSN_UPDATE_SJLJ_CONTEXT,
# 1077 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2


  NOTE_INSN_MAX
};



static const char *const note_insn_name[NOTE_INSN_MAX + 1] = {

# 1 "/home/giulianob/gcc_git_gnu/gcc/gcc/insn-notes.def" 1
# 35 "/home/giulianob/gcc_git_gnu/gcc/gcc/insn-notes.def"
"NOTE_INSN_DELETED",


"NOTE_INSN_DELETED_LABEL",



"NOTE_INSN_DELETED_DEBUG_LABEL",



"NOTE_INSN_BLOCK_BEG",
"NOTE_INSN_BLOCK_END",




"NOTE_INSN_FUNCTION_BEG",


"NOTE_INSN_PROLOGUE_END",


"NOTE_INSN_EPILOGUE_BEG",



"NOTE_INSN_EH_REGION_BEG",
"NOTE_INSN_EH_REGION_END",


"NOTE_INSN_VAR_LOCATION",


"NOTE_INSN_BEGIN_STMT",



"NOTE_INSN_INLINE_ENTRY",






"NOTE_INSN_BASIC_BLOCK",



"NOTE_INSN_SWITCH_TEXT_SECTIONS",



"NOTE_INSN_CFI",



"NOTE_INSN_CFI_LABEL",



"NOTE_INSN_UPDATE_SJLJ_CONTEXT",
# 1087 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 2

};







static void
gen_rtx_next (void)
{
  int i;
  for (i = 0; i < NUM_RTX_CODE; i++)
    {
      int k;

      rtx_next_new[i] = -1;
      if (strncmp (rtx_format[i], "uu", 2) == 0)
 rtx_next_new[i] = 1;
      else if (i == COND_EXEC || i == SET || i == EXPR_LIST || i == INSN_LIST)
 rtx_next_new[i] = 1;
      else
 for (k = strlen (rtx_format[i]) - 1; k >= 0; k--)
   if (rtx_format[i][k] == 'e' || rtx_format[i][k] == 'u')
     rtx_next_new[i] = k;
    }
}


static void
write_rtx_next (void)
{
  outf_p f = get_output_file_with_visibility (nullptr);
  int i;
  if (!f)
    return;

  oprintf (f, "\n/* Used to implement the RTX_NEXT macro.  */\n");
  oprintf (f, "EXPORTED_CONST unsigned char rtx_next[NUM_RTX_CODE] = {\n");
  for (i = 0; i < NUM_RTX_CODE; i++)
    if (rtx_next_new[i] == -1)
      oprintf (f, "  0,\n");
    else
      oprintf (f,
        "  RTX_HDR_SIZE + %d * sizeof (rtunion),\n", rtx_next_new[i]);
  oprintf (f, "};\n");
}





static type_p
adjust_field_rtx_def (type_p t, options_p opt __attribute__ ((__unused__)))
{
  pair_p flds = nullptr;
  options_p nodot;
  int i;
  type_p rtx_tp, rtvec_tp, tree_tp, mem_attrs_tp, note_union_tp, scalar_tp;
  type_p basic_block_tp, reg_attrs_tp, constant_tp, symbol_union_tp;

  if (t->kind != TYPE_UNION)
    {
      error_at_line (&lexer_line,
       "special `rtx_def' must be applied to a union");
      return &string_type;
    }

  nodot = create_string_option (nullptr, "dot", "");

  rtx_tp = create_pointer (find_structure ("rtx_def", TYPE_STRUCT));
  rtvec_tp = create_pointer (find_structure ("rtvec_def", TYPE_STRUCT));
  tree_tp = create_pointer (find_structure ("tree_node", TYPE_UNION));
  mem_attrs_tp = create_pointer (find_structure ("mem_attrs", TYPE_STRUCT));
  reg_attrs_tp =
    create_pointer (find_structure ("reg_attrs", TYPE_STRUCT));
  basic_block_tp =
    create_pointer (find_structure ("basic_block_def", TYPE_STRUCT));
  constant_tp =
    create_pointer (find_structure ("constant_descriptor_rtx", TYPE_STRUCT));
  scalar_tp = &scalar_nonchar;

  {
    pair_p note_flds = nullptr;
    int c;

    for (c = 0; c <= NOTE_INSN_MAX; c++)
      {
 switch (c)
   {
   case NOTE_INSN_MAX:
   case NOTE_INSN_DELETED_LABEL:
   case NOTE_INSN_DELETED_DEBUG_LABEL:
     note_flds = create_field_all (note_flds,&string_type,"rt_str", 0, this_file, 1181);
     break;

   case NOTE_INSN_BLOCK_BEG:
   case NOTE_INSN_BLOCK_END:
     note_flds = create_field_all (note_flds,tree_tp,"rt_tree", 0, this_file, 1186);
     break;

   case NOTE_INSN_VAR_LOCATION:
     note_flds = create_field_all (note_flds,rtx_tp,"rt_rtx", 0, this_file, 1190);
     break;

   default:
     note_flds = create_field_all (note_flds,scalar_tp,"rt_int", 0, this_file, 1194);
     break;
   }


 if (c == NOTE_INSN_MAX)
   note_flds->opt =
     create_string_option (nodot, "default", "");
 else
   note_flds->opt =
     create_string_option (nodot, "tag", note_insn_name[c]);
      }
    note_union_tp = new_structure ("rtx_def_note_subunion", TYPE_UNION,
       &lexer_line, note_flds, nullptr, nullptr);
  }

  {
    pair_p sym_flds;
    sym_flds = create_field_all (nullptr,tree_tp,"rt_tree", 0, this_file, 1212);
    sym_flds->opt = create_string_option (nodot, "default", "");
    sym_flds = create_field_all (sym_flds,constant_tp,"rt_constant", 0, this_file, 1214);
    sym_flds->opt = create_string_option (nodot, "tag", "1");
    symbol_union_tp = new_structure ("rtx_def_symbol_subunion", TYPE_UNION,
         &lexer_line, sym_flds, nullptr, nullptr);
  }
  for (i = 0; i < NUM_RTX_CODE; i++)
    {
      pair_p subfields = nullptr;
      size_t aindex, nmindex;
      const char *sname;
      type_p substruct;
      char *ftag;

      for (aindex = 0; aindex < strlen (rtx_format[i]); aindex++)
 {
   type_p t;
   const char *subname;

   switch (rtx_format[i][aindex])
     {
     case '*':
     case 'i':
     case 'n':
     case 'w':
     case 'r':
       t = scalar_tp;
       subname = "rt_int";
       break;

     case 'p':
       t = scalar_tp;
       subname = "rt_subreg";
       break;

     case '0':
       if (i == MEM && aindex == 1)
  t = mem_attrs_tp, subname = "rt_mem";
       else if (i == JUMP_INSN && aindex == 7)
  t = rtx_tp, subname = "rt_rtx";
       else if (i == CODE_LABEL && aindex == 4)
  t = scalar_tp, subname = "rt_int";
       else if (i == CODE_LABEL && aindex == 3)
  t = rtx_tp, subname = "rt_rtx";
       else if (i == LABEL_REF && (aindex == 1 || aindex == 2))
  t = rtx_tp, subname = "rt_rtx";
       else if (i == NOTE && aindex == 3)
  t = note_union_tp, subname = "";
       else if (i == NOTE && aindex == 4)
  t = scalar_tp, subname = "rt_int";
       else if (i == NOTE && aindex >= 6)
  t = scalar_tp, subname = "rt_int";
       else if (i == ADDR_DIFF_VEC && aindex == 4)
  t = scalar_tp, subname = "rt_int";
       else if (i == VALUE && aindex == 0)
  t = scalar_tp, subname = "rt_int";
       else if (i == DEBUG_EXPR && aindex == 0)
  t = tree_tp, subname = "rt_tree";
       else if (i == SYMBOL_REF && aindex == 1)
  t = symbol_union_tp, subname = "";
       else if (i == JUMP_TABLE_DATA && aindex >= 4)
  t = scalar_tp, subname = "rt_int";
       else if (i == BARRIER && aindex >= 2)
  t = scalar_tp, subname = "rt_int";
       else if (i == ENTRY_VALUE && aindex == 0)
  t = rtx_tp, subname = "rt_rtx";
       else
  {
    error_at_line
      (&lexer_line,
       "rtx type `%s' has `0' in position %lu, can't handle",
       rtx_name[i], (unsigned long) aindex);
    t = &string_type;
    subname = "rt_int";
  }
       break;

     case 's':
     case 'S':
     case 'T':
       t = &string_type;
       subname = "rt_str";
       break;

     case 'e':
     case 'u':
       t = rtx_tp;
       subname = "rt_rtx";
       break;

     case 'E':
     case 'V':
       t = rtvec_tp;
       subname = "rt_rtvec";
       break;

     case 't':
       t = tree_tp;
       subname = "rt_tree";
       break;

     case 'B':
       t = basic_block_tp;
       subname = "rt_bb";
       break;

     default:
       error_at_line
  (&lexer_line,
   "rtx type `%s' has `%c' in position %lu, can't handle",
   rtx_name[i], rtx_format[i][aindex],
   (unsigned long) aindex);
       t = &string_type;
       subname = "rt_int";
       break;
     }

   subfields = create_field_all (subfields,t,xasprintf (".fld[%lu].%s", (unsigned long) aindex, subname), 0, this_file, 1330)


                     ;
   subfields->opt = nodot;
   if (t == note_union_tp)
     subfields->opt =
       create_string_option (subfields->opt, "desc",
        "NOTE_KIND (&%0)");
   if (t == symbol_union_tp)
     subfields->opt =
       create_string_option (subfields->opt, "desc",
        "CONSTANT_POOL_ADDRESS_P (&%0)");
 }

      if (i == REG)
 subfields = create_field_all (subfields,reg_attrs_tp,"reg.attrs", 0, this_file, 1346);

      if (i == SYMBOL_REF)
 {


   type_p field_tp = find_structure ("block_symbol", TYPE_STRUCT);
   subfields
     = create_optional_field_(subfields,field_tp,"block_sym","SYMBOL_REF_HAS_BLOCK_INFO_P (&%0)",1354)
                                             ;
 }

      sname = xasprintf ("rtx_def_%s", rtx_name[i]);
      substruct = new_structure (sname, TYPE_STRUCT, &lexer_line, subfields,
     nullptr, nullptr);

      ftag = xstrdup (rtx_name[i]);
      for (nmindex = 0; nmindex < strlen (ftag); nmindex++)
 ftag[nmindex] = _sch_toupper[(ftag[nmindex]) & 0xff];
      flds = create_field_all (flds,substruct,"", 0, this_file, 1365);
      flds->opt = create_string_option (nodot, "tag", ftag);
    }
  return new_structure ("rtx_def_subunion", TYPE_UNION, &lexer_line, flds,
   nodot, nullptr);
}







static type_p
adjust_field_tree_exp (type_p t, options_p opt __attribute__ ((__unused__)))
{
  pair_p flds;
  options_p nodot;

  if (t->kind != TYPE_ARRAY)
    {
      error_at_line (&lexer_line,
       "special `tree_exp' must be applied to an array");
      return &string_type;
    }

  nodot = create_string_option (nullptr, "dot", "");

  flds = create_field_all (nullptr,t,"", 0, this_file, 1393);
  flds->opt = create_string_option (nodot, "length",
        "TREE_OPERAND_LENGTH ((tree) &%0)");
  flds->opt = create_string_option (flds->opt, "default", "");

  return new_structure ("tree_exp_subunion", TYPE_UNION, &lexer_line, flds,
   nodot, nullptr);
}
# 1412 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
type_p
adjust_field_type (type_p t, options_p opt)
{
  int length_p = 0;
  const int pointer_p = t->kind == TYPE_POINTER;

  for (; opt; opt = opt->next)
    if (strcmp (opt->name, "length") == 0)
      {
 if (length_p)
   error_at_line (&lexer_line, "duplicate `%s' option", opt->name);
 if (t->u.p->kind == TYPE_SCALAR || t->u.p->kind == TYPE_STRING)
   {
     error_at_line (&lexer_line,
      "option `%s' may not be applied to "
      "arrays of atomic types", opt->name);
   }
 length_p = 1;
      }
    else if (strcmp (opt->name, "special") == 0
      && opt->kind == OPTION_STRING)
      {
 const char *special_name = opt->info.string;
 if (strcmp (special_name, "tree_exp") == 0)
   t = adjust_field_tree_exp (t, opt);
 else if (strcmp (special_name, "rtx_def") == 0)
   t = adjust_field_rtx_def (t, opt);
 else
   error_at_line (&lexer_line, "unknown special `%s'", special_name);
      }

  if (!length_p
      && pointer_p && t->u.p->kind == TYPE_SCALAR && t->u.p->u.scalar_is_char)
    return &string_type;
  if (t->kind == TYPE_ARRAY && t->u.a.p->kind == TYPE_POINTER
      && t->u.a.p->u.p->kind == TYPE_SCALAR
      && t->u.a.p->u.p->u.scalar_is_char)
    return create_array (&string_type, t->u.a.len);

  return t;
}


static void set_gc_used_type (type_p, enum gc_used_enum, bool = false);
static void set_gc_used (pair_p);



static void
process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,
      int *length, int *skip, type_p *nested_ptr)
{
  options_p o;
  for (o = opt; o; o = o->next)
    if (strcmp (o->name, "ptr_alias") == 0 && level == GC_POINTED_TO
 && o->kind == OPTION_TYPE)
      set_gc_used_type (o->info.type,
   GC_POINTED_TO);
    else if (strcmp (o->name, "maybe_undef") == 0)
      *maybe_undef = 1;
    else if (strcmp (o->name, "length") == 0)
      *length = 1;
    else if (strcmp (o->name, "skip") == 0)
      *skip = 1;
    else if (strcmp (o->name, "nested_ptr") == 0
      && o->kind == OPTION_NESTED)
      *nested_ptr = ((const struct nested_ptr_data *) o->info.nested)->type;
}
# 1504 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
set_gc_used_type (type_p t, enum gc_used_enum level,
    bool allow_undefined_types)
{
  if (t->gc_used >= level)
    return;

  t->gc_used = level;

  switch (t->kind)
    {
    case TYPE_STRUCT:
    case TYPE_UNION:
    case TYPE_USER_STRUCT:
      {
 pair_p f;
 int dummy;
 type_p dummy2;
 bool allow_undefined_field_types = (t->kind == TYPE_USER_STRUCT);

 process_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy,
       &dummy2);

 if (t->u.s.base_class)
   set_gc_used_type (t->u.s.base_class, level, allow_undefined_types);


 for (type_p subclass = t->u.s.first_subclass; subclass;
      subclass = subclass->u.s.next_sibling_class)
   set_gc_used_type (subclass, level, allow_undefined_types);

 for (type_p sub = (t); sub; sub = sub->u.s.base_class) for (f = sub->u.s.fields; f; f = f->next)
   {
     int maybe_undef = 0;
     int length = 0;
     int skip = 0;
     type_p nested_ptr = nullptr;
     process_gc_options (f->opt, level, &maybe_undef, &length, &skip,
    &nested_ptr);

     if (nested_ptr && f->type->kind == TYPE_POINTER)
       set_gc_used_type (nested_ptr, GC_POINTED_TO);
     else if (length && f->type->kind == TYPE_POINTER)
       set_gc_used_type (f->type->u.p, GC_USED);
     else if (maybe_undef && f->type->kind == TYPE_POINTER)
       set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO);
     else if (skip)
       ;
     else
       set_gc_used_type (f->type, GC_USED, allow_undefined_field_types);
   }
 break;
      }

    case TYPE_UNDEFINED:
      if (level > GC_UNUSED)
 {
   if (!allow_undefined_types)
     error_at_line (&t->u.s.line, "undefined type `%s'", t->u.s.tag);
   t->gc_used = GC_UNUSED;
 }
      break;

    case TYPE_POINTER:
      set_gc_used_type (t->u.p, GC_POINTED_TO);
      break;

    case TYPE_ARRAY:
      set_gc_used_type (t->u.a.p, GC_USED);
      break;

    case TYPE_LANG_STRUCT:
      for (t = t->u.s.lang_struct; t; t = t->next)
 set_gc_used_type (t, level);
      break;

    default:
      break;
    }
}



static void
set_gc_used (pair_p variables)
{
  int nbvars = 0;
  pair_p p;
  for (p = variables; p; p = p->next)
    {
      set_gc_used_type (p->type, GC_USED);
      nbvars++;
    };
  if (verbosity_level >= 2)
    printf ("%s used %d GTY-ed variables\n", progname, nbvars);
}
# 1610 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static outf_p
create_file (const char *name, const char *oname)
{
  static const char *const hdr[] = {
    "   Copyright (C) 2004-2020 Free Software Foundation, Inc.\n",
    "\n",
    "This file is part of GCC.\n",
    "\n",
    "GCC is free software; you can redistribute it and/or modify it under\n",
    "the terms of the GNU General Public License as published by the Free\n",
    "Software Foundation; either version 3, or (at your option) any later\n",
    "version.\n",
    "\n",
    "GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n",
    "WARRANTY; without even the implied warranty of MERCHANTABILITY or\n",
    "FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n",
    "for more details.\n",
    "\n",
    "You should have received a copy of the GNU General Public License\n",
    "along with GCC; see the file COPYING3.  If not see\n",
    "<http://www.gnu.org/licenses/>.  */\n",
    "\n",
    "/* This file is machine generated.  Do not edit.  */\n"
  };
  outf_p f;
  size_t i;

  ((void)(!(name != nullptr) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 1637, __FUNCTION__), 0 : 0));
  ((void)(!(oname != nullptr) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 1638, __FUNCTION__), 0 : 0));
  f = ((struct outf *) xcalloc (1, sizeof (struct outf)));
  f->next = output_files;
  f->name = oname;
  output_files = f;

  oprintf (f, "/* Type information for %s.\n", name);
  for (i = 0; i < (sizeof (hdr) / sizeof ((hdr)[0])); i++)
    oprintf (f, "%s", hdr[i]);
  return f;
}






void
oprintf (outf_p o, const char *format, ...)
{
  char *s;
  size_t slength;
  va_list ap;



  if (!o)
    return;

  
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 __builtin_va_start(
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 ap
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 ,
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 format
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 )
# 1667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                      ;
  slength = vasprintf (&s, format, ap);
  if (s == nullptr || (int) slength < 0)
    fatal ("out of memory");
  
# 1671 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 __builtin_va_end(
# 1671 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 ap
# 1671 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 )
# 1671 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
            ;

  if (o->bufused + slength > o->buflength)
    {
      size_t new_len = o->buflength;
      if (new_len == 0)
 new_len = 1024;
      do
 {
   new_len *= 2;
 }
      while (o->bufused + slength >= new_len);
      o->buf = ((char *) xrealloc ((void *) (o->buf), sizeof (char) * (new_len)));
      o->buflength = new_len;
    }
  memcpy (o->buf + o->bufused, s, slength);
  o->bufused += slength;
  free (s);
}



static void
open_base_files (void)
{
  size_t i;

  if (nb_plugin_files > 0 && plugin_files)
    return;

  header_file = create_file ("GCC", "gtype-desc.h");

  base_files = ((outf_p *) xmalloc (sizeof (outf_p) * (num_lang_dirs)));

  for (i = 0; i < num_lang_dirs; i++)
    base_files[i] = create_file (lang_dir_names[i],
     xasprintf ("gtype-%s.h", lang_dir_names[i]));


  {

    static const char *const ifiles[] = {
      "config.h", "system.h", "coretypes.h",
      "backend.h", "predict.h", "tree.h",
      "rtl.h", "gimple.h", "fold-const.h", "insn-codes.h", "splay-tree.h",
      "alias.h", "insn-config.h", "flags.h", "expmed.h", "dojump.h",
      "explow.h", "calls.h", "memmodel.h", "emit-rtl.h", "varasm.h",
      "stmt.h", "expr.h", "alloc-pool.h", "cselib.h", "insn-addr.h",
      "optabs.h", "libfuncs.h", "debug.h", "internal-fn.h", "gimple-fold.h",
      "value-range.h",
      "tree-eh.h", "gimple-iterator.h", "gimple-ssa.h", "tree-cfg.h",
      "tree-vrp.h", "tree-phinodes.h", "ssa-iterators.h", "stringpool.h",
      "tree-ssanames.h", "tree-ssa-loop.h", "tree-ssa-loop-ivopts.h",
      "tree-ssa-loop-manip.h", "tree-ssa-loop-niter.h", "tree-into-ssa.h",
      "tree-dfa.h", "tree-ssa.h", "reload.h", "cpplib.h", "tree-chrec.h",
      "except.h", "output.h", "cfgloop.h", "target.h", "lto-streamer.h",
      "target-globals.h", "ipa-ref.h", "cgraph.h", "symbol-summary.h",
      "ipa-prop.h", "ipa-fnsummary.h", "dwarf2out.h", "omp-general.h",
      "omp-offload.h", nullptr
    };
    const char *const *ifp;
    outf_p gtype_desc_c;

    gtype_desc_c = create_file ("GCC", "gtype-desc.c");
    for (ifp = ifiles; *ifp; ifp++)
      oprintf (gtype_desc_c, "#include \"%s\"\n", *ifp);


    oprintf (gtype_desc_c, "\n/* See definition in function.h.  */\n");
    oprintf (gtype_desc_c, "#undef cfun\n");

    oprintf (gtype_desc_c,
      "\n"
      "/* Types with a \"gcc::\" namespace have it stripped\n"
      "   during gengtype parsing.  Provide a \"using\" directive\n"
      "   to ensure that the fully-qualified types are found.  */\n"
      "using namespace gcc;\n");
  }
}




static const char *
get_file_realbasename (const input_file *inpf)
{
  return lbasename (get_input_file_name (inpf));
}




const char *
get_file_srcdir_relative_path (const input_file *inpf)
{
  const char *f = get_input_file_name (inpf);
  if (strlen (f) > srcdir_len
      && (((f[srcdir_len]) == '/') || (((f[srcdir_len]) == '\\') && (0)))
      && strncmp (f, srcdir, srcdir_len) == 0)
    return f + srcdir_len + 1;
  else
    return nullptr;
}





static const char *
get_file_basename (const input_file *inpf)
{
  const char *srcdir_path = get_file_srcdir_relative_path (inpf);

  return (srcdir_path != nullptr) ? srcdir_path : get_file_realbasename (inpf);
}




static int
get_prefix_langdir_index (const char *f)
{
  size_t f_len = strlen (f);
  size_t lang_index;

  for (lang_index = 0; lang_index < num_lang_dirs; lang_index++)
    {
      const char *langdir = lang_dir_names[lang_index];
      size_t langdir_len = strlen (langdir);

      if (f_len > langdir_len
   && (((f[langdir_len]) == '/') || (((f[langdir_len]) == '\\') && (0)))
   && memcmp (f, langdir, langdir_len) == 0)
 return lang_index;
    }

  return -1;
}




static const char *
get_file_langdir (const input_file *inpf)
{





  int lang_index;
  const char *srcdir_relative_path = get_file_srcdir_relative_path (inpf);
  const char *r;

  if (!srcdir_relative_path)
    return nullptr;

  lang_index = get_prefix_langdir_index (srcdir_relative_path);
  if (lang_index < 0 && strncmp (srcdir_relative_path, "c-family", 8) == 0)
    r = "c-family";
  else if (lang_index >= 0)
    r = lang_dir_names[lang_index];
  else
    r = nullptr;

  return r;
}



static const char *
get_file_gtfilename (const input_file *inpf)
{



  const char *basename = get_file_realbasename (inpf);
  const char *langdir = get_file_langdir (inpf);

  char *result =
    (langdir ? xasprintf ("gt-%s-%s", langdir, basename)
     : xasprintf ("gt-%s", basename));





  char *s = result;

  for (; *s != '.'; s++)
    if (!(_sch_istable[(*s) & 0xff] & (unsigned short)(_sch_isalnum)) && *s != '-')
      *s = '-';

  memcpy (s, ".h", sizeof (".h"));

  return result;
}
# 1903 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
typedef outf_p (frul_actionrout_t) (input_file*, char**, char**);


struct file_rule_st {
  const char* frul_srcexpr;
  int frul_rflags;

  regex_t* frul_re;

  const char* frul_tr_out;



  const char* frul_tr_for;

  frul_actionrout_t* frul_action;




};


static outf_p header_dot_h_frul (input_file*, char**, char**);


static outf_p source_dot_c_frul (input_file*, char**, char**);
# 1941 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
struct file_rule_st files_rules[] = {







  { "^(([^/]*/)*)" "c-family/([[:alnum:]_-]*)\\.c$",
    1, (regex_t*)0,
    "gt-c-family-$3.h", "c-family/$3.c", (frul_actionrout_t*)0},

  { "^(([^/]*/)*)" "c-family/([[:alnum:]_-]*)\\.h$",
    1, (regex_t*)0,
    "gt-c-family-$3.h", "c-family/$3.h", (frul_actionrout_t*)0},


  { "^(([^/]*/)*)" "c/c-lang\\.h$",
    1, (regex_t*)0, "gt-c-c-decl.h", "c/c-decl.c", (frul_actionrout_t*)0},

  { "^(([^/]*/)*)" "c/c-tree\\.h$",
    1, (regex_t*)0, "gt-c-c-decl.h", "c/c-decl.c", (frul_actionrout_t*)0},


  { "^(([^/]*/)*)" "cp/cp-tree\\.h$",
    1, (regex_t*)0,
    "gt-cp-tree.h", "cp/tree.c", (frul_actionrout_t*)0 },


  { "^(([^/]*/)*)" "cp/decl\\.[ch]$",
    1, (regex_t*)0,
    "gt-cp-decl.h", "cp/decl.c", (frul_actionrout_t*)0 },


  { "^(([^/]*/)*)" "cp/name-lookup\\.h$",
    1, (regex_t*)0,
    "gt-cp-name-lookup.h", "cp/name-lookup.c", (frul_actionrout_t*)0 },


  { "^(([^/]*/)*)" "cp/parser\\.h$",
    1, (regex_t*)0,
    "gt-cp-parser.h", "cp/parser.c", (frul_actionrout_t*)0 },


  { "^(([^/]*/)*)" "objc/objc-act\\.h$",
    1, (regex_t*)0,
    "gt-objc-objc-act.h", "objc/objc-act.c", (frul_actionrout_t*)0 },


  { "^(([^/]*/)*)" "objc/objc-map\\.h$",
    1, (regex_t*)0,
    "gt-objc-objc-map.h", "objc/objc-map.c", (frul_actionrout_t*)0 },







  { "^(([^/]*/)*)" "([[:alnum:]_-]*)\\.c$",
    1, (regex_t*)0, "gt-$3.h", "$3.c", source_dot_c_frul},




  { "^(([^/]*/)*)" "([[:alnum:]_-]*)\\.cc$",
    1, (regex_t*)0, "gt-$3.h", "$3.cc", source_dot_c_frul},




  { "^(([^/]*/)*)" "([[:alnum:]_-]*)\\.h$",
    1, (regex_t*)0, "gt-$3.h", "$3.h", header_dot_h_frul},

  { "^(([^/]*/)*)" "([[:alnum:]_-]*)\\.in$",
    1, (regex_t*)0, "gt-$3.h", "$3.in", (frul_actionrout_t*)0},


  {nullptr, 0, (regex_t*)0, nullptr, nullptr, (frul_actionrout_t*)0}
};




static outf_p
header_dot_h_frul (input_file* inpf, char**poutname,
     char**pforname __attribute__ ((__unused__)))
{
  const char *basename = 0;
  int lang_index = 0;
  do {if (do_debug) fprintf (
# 2031 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2031 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "inpf %p inpname %s outname %s forname %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2031, (void*) inpf, get_input_file_name (inpf), *poutname, *pforname);} while (0)

                           ;
  basename = get_file_basename (inpf);
  lang_index = get_prefix_langdir_index (basename);
  do {if (do_debug) fprintf (
# 2036 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2036 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "basename %s lang_index %d" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2036, basename, lang_index);} while (0);

  if (lang_index >= 0)
    {



      do {if (do_debug) fprintf (
# 2043 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
     stderr
# 2043 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     , "%s:%d: " "header_dot_h found language specific @ %p '%s'" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2043, (void*) base_files[lang_index], (base_files[lang_index])->name);} while (0)

                                  ;
      return base_files[lang_index];
    }
  else
    {



      free (*poutname);
      *poutname = xstrdup ("gtype-desc.c");
      do {if (do_debug) fprintf (
# 2055 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
     stderr
# 2055 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     , "%s:%d: " "special 'gtype-desc.c' for inpname %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2055, get_input_file_name (inpf));} while (0)
                              ;
      return nullptr;
    }
}







static outf_p
source_dot_c_frul (input_file* inpf, char**poutname, char**pforname)
{
  char *newbasename = (const_cast<char*> ((get_file_basename (inpf))));
  char *newoutname = (const_cast<char*> ((get_file_gtfilename (inpf))));
  do {if (do_debug) fprintf (
# 2072 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2072 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "inpf %p inpname %s original outname %s forname %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2072, (void*) inpf, get_input_file_name (inpf), *poutname, *pforname);} while (0)

                           ;
  do {if (do_debug) fprintf (
# 2075 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2075 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "newoutname %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2075, newoutname);} while (0);
  do {if (do_debug) fprintf (
# 2076 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2076 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "newbasename %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2076, newbasename);} while (0);
  free (*poutname);
  free (*pforname);
  *poutname = newoutname;
  *pforname = newbasename;
  return nullptr;
}




static char*
matching_file_name_substitute (const char *filnam, regmatch_t pmatch[10],
          const char *trs)
{
  struct obstack str_obstack;
  char *str = nullptr;
  char *rawstr = nullptr;
  const char *pt = nullptr;
  do {if (do_debug) fprintf (
# 2095 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2095 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "filnam %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2095, filnam);} while (0);
  _obstack_begin ((&str_obstack), 0, 0, (xmalloc), (free));
  for (pt = trs; *pt; pt++) {
    char c = *pt;
    if (c == '$')
      {
 if (pt[1] == '$')
   {



     __extension__ ({ struct obstack *__o = (&str_obstack); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < 1) _obstack_newchunk (__o, 1); ((void) (*((__o)->next_free)++ = ('$'))); });
   }
 else if ((_sch_istable[(pt[1]) & 0xff] & (unsigned short)(_sch_isdigit)))
   {

     int dolnum = pt[1] - '0';
     int so = pmatch[dolnum].rm_so;
     int eo = pmatch[dolnum].rm_eo;
     do {if (do_debug) fprintf (
# 2114 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
    stderr
# 2114 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
    , "%s:%d: " "so=%d eo=%d dolnum=%d" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2114, so, eo, dolnum);} while (0);
     if (so>=0 && eo>=so)
       __extension__ ({ struct obstack *__o = (&str_obstack); size_t __len = (eo - so); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < __len) _obstack_newchunk (__o, __len); memcpy (__o->next_free, filnam + so, __len); __o->next_free += __len; (void) 0; });
   }
 else
   {

     (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 2121, __FUNCTION__));
   }

 pt++;
      }
    else
      __extension__ ({ struct obstack *__o = (&str_obstack); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < 1) _obstack_newchunk (__o, 1); ((void) (*((__o)->next_free)++ = (c))); });
  }
  __extension__ ({ struct obstack *__o = (&str_obstack); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < 1) _obstack_newchunk (__o, 1); ((void) (*((__o)->next_free)++ = ('\0'))); });
  rawstr = ((char *) __extension__ ({ struct obstack *__o1 = ((&str_obstack)); void *__value = (void *) __o1->object_base; if (__o1->next_free == __value) __o1->maybe_empty_object = 1; __o1->next_free = ((sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (((__o1->next_free) - (sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (__o1->alignment_mask)) & ~(__o1->alignment_mask))); if ((size_t) (__o1->next_free - (char *) __o1->chunk) > (size_t) (__o1->chunk_limit - (char *) __o1->chunk)) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; __value; }));
  str = xstrdup (rawstr);
  __extension__ ({ struct obstack *__o = (&str_obstack); void *__obj = (void *) (nullptr); if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit) __o->next_free = __o->object_base = (char *) __obj; else _obstack_free (__o, __obj); });
  do {if (do_debug) fprintf (
# 2133 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2133 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "matched replacement %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2133, str);} while (0);
  rawstr = nullptr;
  return str;
}







outf_p
get_output_file_with_visibility (input_file *inpf)
{
  outf_p r;
  char *for_name = nullptr;
  char *output_name = nullptr;
  const char* inpfname;




  if (inpf == nullptr)
    inpf = system_h_file;


  if (inpf->inpoutf)
    return inpf->inpoutf;



  if (plugin_files)
    {
      size_t i;
      for (i = 0; i < nb_plugin_files; i++)
 if (inpf == plugin_files[i])
   {
     inpf->inpoutf = plugin_output;
     return plugin_output;
   }

      return nullptr;
    }

  inpfname = get_input_file_name (inpf);


  {
    int rulix = 0;
    do {if (do_debug) fprintf (
# 2182 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
   stderr
# 2182 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
   , "%s:%d: " "passing input file @ %p named %s through the files_rules" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2182, (void*) inpf, inpfname);} while (0)
                               ;

    for (; files_rules[rulix].frul_srcexpr != nullptr; rulix++)
      {
 do {if (do_debug) fprintf (
# 2187 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
stderr
# 2187 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
, "%s:%d: " "rulix#%d srcexpr %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2187, rulix, files_rules[rulix].frul_srcexpr);} while (0)
                                            ;

 if (!files_rules[rulix].frul_re)
   {

     int err = 0;
     files_rules[rulix].frul_re = ((regex_t *) xcalloc (1, sizeof (regex_t)));
     err = xregcomp (files_rules[rulix].frul_re,
      files_rules[rulix].frul_srcexpr,
      files_rules[rulix].frul_rflags);
     if (err)
       {


  (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 2202, __FUNCTION__));
       }
   }

 output_name = nullptr;
 for_name = nullptr;


 {


   regmatch_t pmatch[10];
   memset (pmatch, 0, sizeof (pmatch));
   if (!xregexec (files_rules[rulix].frul_re,
   inpfname, 10, pmatch, 0))
     {
       do {if (do_debug) fprintf (
# 2218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
      stderr
# 2218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
      , "%s:%d: " "input @ %p filename %s matched rulix#%d pattern %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2218, (void*) inpf, inpfname, rulix, files_rules[rulix].frul_srcexpr);} while (0)

                                    ;
       for_name =
  matching_file_name_substitute (inpfname, pmatch,
            files_rules[rulix].frul_tr_for);
       do {if (do_debug) fprintf (
# 2224 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
      stderr
# 2224 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
      , "%s:%d: " "for_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2224, for_name);} while (0);
       output_name =
  matching_file_name_substitute (inpfname, pmatch,
            files_rules[rulix].frul_tr_out);
       do {if (do_debug) fprintf (
# 2228 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
      stderr
# 2228 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
      , "%s:%d: " "output_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2228, output_name);} while (0);
       if (files_rules[rulix].frul_action)
  {

    outf_p of = nullptr;
    do {if (do_debug) fprintf (
# 2233 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
   stderr
# 2233 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
   , "%s:%d: " "before action rulix#%d output_name %s for_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2233, rulix, output_name, for_name);} while (0)
                                     ;
    of =
      (files_rules[rulix].frul_action) (inpf,
            &output_name, &for_name);
    do {if (do_debug) fprintf (
# 2238 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
   stderr
# 2238 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
   , "%s:%d: " "after action rulix#%d of=%p output_name %s for_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2238, rulix, (void*)of, output_name, for_name);} while (0)
                                                ;


    if (of)
      {
        inpf->inpoutf = of;
        return of;
      }
  }




       break;
     }
   else
     {

       do {if (do_debug) fprintf (
# 2257 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
      stderr
# 2257 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
      , "%s:%d: " "rulix#%d did not match %s pattern %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2257, rulix, inpfname, files_rules[rulix].frul_srcexpr);} while (0)
                                                     ;
       continue;
     }
 }
      }
  }
  if (!output_name || !for_name)
    {


      fatal ("failed to compute output name for %s", inpfname);
    }



  for (r = output_files; r; r = r->next)
    if (filename_cmp (r->name, output_name) == 0)
      {
 inpf->inpoutf = r;
 do {if (do_debug) fprintf (
# 2277 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
stderr
# 2277 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
, "%s:%d: " "found r @ %p for output_name %s for_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2277, (void*)r, output_name, for_name);} while (0)
                           ;
 return r;
      }


  r = create_file (for_name, output_name);

  ((void)(!(r && r->name) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 2285, __FUNCTION__), 0 : 0));
  do {if (do_debug) fprintf (
# 2286 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 2286 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "created r @ %p for output_name %s for_name %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),2286, (void*) r, output_name, for_name);} while (0)
                            ;
  inpf->inpoutf = r;
  return r;


}





const char *
get_output_file_name (input_file* inpf)
{
  outf_p o = get_output_file_with_visibility (inpf);
  if (o)
    return o->name;
  return nullptr;
}



static bool
is_file_equal (outf_p of)
{
  FILE *newfile = fopen_unlocked (of->name, "r");
  size_t i;
  bool equal;
  if (newfile == nullptr)
    return false;

  equal = true;
  for (i = 0; i < of->bufused; i++)
    {
      int ch;
      ch = fgetc_unlocked (newfile);
      if (ch == 
# 2323 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
               (-1) 
# 2323 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                   || ch != (unsigned char) of->buf[i])
 {
   equal = false;
   break;
 }
    }
  if (equal && 
# 2329 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
              (-1) 
# 2329 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                  != fgetc_unlocked (newfile))
    equal = false;
  fclose (newfile);
  return equal;
}




static void
close_output_files (void)
{
  int nbwrittenfiles = 0;
  outf_p of;

  for (of = output_files; of; of = of->next)
    {
      if (!is_file_equal (of))
 {
   FILE *newfile = nullptr;
   char *backupname = nullptr;


   if (backup_dir)
     {
       backupname = concat (backup_dir, "/",
       lbasename (of->name), "~", nullptr);
       if (!access (of->name, 
# 2356 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                             0
# 2356 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                 ) && rename (of->name, backupname))
  fatal ("failed to back up %s as %s: %s",
         of->name, backupname, xstrerror (
# 2358 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                         (*__errno_location ())
# 2358 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                              ));
     }

   newfile = fopen_unlocked (of->name, "w");
   if (newfile == nullptr)
     fatal ("opening output file %s: %s", of->name, xstrerror (
# 2363 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                                              (*__errno_location ())
# 2363 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                                                   ));
   if (fwrite_unlocked (of->buf, 1, of->bufused, newfile) != of->bufused)
     fatal ("writing output file %s: %s", of->name, xstrerror (
# 2365 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                                              (*__errno_location ())
# 2365 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                                                   ));
   if (fclose (newfile) != 0)
     fatal ("closing output file %s: %s", of->name, xstrerror (
# 2367 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
                                                              (*__errno_location ())
# 2367 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                                                                   ));
   nbwrittenfiles++;
   if (verbosity_level >= 2 && backupname)
     printf ("%s wrote #%-3d %s backed-up in %s\n",
      progname, nbwrittenfiles, of->name, backupname);
   else if (verbosity_level >= 1)
     printf ("%s write #%-3d %s\n", progname, nbwrittenfiles, of->name);
   free (backupname);
 }
      else
 {

   if (verbosity_level >= 2)
     printf ("%s keep %s\n", progname, of->name);
 }
      free (of->buf);
      of->buf = nullptr;
      of->bufused = of->buflength = 0;
    }
  if (verbosity_level >= 1)
    printf ("%s wrote %d files.\n", progname, nbwrittenfiles);
}

struct flist
{
  struct flist *next;
  int started_p;
  const input_file* file;
  outf_p f;
};

struct walk_type_data;





typedef void (*process_field_fn) (type_p f, const struct walk_type_data * p);
typedef void (*func_name_fn) (type_p s, const struct walk_type_data * p);



struct write_types_data
{
  const char *prefix;
  const char *param_prefix;
  const char *subfield_marker_routine;
  const char *marker_routine;
  const char *reorder_note_routine;
  const char *comment;
  enum write_types_kinds kind;
};

static void output_escaped_param (struct walk_type_data *d,
      const char *, const char *);
static void output_mangled_typename (outf_p, const_type_p);
static void walk_type (type_p t, struct walk_type_data *d);
static void write_func_for_structure (type_p orig_s, type_p s,
          const struct write_types_data *wtd);
static void write_types_process_field
  (type_p f, const struct walk_type_data *d);
static void write_types (outf_p output_header,
    type_p structures,
    const struct write_types_data *wtd);
static void write_types_local_process_field
  (type_p f, const struct walk_type_data *d);
static void write_local_func_for_structure (const_type_p orig_s, type_p s);
static void write_local (outf_p output_header,
    type_p structures);
static int contains_scalar_p (type_p t);
static void put_mangled_filename (outf_p, const input_file *);
static void finish_root_table (struct flist *flp, const char *pfx,
          const char *tname, const char *lastname,
          const char *name);
static void write_root (outf_p, pair_p, type_p, const char *, int,
   struct fileloc *, bool);
static void write_array (outf_p f, pair_p v,
    const struct write_types_data *wtd);
static void write_roots (pair_p, bool);



struct walk_type_data
{
  process_field_fn process_field;
  const void *cookie;
  outf_p of;
  options_p opt;
  const char *val;
  const char *prev_val[4];
  int indent;
  int counter;
  const struct fileloc *line;
  lang_bitmap bitmap;
  int used_length;
  type_p orig_s;
  const char *reorder_fn;
  bool needs_cast_p;
  bool fn_wants_lvalue;
  bool in_record_p;
  int loopcounter;
  bool in_ptr_field;
  bool have_this_obj;
};
# 2483 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static const char *
filter_type_name (const char *type_name)
{
  if (strchr (type_name, '<') || strchr (type_name, ':'))
    {
      size_t i;
      char *s = xstrdup (type_name);
      for (i = 0; i < strlen (s); i++)
 if (s[i] == '<' || s[i] == '>' || s[i] == ':' || s[i] == ','
     || s[i] == '*')
   s[i] = '_';
      return s;
    }
  else
    return type_name;
}




static void
output_mangled_typename (outf_p of, const_type_p t)
{
  if (t == nullptr)
    oprintf (of, "Z");
  else
    switch (t->kind)
      {
      case TYPE_NONE:
      case TYPE_UNDEFINED:
 (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 2513, __FUNCTION__));
 break;
      case TYPE_POINTER:
 oprintf (of, "P");
 output_mangled_typename (of, t->u.p);
 break;
      case TYPE_SCALAR:
 oprintf (of, "I");
 break;
      case TYPE_STRING:
 oprintf (of, "S");
 break;
      case TYPE_STRUCT:
      case TYPE_UNION:
      case TYPE_LANG_STRUCT:
      case TYPE_USER_STRUCT:
 {



   t = get_ultimate_base_class (t);
   const char *id_for_tag = filter_type_name (t->u.s.tag);
   oprintf (of, "%lu%s", (unsigned long) strlen (id_for_tag),
     id_for_tag);
   if (id_for_tag != t->u.s.tag)
     free ((const_cast<char *> ((id_for_tag))));
 }
 break;
      case TYPE_ARRAY:
 (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 2542, __FUNCTION__));
      }
}






static void
output_escaped_param (struct walk_type_data *d, const char *param,
        const char *oname)
{
  const char *p;

  for (p = param; *p; p++)
    if (*p != '%')
      oprintf (d->of, "%c", *p);
    else
      switch (*++p)
 {
 case 'h':
   oprintf (d->of, "(%s)", d->prev_val[2]);
   break;
 case '0':
   oprintf (d->of, "(%s)", d->prev_val[0]);
   break;
 case '1':
   oprintf (d->of, "(%s)", d->prev_val[1]);
   break;
 case 'a':
   {
     const char *pp = d->val + strlen (d->val);
     while (pp[-1] == ']')
       while (*pp != '[')
  pp--;
     oprintf (d->of, "%s", pp);
   }
   break;
 default:
   error_at_line (d->line, "`%s' option contains bad escape %c%c",
    oname, '%', *p);
 }
}

const char *
get_string_option (options_p opt, const char *key)
{
  for (; opt; opt = opt->next)
    if (strcmp (opt->name, key) == 0)
      return opt->info.string;
  return nullptr;
}


struct seen_tag
{
  const char *tag;
  struct seen_tag *next;
};

int
already_seen_tag (struct seen_tag *seen_tags, const char *tag)
{

  while (seen_tags)
    {
      if (!strcmp (seen_tags->tag, tag))
 return 1;
      seen_tags = seen_tags->next;
    }

  return 0;
}

void
mark_tag_as_seen (struct seen_tag **seen_tags, const char *tag)
{

  struct seen_tag *new_node = ((struct seen_tag *) xcalloc (1, sizeof (struct seen_tag)));
  new_node->tag = tag;
  new_node->next = *seen_tags;
  *seen_tags = new_node;
}

static void
walk_subclasses (type_p base, struct walk_type_data *d,
   struct seen_tag **seen_tags)
{
  for (type_p sub = base->u.s.first_subclass; sub != nullptr;
       sub = sub->u.s.next_sibling_class)
    {
      const char *type_tag = get_string_option (sub->u.s.opt, "tag");
      if (type_tag && !already_seen_tag (*seen_tags, type_tag))
 {
   mark_tag_as_seen (seen_tags, type_tag);
   oprintf (d->of, "%*scase %s:\n", d->indent, "", type_tag);
   d->indent += 2;
   oprintf (d->of, "%*s{\n", d->indent, "");
   d->indent += 2;
   oprintf (d->of, "%*s%s *sub = static_cast <%s *> (x);\n",
     d->indent, "", sub->u.s.tag, sub->u.s.tag);
   const char *old_val = d->val;
   d->val = "(*sub)";
   walk_type (sub, d);
   d->val = old_val;
   d->indent -= 2;
   oprintf (d->of, "%*s}\n", d->indent, "");
   oprintf (d->of, "%*sbreak;\n", d->indent, "");
   d->indent -= 2;
 }
      walk_subclasses (sub, d, seen_tags);
    }
}
# 2667 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
walk_type (type_p t, struct walk_type_data *d)
{
  const char *length = nullptr;
  const char *desc = nullptr;
  const char *type_tag = nullptr;
  int maybe_undef_p = 0;
  int atomic_p = 0;
  options_p oo;
  const struct nested_ptr_data *nested_ptr_d = nullptr;

  d->needs_cast_p = false;
  for (oo = d->opt; oo; oo = oo->next)
    if (strcmp (oo->name, "length") == 0 && oo->kind == OPTION_STRING)
      length = oo->info.string;
    else if (strcmp (oo->name, "maybe_undef") == 0)
      maybe_undef_p = 1;
    else if (strcmp (oo->name, "desc") == 0 && oo->kind == OPTION_STRING)
      desc = oo->info.string;
    else if (strcmp (oo->name, "nested_ptr") == 0
      && oo->kind == OPTION_NESTED)
      nested_ptr_d = (const struct nested_ptr_data *) oo->info.nested;
    else if (strcmp (oo->name, "dot") == 0)
      ;
    else if (strcmp (oo->name, "tag") == 0)
      type_tag = oo->info.string;
    else if (strcmp (oo->name, "special") == 0)
      ;
    else if (strcmp (oo->name, "skip") == 0)
      ;
    else if (strcmp (oo->name, "atomic") == 0)
      atomic_p = 1;
    else if (strcmp (oo->name, "default") == 0)
      ;
    else if (strcmp (oo->name, "chain_next") == 0)
      ;
    else if (strcmp (oo->name, "chain_prev") == 0)
      ;
    else if (strcmp (oo->name, "chain_circular") == 0)
      ;
    else if (strcmp (oo->name, "reorder") == 0)
      ;
    else if (strcmp (oo->name, "variable_size") == 0)
      ;
    else if (strcmp (oo->name, "for_user") == 0)
      ;
    else
      error_at_line (d->line, "unknown option `%s'\n", oo->name);

  if (d->used_length)
    length = nullptr;

  if (maybe_undef_p
      && (t->kind != TYPE_POINTER || !union_or_struct_p (t->u.p)))
    {
      error_at_line (d->line,
       "field `%s' has invalid option `maybe_undef_p'\n",
       d->val);
      return;
    }

  if (atomic_p && (t->kind != TYPE_POINTER) && (t->kind != TYPE_STRING))
    {
      error_at_line (d->line, "field `%s' has invalid option `atomic'\n", d->val);
      return;
    }

  switch (t->kind)
    {
    case TYPE_SCALAR:
    case TYPE_STRING:
      d->process_field (t, d);
      break;

    case TYPE_POINTER:
      {
 d->in_ptr_field = true;
 if (maybe_undef_p && t->u.p->u.s.line.file == nullptr)
   {
     oprintf (d->of, "%*sgcc_assert (!%s);\n", d->indent, "", d->val);
     break;
   }
# 2759 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 if (atomic_p)
   {
     oprintf (d->of, "%*sif (%s != NULL) {\n", d->indent, "", d->val);
     d->indent += 2;
     d->process_field (t, d);
     d->indent -= 2;
     oprintf (d->of, "%*s}\n", d->indent, "");
     break;
   }

 if (!length)
   {
     if (!union_or_struct_p (t->u.p))
       {
  error_at_line (d->line,
          "field `%s' is pointer to unimplemented type",
          d->val);
  break;
       }

     if (nested_ptr_d)
       {
  const char *oldprevval2 = d->prev_val[2];

  if (!union_or_struct_p (nested_ptr_d->type))
    {
      error_at_line (d->line,
       "field `%s' has invalid "
       "option `nested_ptr'\n", d->val);
      return;
    }

  d->prev_val[2] = d->val;
  oprintf (d->of, "%*s{\n", d->indent, "");
  d->indent += 2;
  d->val = xasprintf ("x%d", d->counter++);
  oprintf (d->of, "%*s%s %s * %s%s =\n", d->indent, "",
    (nested_ptr_d->type->kind == TYPE_UNION
     ? "union" : "struct"),
    nested_ptr_d->type->u.s.tag,
    d->fn_wants_lvalue ? "" : "const ", d->val);
  oprintf (d->of, "%*s", d->indent + 2, "");
  output_escaped_param (d, nested_ptr_d->convert_from,
          "nested_ptr");
  oprintf (d->of, ";\n");

  d->process_field (nested_ptr_d->type, d);

  if (d->fn_wants_lvalue)
    {
      oprintf (d->of, "%*s%s = ", d->indent, "",
        d->prev_val[2]);
      d->prev_val[2] = d->val;
      output_escaped_param (d, nested_ptr_d->convert_to,
       "nested_ptr");
      oprintf (d->of, ";\n");
    }

  d->indent -= 2;
  oprintf (d->of, "%*s}\n", d->indent, "");
  d->val = d->prev_val[2];
  d->prev_val[2] = oldprevval2;
       }
     else
       d->process_field (t->u.p, d);
   }
 else
   {
     int loopcounter = d->loopcounter;
     const char *oldval = d->val;
     const char *oldprevval3 = d->prev_val[3];
     char *newval;

     oprintf (d->of, "%*sif (%s != NULL) {\n", d->indent, "", d->val);
     d->indent += 2;
     oprintf (d->of, "%*ssize_t i%d;\n", d->indent, "", loopcounter);
     oprintf (d->of, "%*sfor (i%d = 0; i%d != (size_t)(", d->indent,
       "", loopcounter, loopcounter);
     if (!d->in_record_p)
       output_escaped_param (d, length, "length");
     else
       oprintf (d->of, "l%d", loopcounter);
     if (d->have_this_obj)

       oprintf (d->of, ") && ((void *)%s == this_obj", oldval);
     oprintf (d->of, "); i%d++) {\n", loopcounter);
     d->indent += 2;
     d->val = newval = xasprintf ("%s[i%d]", oldval, loopcounter);
     d->used_length = 1;
     d->prev_val[3] = oldval;
     walk_type (t->u.p, d);
     free (newval);
     d->val = oldval;
     d->prev_val[3] = oldprevval3;
     d->used_length = 0;
     d->indent -= 2;
     oprintf (d->of, "%*s}\n", d->indent, "");
     d->process_field (t, d);
     d->indent -= 2;
     oprintf (d->of, "%*s}\n", d->indent, "");
   }
 d->in_ptr_field = false;
      }
      break;

    case TYPE_ARRAY:
      {
 int loopcounter;
 const char *oldval = d->val;
 char *newval;



 if (t->u.a.p->kind == TYPE_SCALAR)
   break;

 if (length)
   loopcounter = d->loopcounter;
 else
   loopcounter = d->counter++;
# 2887 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 oprintf (d->of, "%*s{\n", d->indent, "");
 d->indent += 2;
 oprintf (d->of, "%*ssize_t i%d;\n", d->indent, "", loopcounter);
 if (!d->in_record_p || !length)
   {
     oprintf (d->of, "%*ssize_t l%d = (size_t)(",
       d->indent, "", loopcounter);
     if (length)
       output_escaped_param (d, length, "length");
     else
       oprintf (d->of, "%s", t->u.a.len);
     oprintf (d->of, ");\n");
   }

 oprintf (d->of, "%*sfor (i%d = 0; i%d != l%d; i%d++) {\n",
   d->indent, "",
   loopcounter, loopcounter, loopcounter, loopcounter);
 d->indent += 2;
 d->val = newval = xasprintf ("%s[i%d]", oldval, loopcounter);
 d->used_length = 1;
 walk_type (t->u.a.p, d);
 free (newval);
 d->used_length = 0;
 d->val = oldval;
 d->indent -= 2;
 oprintf (d->of, "%*s}\n", d->indent, "");
 d->indent -= 2;
 oprintf (d->of, "%*s}\n", d->indent, "");
      }
      break;

    case TYPE_STRUCT:
    case TYPE_UNION:
      {
 pair_p f;
 const char *oldval = d->val;
 const char *oldprevval1 = d->prev_val[1];
 const char *oldprevval2 = d->prev_val[2];
 const int union_p = t->kind == TYPE_UNION;
 int seen_default_p = 0;
 options_p o;
 int lengths_seen = 0;
 int endcounter;
 bool any_length_seen = false;

 if (!t->u.s.line.file)
   error_at_line (d->line, "incomplete structure `%s'", t->u.s.tag);

 if ((d->bitmap & t->u.s.bitmap) != d->bitmap)
   {
     error_at_line (d->line,
      "structure `%s' defined for mismatching languages",
      t->u.s.tag);
     error_at_line (&t->u.s.line, "one structure defined here");
   }


 for (o = t->u.s.opt; o; o = o->next)
   if (!desc && strcmp (o->name, "desc") == 0
       && o->kind == OPTION_STRING)
     desc = o->info.string;

 d->prev_val[2] = oldval;
 d->prev_val[1] = oldprevval2;
 if (union_p)
   {
     if (desc == nullptr)
       {
  error_at_line (d->line,
          "missing `desc' option for union `%s'",
          t->u.s.tag);
  desc = "1";
       }
     oprintf (d->of, "%*sswitch ((int) (", d->indent, "");
     output_escaped_param (d, desc, "desc");
     oprintf (d->of, "))\n");
     d->indent += 2;
     oprintf (d->of, "%*s{\n", d->indent, "");
   }
 else if (desc)
   {
# 2976 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     if (!type_tag)
       {
  error_at_line (d->line,
          "missing `tag' option for type `%s'",
          t->u.s.tag);
       }
     oprintf (d->of, "%*sswitch ((int) (", d->indent, "");
     output_escaped_param (d, desc, "desc");
     oprintf (d->of, "))\n");
     d->indent += 2;
     oprintf (d->of, "%*s{\n", d->indent, "");
     oprintf (d->of, "%*scase %s:\n", d->indent, "", type_tag);
     d->indent += 2;
   }

 for (type_p sub = (t); sub; sub = sub->u.s.base_class) for (f = sub->u.s.fields; f; f = f->next)
   {
     options_p oo;
     int skip_p = 0;
     const char *fieldlength = nullptr;

     d->reorder_fn = nullptr;
     for (oo = f->opt; oo; oo = oo->next)
       if (strcmp (oo->name, "skip") == 0)
  skip_p = 1;
       else if (strcmp (oo->name, "length") == 0
         && oo->kind == OPTION_STRING)
  fieldlength = oo->info.string;

     if (skip_p)
       continue;
     if (fieldlength)
       {
         lengths_seen++;
  d->counter++;
  if (!union_p)
    {
      if (!any_length_seen)
        {
   oprintf (d->of, "%*s{\n", d->indent, "");
   d->indent += 2;
        }
      any_length_seen = true;

      oprintf (d->of, "%*ssize_t l%d = (size_t)(",
        d->indent, "", d->counter - 1);
      output_escaped_param (d, fieldlength, "length");
      oprintf (d->of, ");\n");
    }
       }
   }
 endcounter = d->counter;

 for (type_p sub = (t); sub; sub = sub->u.s.base_class) for (f = sub->u.s.fields; f; f = f->next)
   {
     options_p oo;
     const char *dot = ".";
     const char *tagid = nullptr;
     int skip_p = 0;
     int default_p = 0;
     const char *fieldlength = nullptr;
     char *newval;

     d->reorder_fn = nullptr;
     for (oo = f->opt; oo; oo = oo->next)
       if (strcmp (oo->name, "dot") == 0
    && oo->kind == OPTION_STRING)
  dot = oo->info.string;
       else if (strcmp (oo->name, "tag") == 0
         && oo->kind == OPTION_STRING)
  tagid = oo->info.string;
       else if (strcmp (oo->name, "skip") == 0)
  skip_p = 1;
       else if (strcmp (oo->name, "default") == 0)
  default_p = 1;
       else if (strcmp (oo->name, "reorder") == 0
    && oo->kind == OPTION_STRING)
  d->reorder_fn = oo->info.string;
       else if (strcmp (oo->name, "length") == 0
         && oo->kind == OPTION_STRING)
  fieldlength = oo->info.string;

     if (skip_p)
       continue;

     if (union_p && tagid)
       {
  oprintf (d->of, "%*scase %s:\n", d->indent, "", tagid);
  d->indent += 2;
       }
     else if (union_p && default_p)
       {
  oprintf (d->of, "%*sdefault:\n", d->indent, "");
  d->indent += 2;
  seen_default_p = 1;
       }
     else if (!union_p && (default_p || tagid))
       error_at_line (d->line,
        "can't use `%s' outside a union on field `%s'",
        default_p ? "default" : "tag", f->name);
     else if (union_p && !(default_p || tagid)
       && f->type->kind == TYPE_SCALAR)
       {
  fprintf (
# 3079 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
          stderr
# 3079 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                ,
    "%s:%d: warning: field `%s' is missing `tag' or `default' option\n",
    get_input_file_name (d->line->file), d->line->line,
    f->name);
  continue;
       }
     else if (union_p && !(default_p || tagid))
       error_at_line (d->line,
        "field `%s' is missing `tag' or `default' option",
        f->name);

     if (fieldlength)
       {
  d->loopcounter = endcounter - lengths_seen--;
       }

     d->line = &f->line;
     d->val = newval = xasprintf ("%s%s%s", oldval, dot, f->name);
     d->opt = f->opt;
     d->used_length = false;
     d->in_record_p = !union_p;

     walk_type (f->type, d);

     d->in_record_p = false;

     free (newval);

     if (union_p)
       {
  oprintf (d->of, "%*sbreak;\n", d->indent, "");
  d->indent -= 2;
       }
   }
 d->reorder_fn = nullptr;

 d->val = oldval;
 d->prev_val[1] = oldprevval1;
 d->prev_val[2] = oldprevval2;

 if (union_p && !seen_default_p)
   {
     oprintf (d->of, "%*sdefault:\n", d->indent, "");
     oprintf (d->of, "%*s  break;\n", d->indent, "");
   }

 if (desc && !union_p)
   {
  oprintf (d->of, "%*sbreak;\n", d->indent, "");
  d->indent -= 2;
          }
 if (union_p)
   {
     oprintf (d->of, "%*s}\n", d->indent, "");
     d->indent -= 2;
   }
 else if (desc)
   {

     struct seen_tag *tags = nullptr;
     walk_subclasses (t, d, &tags);



     if (!seen_default_p)
       {
  oprintf (d->of, "%*s/* Unrecognized tag value.  */\n",
    d->indent, "");
  oprintf (d->of, "%*sdefault: gcc_unreachable (); \n",
    d->indent, "");
       }


     oprintf (d->of, "%*s}\n", d->indent, "");
     d->indent -= 2;
   }
 if (any_length_seen)
   {
     d->indent -= 2;
     oprintf (d->of, "%*s}\n", d->indent, "");
   }
      }
      break;

    case TYPE_LANG_STRUCT:
      {
 type_p nt;
 for (nt = t->u.s.lang_struct; nt; nt = nt->next)
   if ((d->bitmap & nt->u.s.bitmap) == d->bitmap)
     break;
 if (nt == nullptr)
   error_at_line (d->line, "structure `%s' differs between languages",
    t->u.s.tag);
 else
   walk_type (nt, d);
      }
      break;

    case TYPE_USER_STRUCT:
      d->process_field (t, d);
      break;

    case TYPE_NONE:
    case TYPE_UNDEFINED:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3183, __FUNCTION__));
    }
}



static void
write_types_process_field (type_p f, const struct walk_type_data *d)
{
  const struct write_types_data *wtd;
  const char *cast = d->needs_cast_p ? "(void *)" : "";
  wtd = (const struct write_types_data *) d->cookie;

  switch (f->kind)
    {
    case TYPE_NONE:
    case TYPE_UNDEFINED:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3200, __FUNCTION__));
    case TYPE_POINTER:
      oprintf (d->of, "%*s%s (%s%s", d->indent, "",
        wtd->subfield_marker_routine, cast, d->val);
      if (wtd->param_prefix)
 {
   if (f->u.p->kind == TYPE_SCALAR)
# 3223 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     oprintf (d->of, ", x");
   else
     oprintf (d->of, ", %s", d->prev_val[3]);
   if (d->orig_s)
     {
       oprintf (d->of, ", gt_%s_", wtd->param_prefix);
       output_mangled_typename (d->of, d->orig_s);
     }
   else
     oprintf (d->of, ", gt_%sa_%s", wtd->param_prefix, d->prev_val[0]);
 }
      oprintf (d->of, ");\n");
      if (d->reorder_fn && wtd->reorder_note_routine)
 oprintf (d->of, "%*s%s (%s%s, %s, %s);\n", d->indent, "",
   wtd->reorder_note_routine, cast, d->val,
   d->prev_val[3], d->reorder_fn);
      break;

    case TYPE_STRING:
    case TYPE_STRUCT:
    case TYPE_UNION:
    case TYPE_LANG_STRUCT:
    case TYPE_USER_STRUCT:
      if (f->kind == TYPE_USER_STRUCT && !d->in_ptr_field)
 {





   oprintf (d->of, "%*sgt_%sx (&(%s));\n", d->indent, "", wtd->prefix,
     d->val);
 }
      else
 {
   oprintf (d->of, "%*sgt_%s_", d->indent, "", wtd->prefix);
   output_mangled_typename (d->of, f);
   oprintf (d->of, " (%s%s);\n", cast, d->val);
   if (d->reorder_fn && wtd->reorder_note_routine)
     oprintf (d->of, "%*s%s (%s%s, %s%s, %s);\n", d->indent, "",
       wtd->reorder_note_routine, cast, d->val, cast, d->val,
       d->reorder_fn);
 }
      break;

    case TYPE_SCALAR:
      break;

    case TYPE_ARRAY:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3272, __FUNCTION__));
    }
}




static outf_p
get_output_file_for_structure (const_type_p s)
{
  const input_file *fn;

  ((void)(!(union_or_struct_p (s)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3284, __FUNCTION__), 0 : 0));
  fn = s->u.s.line.file;



  return get_output_file_with_visibility ((const_cast<input_file*> ((fn))));
}





static const char *
get_type_specifier (const type_p s)
{
  if (s->kind == TYPE_STRUCT)
    return "struct ";
  else if (s->kind == TYPE_LANG_STRUCT)
    return get_type_specifier (s->u.s.lang_struct);
  else if (s->kind == TYPE_UNION)
    return "union ";
  return "";
}





static void
write_type_decl (outf_p out, type_p ty)
{
  if (union_or_struct_p (ty))
    oprintf (out, "%s%s", get_type_specifier (ty), ty->u.s.tag);
  else if (ty->kind == TYPE_SCALAR)
    {
      if (ty->u.scalar_is_char)
 oprintf (out, "const char");
      else
 oprintf (out, "void");
    }
  else if (ty->kind == TYPE_POINTER)
    {
      write_type_decl (out, ty->u.p);
      oprintf (out, " *");
    }
  else if (ty->kind == TYPE_ARRAY)
    {
      write_type_decl (out, ty->u.a.p);
      oprintf (out, " *");
    }
  else if (ty->kind == TYPE_STRING)
    {
      oprintf (out, "const char *");
    }
  else
    (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3339, __FUNCTION__));
}





static void
write_marker_function_name (outf_p of, type_p s, const char *prefix)
{
  if (union_or_struct_p (s))
    {
      const char *id_for_tag = filter_type_name (s->u.s.tag);
      oprintf (of, "gt_%sx_%s", prefix, id_for_tag);
      if (id_for_tag != s->u.s.tag)
 free ((const_cast<char *> ((id_for_tag))));
    }
  else
    (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3357, __FUNCTION__));
}





static void
write_user_func_for_structure_ptr (outf_p of, type_p s, const write_types_data *wtd)
{
  ((void)(!(union_or_struct_p (s)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3367, __FUNCTION__), 0 : 0));

  type_p alias_of = nullptr;
  for (options_p opt = s->u.s.opt; opt; opt = opt->next)
    if (strcmp (opt->name, "ptr_alias") == 0)
      {
# 3381 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 alias_of = opt->info.type;
 break;
      }

  do {if (do_debug) fprintf (
# 3385 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 3385 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "write_user_func_for_structure_ptr: %s %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),3385, s->u.s.tag, wtd->prefix);} while (0)
                  ;


  if (s->u.s.wrote_user_func_for_ptr[wtd->kind])
    return;
  s->u.s.wrote_user_func_for_ptr[wtd->kind] = true;

  oprintf (of, "\nvoid\n");
  oprintf (of, "gt_%sx (", wtd->prefix);
  write_type_decl (of, s);
  oprintf (of, " *& x)\n");
  oprintf (of, "{\n");
  oprintf (of, "  if (x)\n    ");
  write_marker_function_name (of,
         alias_of ? alias_of : get_ultimate_base_class (s),
         wtd->prefix);
  oprintf (of, " ((void *) x);\n");
  oprintf (of, "}\n");
}





static void
write_user_func_for_structure_body (type_p s, const char *prefix,
        struct walk_type_data *d)
{
  oprintf (d->of, "\nvoid\n");
  oprintf (d->of, "gt_%sx (", prefix);
  write_type_decl (d->of, s);
  oprintf (d->of, "& x_r ATTRIBUTE_UNUSED)\n");
  oprintf (d->of, "{\n");
  oprintf (d->of, "  ");
  write_type_decl (d->of, s);
  oprintf (d->of, " * ATTRIBUTE_UNUSED x = &x_r;\n");
  d->val = "(*x)";
  d->indent = 2;
  walk_type (s, d);
  oprintf (d->of, "}\n");
}
# 3437 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_user_marking_functions (type_p s,
         const write_types_data *w,
         struct walk_type_data *d)
{
  ((void)(!(s->kind == TYPE_USER_STRUCT) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3442, __FUNCTION__), 0 : 0));

  for (pair_p fld = s->u.s.fields; fld; fld = fld->next)
    {
      type_p fld_type = fld->type;
      if (fld_type->kind == TYPE_POINTER)
 {
   type_p pointed_to_type = fld_type->u.p;
   if (union_or_struct_p (pointed_to_type))
     write_user_func_for_structure_ptr (d->of, pointed_to_type, w);
 }
      else if (union_or_struct_p (fld_type))
 write_user_func_for_structure_body (fld_type, w->prefix, d);
    }
}
# 3465 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_func_for_structure (type_p orig_s, type_p s,
     const struct write_types_data *wtd)
{
  const char *chain_next = nullptr;
  const char *chain_prev = nullptr;
  const char *chain_circular = nullptr;
  options_p opt;
  struct walk_type_data d;

  if (s->u.s.base_class)
    {



      const_type_p ubc = get_ultimate_base_class (s);
      if ((!opts_have (ubc->u.s.opt, "user")
    && !opts_have (ubc->u.s.opt, "desc")))
 error_at_line (&s->u.s.line,
         ("'%s' is a subclass of non-GTY(user) GTY class '%s'"
   ", but '%s' lacks a discriminator 'desc' option"),
         s->u.s.tag, ubc->u.s.tag, ubc->u.s.tag);



      return;
    }

  memset (&d, 0, sizeof (d));
  d.of = get_output_file_for_structure (s);

  bool for_user = false;
  for (opt = s->u.s.opt; opt; opt = opt->next)
    if (strcmp (opt->name, "chain_next") == 0
 && opt->kind == OPTION_STRING)
      chain_next = opt->info.string;
    else if (strcmp (opt->name, "chain_prev") == 0
      && opt->kind == OPTION_STRING)
      chain_prev = opt->info.string;
    else if (strcmp (opt->name, "chain_circular") == 0
      && opt->kind == OPTION_STRING)
      chain_circular = opt->info.string;
    else if (strcmp (opt->name, "for_user") == 0)
      for_user = true;
  if (chain_prev != nullptr && chain_next == nullptr)
    error_at_line (&s->u.s.line, "chain_prev without chain_next");
  if (chain_circular != nullptr && chain_next != nullptr)
    error_at_line (&s->u.s.line, "chain_circular with chain_next");
  if (chain_circular != nullptr)
    chain_next = chain_circular;

  d.process_field = write_types_process_field;
  d.cookie = wtd;
  d.orig_s = orig_s;
  d.opt = s->u.s.opt;
  d.line = &s->u.s.line;
  d.bitmap = s->u.s.bitmap;
  d.prev_val[0] = "*x";
  d.prev_val[1] = "not valid postage";
  d.prev_val[3] = "x";
  d.val = "(*x)";
  d.have_this_obj = false;

  oprintf (d.of, "\n");
  oprintf (d.of, "void\n");
  write_marker_function_name (d.of, orig_s, wtd->prefix);
  oprintf (d.of, " (void *x_p)\n");
  oprintf (d.of, "{\n  ");
  write_type_decl (d.of, s);
  oprintf (d.of, " * %sx = (", chain_next == nullptr ? "const " : "");
  write_type_decl (d.of, s);
  oprintf (d.of, " *)x_p;\n");
  if (chain_next != nullptr)
    {


      ((void)(!(orig_s->kind != TYPE_USER_STRUCT) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3541, __FUNCTION__), 0 : 0));

      oprintf (d.of, "  ");
      write_type_decl (d.of, s);
      oprintf (d.of, " * xlimit = x;\n");
    }
  if (chain_next == nullptr)
    {
      oprintf (d.of, "  if (%s (x", wtd->marker_routine);
      if (wtd->param_prefix)
 {
   oprintf (d.of, ", x, gt_%s_", wtd->param_prefix);
   output_mangled_typename (d.of, orig_s);
 }
      oprintf (d.of, "))\n");
    }
  else
    {
      if (chain_circular != nullptr)
 oprintf (d.of, "  if (!%s (xlimit", wtd->marker_routine);
      else
 oprintf (d.of, "  while (%s (xlimit", wtd->marker_routine);
      if (wtd->param_prefix)
 {
   oprintf (d.of, ", xlimit, gt_%s_", wtd->param_prefix);
   output_mangled_typename (d.of, orig_s);
 }
      oprintf (d.of, "))\n");
      if (chain_circular != nullptr)
 oprintf (d.of, "    return;\n  do\n");

      oprintf (d.of, "   xlimit = (");
      d.prev_val[2] = "*xlimit";
      output_escaped_param (&d, chain_next, "chain_next");
      oprintf (d.of, ");\n");
      if (chain_prev != nullptr)
 {
   oprintf (d.of, "  if (x != xlimit)\n");
   oprintf (d.of, "    for (;;)\n");
   oprintf (d.of, "      {\n");
   oprintf (d.of, "        %s %s * const xprev = (",
     s->kind == TYPE_UNION ? "union" : "struct", s->u.s.tag);

   d.prev_val[2] = "*x";
   output_escaped_param (&d, chain_prev, "chain_prev");
   oprintf (d.of, ");\n");
   oprintf (d.of, "        if (xprev == NULL) break;\n");
   oprintf (d.of, "        x = xprev;\n");
   oprintf (d.of, "        (void) %s (xprev", wtd->marker_routine);
   if (wtd->param_prefix)
     {
       oprintf (d.of, ", xprev, gt_%s_", wtd->param_prefix);
       output_mangled_typename (d.of, orig_s);
     }
   oprintf (d.of, ");\n");
   oprintf (d.of, "      }\n");
 }
      if (chain_circular != nullptr)
 {
   oprintf (d.of, "  while (%s (xlimit", wtd->marker_routine);
   if (wtd->param_prefix)
     {
       oprintf (d.of, ", xlimit, gt_%s_", wtd->param_prefix);
       output_mangled_typename (d.of, orig_s);
     }
   oprintf (d.of, "));\n");
   oprintf (d.of, "  do\n");
 }
      else
 oprintf (d.of, "  while (x != xlimit)\n");
    }
  oprintf (d.of, "    {\n");

  d.prev_val[2] = "*x";
  d.indent = 6;
  if (orig_s->kind != TYPE_USER_STRUCT)
    walk_type (s, &d);
  else
    {


      oprintf (d.of, "%*sgt_%sx (x);\n", d.indent, "", wtd->prefix);
    }

  if (chain_next != nullptr)
    {
      oprintf (d.of, "      x = (");
      output_escaped_param (&d, chain_next, "chain_next");
      oprintf (d.of, ");\n");
    }

  oprintf (d.of, "    }\n");
  if (chain_circular != nullptr)
    oprintf (d.of, "  while (x != xlimit);\n");
  oprintf (d.of, "}\n");

  if (orig_s->kind == TYPE_USER_STRUCT)
    write_user_marking_functions (orig_s, wtd, &d);

  if (for_user)
    {
      write_user_func_for_structure_body (orig_s, wtd->prefix, &d);
      write_user_func_for_structure_ptr (d.of, orig_s, wtd);
    }
}




static void
write_types (outf_p output_header, type_p structures,
      const struct write_types_data *wtd)
{
  int nbfun = 0;
  type_p s;

  oprintf (output_header, "\n/* %s*/\n", wtd->comment);



  oprintf (output_header, "/* Macros and declarations.  */\n");
  for (s = structures; s; s = s->next)


    if ((s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)
        && !s->u.s.base_class)
      {
 options_p opt;

 if (s->gc_used == GC_MAYBE_POINTED_TO && s->u.s.line.file == nullptr)
   continue;

 const char *s_id_for_tag = filter_type_name (s->u.s.tag);

 oprintf (output_header, "#define gt_%s_", wtd->prefix);
 output_mangled_typename (output_header, s);
 oprintf (output_header, "(X) do { \\\n");
 oprintf (output_header,
   "  if (X != NULL) gt_%sx_%s (X);\\\n", wtd->prefix,
   s_id_for_tag);
 oprintf (output_header, "  } while (0)\n");

 for (opt = s->u.s.opt; opt; opt = opt->next)
   if (strcmp (opt->name, "ptr_alias") == 0
       && opt->kind == OPTION_TYPE)
     {
       const_type_p const t = (const_type_p) opt->info.type;
       if (t->kind == TYPE_STRUCT
    || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)
  {
    const char *t_id_for_tag = filter_type_name (t->u.s.tag);
    oprintf (output_header,
      "#define gt_%sx_%s gt_%sx_%s\n",
      wtd->prefix, s->u.s.tag, wtd->prefix, t_id_for_tag);
    if (t_id_for_tag != t->u.s.tag)
      free ((const_cast<char *> ((t_id_for_tag))));
  }
       else
  error_at_line (&s->u.s.line,
          "structure alias is not a structure");
       break;
     }
 if (opt)
   continue;


 oprintf (output_header,
   "extern void gt_%sx_%s (void *);\n",
   wtd->prefix, s_id_for_tag);

 if (s_id_for_tag != s->u.s.tag)
   free ((const_cast<char *> ((s_id_for_tag))));

 if (s->u.s.line.file == nullptr)
   {
     fprintf (
# 3716 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
             stderr
# 3716 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                   , "warning: structure `%s' used but not defined\n",
       s->u.s.tag);
     continue;
   }
      }


  oprintf (output_header, "\n/* functions code */\n");
  for (s = structures; s; s = s->next)
    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)
      {
 options_p opt;

 if (s->gc_used == GC_MAYBE_POINTED_TO && s->u.s.line.file == nullptr)
   continue;
 for (opt = s->u.s.opt; opt; opt = opt->next)
   if (strcmp (opt->name, "ptr_alias") == 0)
     break;
 if (opt)
   continue;

 if (s->kind == TYPE_LANG_STRUCT)
   {
     type_p ss;
     for (ss = s->u.s.lang_struct; ss; ss = ss->next)
       {
  nbfun++;
  do {if (do_debug) fprintf (
# 3743 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 3743 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "writing func #%d lang_struct ss @ %p '%s'" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),3743, nbfun, (void*) ss, ss->u.s.tag);} while (0)
                                     ;
  write_func_for_structure (s, ss, wtd);
       }
   }
 else
   {
     nbfun++;
     do {if (do_debug) fprintf (
# 3751 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
    stderr
# 3751 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
    , "%s:%d: " "writing func #%d struct s @ %p '%s'" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),3751, nbfun, (void*) s, s->u.s.tag);} while (0)
                                      ;
     write_func_for_structure (s, s, wtd);
   }
      }
    else
      {

 do {if (do_debug) fprintf (
# 3759 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
stderr
# 3759 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
, "%s:%d: " "ignored s @ %p  '%s' gc_used#%d" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),3759, (void*)s, s->u.s.tag, (int) s->gc_used);} while (0)

                      ;
      }

  if (verbosity_level >= 2)
    printf ("%s emitted %d routines for %s\n",
     progname, nbfun, wtd->comment);
}

static const struct write_types_data ggc_wtd = {
  "ggc_m", nullptr, "ggc_mark", "ggc_test_and_set_mark", nullptr,
  "GC marker procedures.  ",
  WTK_GGC
};

static const struct write_types_data pch_wtd = {
  "pch_n", "pch_p", "gt_pch_note_object", "gt_pch_note_object",
  "gt_pch_note_reorder",
  "PCH type-walking procedures.  ",
  WTK_PCH
};
# 3792 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_types_local_user_process_field (type_p f, const struct walk_type_data *d)
{
  switch (f->kind)
    {
    case TYPE_POINTER:
    case TYPE_STRUCT:
    case TYPE_UNION:
    case TYPE_LANG_STRUCT:
    case TYPE_STRING:
      oprintf (d->of, "%*s  op (&(%s), cookie);\n", d->indent, "", d->val);
      break;

    case TYPE_USER_STRUCT:
      if (d->in_ptr_field)
 oprintf (d->of, "%*s  op (&(%s), cookie);\n", d->indent, "", d->val);
      else
 oprintf (d->of, "%*s  gt_pch_nx (&(%s), op, cookie);\n",
   d->indent, "", d->val);
      break;

    case TYPE_SCALAR:
      break;

    case TYPE_ARRAY:
    case TYPE_NONE:
    case TYPE_UNDEFINED:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3819, __FUNCTION__));
    }
}





static void
write_pch_user_walking_for_structure_body (type_p s, struct walk_type_data *d)
{
  oprintf (d->of, "\nvoid\n");
  oprintf (d->of, "gt_pch_nx (");
  write_type_decl (d->of, s);
  oprintf (d->of, "* x ATTRIBUTE_UNUSED,\n"
    "\tATTRIBUTE_UNUSED gt_pointer_operator op,\n"
    "\tATTRIBUTE_UNUSED void *cookie)\n");
  oprintf (d->of, "{\n");
  d->val = "(*x)";
  d->indent = 2;
  d->process_field = write_types_local_user_process_field;
  walk_type (s, d);
  oprintf (d->of, "}\n");
}
# 3855 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_pch_user_walking_functions (type_p s, struct walk_type_data *d)
{
  ((void)(!(s->kind == TYPE_USER_STRUCT) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3858, __FUNCTION__), 0 : 0));

  for (pair_p fld = s->u.s.fields; fld; fld = fld->next)
    {
      type_p fld_type = fld->type;
      if (union_or_struct_p (fld_type))
 write_pch_user_walking_for_structure_body (fld_type, d);
    }
}




static void
write_types_local_process_field (type_p f, const struct walk_type_data *d)
{
  ((void)(!(d->have_this_obj) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3874, __FUNCTION__), 0 : 0));
  switch (f->kind)
    {
    case TYPE_POINTER:
    case TYPE_STRUCT:
    case TYPE_UNION:
    case TYPE_LANG_STRUCT:
    case TYPE_STRING:
      oprintf (d->of, "%*sif ((void *)(%s) == this_obj)\n", d->indent, "",
        d->prev_val[3]);
      oprintf (d->of, "%*s  op (&(%s), cookie);\n", d->indent, "", d->val);
      break;

    case TYPE_USER_STRUCT:
      oprintf (d->of, "%*sif ((void *)(%s) == this_obj)\n", d->indent, "",
        d->prev_val[3]);
      if (d->in_ptr_field)
 oprintf (d->of, "%*s  op (&(%s), cookie);\n", d->indent, "", d->val);
      else
 oprintf (d->of, "%*s  gt_pch_nx (&(%s), op, cookie);\n",
   d->indent, "", d->val);
      break;

    case TYPE_SCALAR:
      break;

    case TYPE_ARRAY:
    case TYPE_NONE:
    case TYPE_UNDEFINED:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 3903, __FUNCTION__));
    }
}
# 3914 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_local_func_for_structure (const_type_p orig_s, type_p s)
{
  struct walk_type_data d;



  if (s->u.s.base_class)
    return;

  memset (&d, 0, sizeof (d));
  d.of = get_output_file_for_structure (s);
  d.process_field = write_types_local_process_field;
  d.opt = s->u.s.opt;
  d.line = &s->u.s.line;
  d.bitmap = s->u.s.bitmap;
  d.prev_val[0] = d.prev_val[2] = "*x";
  d.prev_val[1] = "not valid postage";
  d.prev_val[3] = "x";
  d.val = "(*x)";
  d.fn_wants_lvalue = true;

  oprintf (d.of, "\n");
  oprintf (d.of, "void\n");
  oprintf (d.of, "gt_pch_p_");
  output_mangled_typename (d.of, orig_s);
  oprintf (d.of, " (ATTRIBUTE_UNUSED void *this_obj,\n"
    "\tvoid *x_p,\n"
    "\tATTRIBUTE_UNUSED gt_pointer_operator op,\n"
    "\tATTRIBUTE_UNUSED void *cookie)\n");
  oprintf (d.of, "{\n");
  oprintf (d.of, "  %s %s * x ATTRIBUTE_UNUSED = (%s %s *)x_p;\n",
    s->kind == TYPE_UNION ? "union" : "struct", s->u.s.tag,
    s->kind == TYPE_UNION ? "union" : "struct", s->u.s.tag);
  d.indent = 2;
  d.have_this_obj = true;

  if (s->kind != TYPE_USER_STRUCT)
    walk_type (s, &d);
  else
    {


      oprintf (d.of, "%*sif ((void *)(%s) == this_obj)\n", d.indent, "",
        d.prev_val[3]);
      oprintf (d.of, "%*s  gt_pch_nx (&(%s), op, cookie);\n",
        d.indent, "", d.val);
    }

  oprintf (d.of, "}\n");


  if (orig_s->kind == TYPE_USER_STRUCT)
    write_pch_user_walking_functions (s, &d);

  for (options_p o = s->u.s.opt; o; o = o->next)
    if (strcmp (o->name, "for_user") == 0)
      {
 write_pch_user_walking_for_structure_body (s, &d);
 break;
      }
}



static void
write_local (outf_p output_header, type_p structures)
{
  type_p s;

  if (!output_header)
    return;

  oprintf (output_header, "\n/* Local pointer-walking routines.  */\n");
  for (s = structures; s; s = s->next)
    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)
      {
 options_p opt;

 if (s->u.s.line.file == nullptr)
   continue;
  for (opt = s->u.s.opt; opt; opt = opt->next)
   if (strcmp (opt->name, "ptr_alias") == 0
       && opt->kind == OPTION_TYPE)
     {
       const_type_p const t = (const_type_p) opt->info.type;
       if (t->kind == TYPE_STRUCT
    || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)
  {
    oprintf (output_header, "#define gt_pch_p_");
    output_mangled_typename (output_header, s);
    oprintf (output_header, " gt_pch_p_");
    output_mangled_typename (output_header, t);
    oprintf (output_header, "\n");
  }
       else
  error_at_line (&s->u.s.line,
          "structure alias is not a structure");
       break;
     }
 if (opt)
   continue;


 oprintf (output_header, "extern void gt_pch_p_");
 output_mangled_typename (output_header, s);
 oprintf (output_header,
   "\n    (void *, void *, gt_pointer_operator, void *);\n");

 if (s->kind == TYPE_LANG_STRUCT)
   {
     type_p ss;
     for (ss = s->u.s.lang_struct; ss; ss = ss->next)
       write_local_func_for_structure (s, ss);
   }
 else
   write_local_func_for_structure (s, s);
      }
}
# 4052 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static int
contains_scalar_p (type_p t)
{
  switch (t->kind)
    {
    case TYPE_STRING:
    case TYPE_POINTER:
      return 0;
    case TYPE_ARRAY:
      return contains_scalar_p (t->u.a.p);
    case TYPE_USER_STRUCT:

      return 0;
    default:


      return 1;
    }
}



static void
put_mangled_filename (outf_p f, const input_file *inpf)
{



  const char *name = get_output_file_name ((const_cast<input_file*> ((inpf))));
  if (!f || !name)
    return;
  for (; *name != 0; name++)
    if ((_sch_istable[(*name) & 0xff] & (unsigned short)(_sch_isalnum)))
      oprintf (f, "%c", *name);
    else
      oprintf (f, "%c", '_');
}





static void
finish_root_table (struct flist *flp, const char *pfx, const char *lastname,
     const char *tname, const char *name)
{
  struct flist *fli2;

  for (fli2 = flp; fli2; fli2 = fli2->next)
    if (fli2->started_p)
      {
 oprintf (fli2->f, "  %s\n", lastname);
 oprintf (fli2->f, "};\n\n");
      }

  for (fli2 = flp; fli2 && base_files; fli2 = fli2->next)
    if (fli2->started_p)
      {
 lang_bitmap bitmap = get_lang_bitmap (fli2->file);
 int fnum;

 for (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)
   if (bitmap & 1)
     {
       oprintf (base_files[fnum],
         "extern const struct %s gt_%s_", tname, pfx);
       put_mangled_filename (base_files[fnum], fli2->file);
       oprintf (base_files[fnum], "[];\n");
     }
      }

  {
    size_t fnum;
    for (fnum = 0; base_files && fnum < num_lang_dirs; fnum++)
      oprintf (base_files[fnum],
        "EXPORTED_CONST struct %s * const %s[] = {\n", tname, name);
  }


  for (fli2 = flp; fli2; fli2 = fli2->next)
    if (fli2->started_p)
      {
 lang_bitmap bitmap = get_lang_bitmap (fli2->file);
 int fnum;

 fli2->started_p = 0;

 for (fnum = 0; base_files && bitmap != 0; fnum++, bitmap >>= 1)
   if (bitmap & 1)
     {
       oprintf (base_files[fnum], "  gt_%s_", pfx);
       put_mangled_filename (base_files[fnum], fli2->file);
       oprintf (base_files[fnum], ",\n");
     }
      }

  {
    size_t fnum;
    for (fnum = 0; base_files && fnum < num_lang_dirs; fnum++)
      {
 oprintf (base_files[fnum], "  NULL\n");
 oprintf (base_files[fnum], "};\n");
      }
  }
}



static void
finish_cache_funcs (flist *flp)
{
  struct flist *fli2;

  for (fli2 = flp; fli2; fli2 = fli2->next)
    if (fli2->started_p)
      {
 oprintf (fli2->f, "}\n\n");
      }

  for (fli2 = flp; fli2 && base_files; fli2 = fli2->next)
    if (fli2->started_p)
      {
 lang_bitmap bitmap = get_lang_bitmap (fli2->file);
 int fnum;

 for (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)
   if (bitmap & 1)
     {
       oprintf (base_files[fnum], "extern void gt_clear_caches_");
       put_mangled_filename (base_files[fnum], fli2->file);
       oprintf (base_files[fnum], " ();\n");
     }
      }

  for (size_t fnum = 0; base_files && fnum < num_lang_dirs; fnum++)
    oprintf (base_files[fnum], "void\ngt_clear_caches ()\n{\n");

  for (fli2 = flp; fli2; fli2 = fli2->next)
    if (fli2->started_p)
      {
 lang_bitmap bitmap = get_lang_bitmap (fli2->file);
 int fnum;

 fli2->started_p = 0;

 for (fnum = 0; base_files && bitmap != 0; fnum++, bitmap >>= 1)
   if (bitmap & 1)
     {
       oprintf (base_files[fnum], "  gt_clear_caches_");
       put_mangled_filename (base_files[fnum], fli2->file);
       oprintf (base_files[fnum], " ();\n");
     }
      }

  for (size_t fnum = 0; base_files && fnum < num_lang_dirs; fnum++)
    {
      oprintf (base_files[fnum], "}\n");
    }
}






static bool
start_root_entry (outf_p f, pair_p v, const char *name, struct fileloc *line)
{
  type_p ap;

  if (!v)
    {
      error_at_line (line, "`%s' is too complex to be a root", name);
      return false;
    }

  oprintf (f, "  {\n");
  oprintf (f, "    &%s,\n", name);
  oprintf (f, "    1");

  for (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)
    if (ap->u.a.len[0])
      oprintf (f, " * (%s)", ap->u.a.len);
    else if (ap == v->type)
      oprintf (f, " * ARRAY_SIZE (%s)", v->name);
  oprintf (f, ",\n");
  oprintf (f, "    sizeof (%s", v->name);
  for (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)
    oprintf (f, "[0]");
  oprintf (f, "),\n");
  return true;
}





static void
write_field_root (outf_p f, pair_p v, type_p type, const char *name,
    int has_length, struct fileloc *line,
    bool emit_pch, type_p field_type, const char *field_name)
{
  struct pair newv;




  if (v && type == v->type)
    {
      newv = *v;
      newv.type = field_type;
      newv.name = (libiberty_concat_ptr = (char *) __builtin_alloca(concat_length (v->name, ".", field_name, nullptr) + 1), concat_copy2 (v->name, ".", field_name, nullptr));
      v = &newv;
    }


  else if (field_type->kind == TYPE_ARRAY)
    v = nullptr;
  write_root (f, v, field_type, (libiberty_concat_ptr = (char *) __builtin_alloca(concat_length (name, ".", field_name, nullptr) + 1), concat_copy2 (name, ".", field_name, nullptr)),
       has_length, line, emit_pch);
}
# 4288 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,
     struct fileloc *line, bool emit_pch)
{
  switch (type->kind)
    {
    case TYPE_STRUCT:
      {
 pair_p fld;
 for (fld = type->u.s.fields; fld; fld = fld->next)
   {
     int skip_p = 0;
     const char *desc = nullptr;
     options_p o;

     for (o = fld->opt; o; o = o->next)
       if (strcmp (o->name, "skip") == 0)
  skip_p = 1;
       else if (strcmp (o->name, "desc") == 0
         && o->kind == OPTION_STRING)
  desc = o->info.string;
       else
  error_at_line (line,
          "field `%s' of global `%s' has unknown option `%s'",
          fld->name, name, o->name);

     if (skip_p)
       continue;
     else if (desc && fld->type->kind == TYPE_UNION)
       {
  pair_p validf = nullptr;
  pair_p ufld;

  for (ufld = fld->type->u.s.fields; ufld; ufld = ufld->next)
    {
      const char *tag = nullptr;
      options_p oo;
       for (oo = ufld->opt; oo; oo = oo->next)
        if (strcmp (oo->name, "tag") == 0
     && oo->kind == OPTION_STRING)
   tag = oo->info.string;
      if (tag == nullptr || strcmp (tag, desc) != 0)
        continue;
      if (validf != nullptr)
        error_at_line (line,
         "both `%s.%s.%s' and `%s.%s.%s' have tag `%s'",
         name, fld->name, validf->name,
         name, fld->name, ufld->name, tag);
      validf = ufld;
    }
  if (validf != nullptr)
    write_field_root (f, v, type, name, 0, line, emit_pch,
        validf->type,
        (libiberty_concat_ptr = (char *) __builtin_alloca(concat_length (fld->name, ".", validf->name, nullptr) + 1), concat_copy2 (fld->name, ".", validf->name, nullptr))
                               );
       }
     else if (desc)
       error_at_line (line,
        "global `%s.%s' has `desc' option but is not union",
        name, fld->name);
     else
       write_field_root (f, v, type, name, 0, line, emit_pch, fld->type,
    fld->name);
   }
      }
      break;

    case TYPE_ARRAY:
      {
 char *newname;
 newname = xasprintf ("%s[0]", name);
 write_root (f, v, type->u.a.p, newname, has_length, line, emit_pch);
 free (newname);
      }
      break;

    case TYPE_USER_STRUCT:
      error_at_line (line, "`%s' must be a pointer type, because it is "
              "a GC root and its type is marked with GTY((user))",
       v->name);
      break;

    case TYPE_POINTER:
      {
 const_type_p tp;

 if (!start_root_entry (f, v, name, line))
   return;

 tp = type->u.p;

 if (!has_length && union_or_struct_p (tp))
   {
     tp = get_ultimate_base_class (tp);
     const char *id_for_tag = filter_type_name (tp->u.s.tag);
     oprintf (f, "    &gt_ggc_mx_%s,\n", id_for_tag);
     if (emit_pch)
       oprintf (f, "    &gt_pch_nx_%s", id_for_tag);
     else
       oprintf (f, "    NULL");
     if (id_for_tag != tp->u.s.tag)
       free ((const_cast<char *> ((id_for_tag))));
   }
 else if (has_length
   && (tp->kind == TYPE_POINTER || union_or_struct_p (tp)))
   {
     oprintf (f, "    &gt_ggc_ma_%s,\n", name);
     if (emit_pch)
       oprintf (f, "    &gt_pch_na_%s", name);
     else
       oprintf (f, "    NULL");
   }
 else
   {
     error_at_line (line,
      "global `%s' is pointer to unimplemented type",
      name);
   }
 oprintf (f, "\n  },\n");
      }
      break;

    case TYPE_STRING:
      {
 if (!start_root_entry (f, v, name, line))
   return;

 oprintf (f, "    (gt_pointer_walker) &gt_ggc_m_S,\n");
 oprintf (f, "    (gt_pointer_walker) &gt_pch_n_S\n");
 oprintf (f, "  },\n");
      }
      break;

    case TYPE_SCALAR:
      break;

    case TYPE_NONE:
    case TYPE_UNDEFINED:
    case TYPE_UNION:
    case TYPE_LANG_STRUCT:
      error_at_line (line, "global `%s' is unimplemented type", name);
    }
}



static void
write_array (outf_p f, pair_p v, const struct write_types_data *wtd)
{
  struct walk_type_data d;
  char *prevval3;

  memset (&d, 0, sizeof (d));
  d.of = f;
  d.cookie = wtd;
  d.indent = 2;
  d.line = &v->line;
  d.opt = v->opt;
  d.bitmap = get_lang_bitmap (v->line.file);

  d.prev_val[3] = prevval3 = xasprintf ("&%s", v->name);

  if (wtd->param_prefix)
    {
      oprintf (f, "static void gt_%sa_%s\n", wtd->param_prefix, v->name);
      oprintf (f, "    (void *, void *, gt_pointer_operator, void *);\n");
      oprintf (f, "static void gt_%sa_%s (ATTRIBUTE_UNUSED void *this_obj,\n",
        wtd->param_prefix, v->name);
      oprintf (d.of,
        "      ATTRIBUTE_UNUSED void *x_p,\n"
        "      ATTRIBUTE_UNUSED gt_pointer_operator op,\n"
        "      ATTRIBUTE_UNUSED void * cookie)\n");
      oprintf (d.of, "{\n");
      d.prev_val[0] = d.prev_val[1] = d.prev_val[2] = d.val = v->name;
      d.process_field = write_types_local_process_field;
      d.have_this_obj = true;
      walk_type (v->type, &d);
      oprintf (f, "}\n\n");
    }

  d.opt = v->opt;
  oprintf (f, "static void gt_%sa_%s (void *);\n", wtd->prefix, v->name);
  oprintf (f, "static void\ngt_%sa_%s (ATTRIBUTE_UNUSED void *x_p)\n",
    wtd->prefix, v->name);
  oprintf (f, "{\n");
  d.prev_val[0] = d.prev_val[1] = d.prev_val[2] = d.val = v->name;
  d.process_field = write_types_process_field;
  d.have_this_obj = false;
  walk_type (v->type, &d);
  free (prevval3);
  oprintf (f, "}\n\n");
}



static void
write_roots (pair_p variables, bool emit_pch)
{
  pair_p v;
  struct flist *flp = nullptr;

  for (v = variables; v; v = v->next)
    {
      outf_p f =
 get_output_file_with_visibility ((const_cast<input_file*> ((v->line.file)))
                        );
      struct flist *fli;
      const char *length = nullptr;
      int deletable_p = 0;
      options_p o;
      for (o = v->opt; o; o = o->next)
 if (strcmp (o->name, "length") == 0
     && o->kind == OPTION_STRING)
   length = o->info.string;
 else if (strcmp (o->name, "deletable") == 0)
   deletable_p = 1;
 else if (strcmp (o->name, "cache") == 0)
   ;
 else
   error_at_line (&v->line,
    "global `%s' has unknown option `%s'",
    v->name, o->name);

      for (fli = flp; fli; fli = fli->next)
 if (fli->f == f && f)
   break;
      if (fli == nullptr)
 {
   fli = ((struct flist *) xmalloc (sizeof (struct flist)));
   fli->f = f;
   fli->next = flp;
   fli->started_p = 0;
   fli->file = v->line.file;
   ((void)(!(fli->file) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4521, __FUNCTION__), 0 : 0));
   flp = fli;

   oprintf (f, "\n/* GC roots.  */\n\n");
 }

      if (!deletable_p
   && length
   && v->type->kind == TYPE_POINTER
   && (v->type->u.p->kind == TYPE_POINTER
       || v->type->u.p->kind == TYPE_STRUCT))
 {
   write_array (f, v, &ggc_wtd);
   write_array (f, v, &pch_wtd);
 }
    }

  for (v = variables; v; v = v->next)
    {
      outf_p f = get_output_file_with_visibility ((const_cast<input_file*> ((v->line.file)))
                          );
      struct flist *fli;
      int skip_p = 0;
      int length_p = 0;
      options_p o;

      for (o = v->opt; o; o = o->next)
 if (strcmp (o->name, "length") == 0)
   length_p = 1;
 else if (strcmp (o->name, "deletable") == 0)
   skip_p = 1;

      if (skip_p)
 continue;

      for (fli = flp; fli; fli = fli->next)
 if (fli->f == f)
   break;
      if (!fli->started_p)
 {
   fli->started_p = 1;

   oprintf (f, "EXPORTED_CONST struct ggc_root_tab gt_ggc_r_");
   put_mangled_filename (f, v->line.file);
   oprintf (f, "[] = {\n");
 }

      write_root (f, v, v->type, v->name, length_p, &v->line, emit_pch);
    }

  finish_root_table (flp, "ggc_r", "LAST_GGC_ROOT_TAB", "ggc_root_tab",
       "gt_ggc_rtab");

  for (v = variables; v; v = v->next)
    {
      outf_p f = get_output_file_with_visibility ((const_cast<input_file*> ((v->line.file)))
                          );
      struct flist *fli;
      int skip_p = 1;
      options_p o;

      for (o = v->opt; o; o = o->next)
 if (strcmp (o->name, "deletable") == 0)
   skip_p = 0;

      if (skip_p)
 continue;

      for (fli = flp; fli; fli = fli->next)
 if (fli->f == f)
   break;
      if (!fli->started_p)
 {
   fli->started_p = 1;

   oprintf (f, "EXPORTED_CONST struct ggc_root_tab gt_ggc_rd_");
   put_mangled_filename (f, v->line.file);
   oprintf (f, "[] = {\n");
 }

      oprintf (f, "  { &%s, 1, sizeof (%s), NULL, NULL },\n",
        v->name, v->name);
    }

  finish_root_table (flp, "ggc_rd", "LAST_GGC_ROOT_TAB", "ggc_root_tab",
       "gt_ggc_deletable_rtab");

  for (v = variables; v; v = v->next)
    {
      outf_p f = get_output_file_with_visibility ((const_cast<input_file*> ((v->line.file)))
                          );
      struct flist *fli;
      bool cache = false;
      options_p o;

      for (o = v->opt; o; o = o->next)
 if (strcmp (o->name, "cache") == 0)
   cache = true;
       if (!cache)
 continue;

      for (fli = flp; fli; fli = fli->next)
 if (fli->f == f)
   break;
      if (!fli->started_p)
 {
   fli->started_p = 1;

   oprintf (f, "void\ngt_clear_caches_");
   put_mangled_filename (f, v->line.file);
   oprintf (f, " ()\n{\n");
 }

      oprintf (f, "  gt_cleare_cache (%s);\n", v->name);
    }

  finish_cache_funcs (flp);

  if (!emit_pch)
    return;

  for (v = variables; v; v = v->next)
    {
      outf_p f = get_output_file_with_visibility ((const_cast<input_file*> ((v->line.file)))
                          );
      struct flist *fli;
      int skip_p = 0;
      options_p o;

      for (o = v->opt; o; o = o->next)
 if (strcmp (o->name, "deletable") == 0)
   {
     skip_p = 1;
     break;
   }

      if (skip_p)
 continue;

      if (!contains_scalar_p (v->type))
 continue;

      for (fli = flp; fli; fli = fli->next)
 if (fli->f == f)
   break;
      if (!fli->started_p)
 {
   fli->started_p = 1;

   oprintf (f, "EXPORTED_CONST struct ggc_root_tab gt_pch_rs_");
   put_mangled_filename (f, v->line.file);
   oprintf (f, "[] = {\n");
 }

      oprintf (f, "  { &%s, 1, sizeof (%s), NULL, NULL },\n",
        v->name, v->name);
    }

  finish_root_table (flp, "pch_rs", "LAST_GGC_ROOT_TAB", "ggc_root_tab",
       "gt_pch_scalar_rtab");
}
# 4692 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
static void
dump_typekind (int indent, enum typekind kind)
{
  printf ("%*ckind = ", indent, ' ');
  switch (kind)
    {
    case TYPE_SCALAR:
      printf ("TYPE_SCALAR");
      break;
    case TYPE_STRING:
      printf ("TYPE_STRING");
      break;
    case TYPE_STRUCT:
      printf ("TYPE_STRUCT");
      break;
    case TYPE_UNDEFINED:
      printf ("TYPE_UNDEFINED");
      break;
    case TYPE_USER_STRUCT:
      printf ("TYPE_USER_STRUCT");
      break;
    case TYPE_UNION:
      printf ("TYPE_UNION");
      break;
    case TYPE_POINTER:
      printf ("TYPE_POINTER");
      break;
    case TYPE_ARRAY:
      printf ("TYPE_ARRAY");
      break;
    case TYPE_LANG_STRUCT:
      printf ("TYPE_LANG_STRUCT");
      break;
    default:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4726, __FUNCTION__));
    }
  printf ("\n");
}



static void
dump_gc_used (int indent, enum gc_used_enum gc_used)
{
  printf ("%*cgc_used = ", indent, ' ');
  switch (gc_used)
    {
    case GC_UNUSED:
      printf ("GC_UNUSED");
      break;
    case GC_USED:
      printf ("GC_USED");
      break;
    case GC_MAYBE_POINTED_TO:
      printf ("GC_MAYBE_POINTED_TO");
      break;
    case GC_POINTED_TO:
      printf ("GC_POINTED_TO");
      break;
    default:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4752, __FUNCTION__));
    }
  printf ("\n");
}



static void
dump_options (int indent, options_p opt)
{
  options_p o;
  printf ("%*coptions = ", indent, ' ');
  o = opt;
  while (o)
    {
      switch (o->kind)
 {
 case OPTION_STRING:
   printf ("%s:string %s ", o->name, o->info.string);
   break;
 case OPTION_TYPE:
   printf ("%s:type ", o->name);
   dump_type (indent+1, o->info.type);
   break;
 case OPTION_NESTED:
   printf ("%s:nested ", o->name);
   break;
 case OPTION_NONE:
   (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4780, __FUNCTION__));
 }
      o = o->next;
    }
  printf ("\n");
}



static void
dump_fileloc (int indent, struct fileloc line)
{
  printf ("%*cfileloc: file = %s, line = %d\n", indent, ' ',
   get_input_file_name (line.file),
   line.line);
}




static void
dump_type_u_s (int indent, type_p t)
{
  pair_p fields;

  ((void)(!(union_or_struct_p (t)) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4805, __FUNCTION__), 0 : 0));
  printf ("%*cu.s.tag = %s\n", indent, ' ', t->u.s.tag);
  dump_fileloc (indent, t->u.s.line);
  printf ("%*cu.s.fields =\n", indent, ' ');
  fields = t->u.s.fields;
  while (fields)
    {
      dump_pair (indent + 2, fields);
      fields = fields->next;
    }
  printf ("%*cend of fields of type %p\n", indent, ' ', (void *) t);
  dump_options (indent, t->u.s.opt);
  printf ("%*cu.s.bitmap = %X\n", indent, ' ', t->u.s.bitmap);
  if (t->kind == TYPE_LANG_STRUCT)
    {
      printf ("%*cu.s.lang_struct:\n", indent, ' ');
      dump_type_list (indent + 2, t->u.s.lang_struct);
    }
}



static void
dump_type_u_a (int indent, type_p t)
{
  ((void)(!(t->kind == TYPE_ARRAY) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4830, __FUNCTION__), 0 : 0));
  printf ("%*clen = %s, u.a.p:\n", indent, ' ', t->u.a.len);
  dump_type_list (indent + 2, t->u.a.p);
}



static void
dump_type_list (int indent, type_p t)
{
  type_p p = t;
  while (p)
    {
      dump_type (indent, p);
      p = p->next;
    }
}

static htab_t seen_types;



static void
dump_type (int indent, type_p t)
{
  void * *slot;

  printf ("%*cType at %p: ", indent, ' ', (void *) t);
  if (t->kind == TYPE_UNDEFINED)
    {
      ((void)(!(t->gc_used == GC_UNUSED) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4860, __FUNCTION__), 0 : 0));
      printf ("undefined.\n");
      return;
    }

  if (seen_types == nullptr)
    seen_types = htab_create (100, htab_hash_pointer, htab_eq_pointer, nullptr);

  slot = htab_find_slot (seen_types, t, INSERT);
  if (*slot != nullptr)
    {
      printf ("already seen.\n");
      return;
    }
  *slot = t;
  printf ("\n");

  dump_typekind (indent, t->kind);
  printf ("%*cpointer_to = %p\n", indent + 2, ' ',
   (void *) t->pointer_to);
  dump_gc_used (indent + 2, t->gc_used);
  switch (t->kind)
    {
    case TYPE_SCALAR:
      printf ("%*cscalar_is_char = %s\n", indent + 2, ' ',
       t->u.scalar_is_char ? "true" : "false");
      break;
    case TYPE_STRING:
      break;
    case TYPE_STRUCT:
    case TYPE_UNION:
    case TYPE_LANG_STRUCT:
    case TYPE_USER_STRUCT:
      dump_type_u_s (indent + 2, t);
      break;
    case TYPE_POINTER:
      printf ("%*cp:\n", indent + 2, ' ');
      dump_type (indent + 2, t->u.p);
      break;
    case TYPE_ARRAY:
      dump_type_u_a (indent + 2, t);
      break;
    default:
      (fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 4903, __FUNCTION__));
    }
  printf ("%*cEnd of type at %p\n", indent, ' ', (void *) t);
}



static void
dump_pair (int indent, pair_p p)
{
  printf ("%*cpair: name = %s\n", indent, ' ', p->name);
  dump_type (indent, p->type);
  dump_fileloc (indent, p->line);
  dump_options (indent, p->opt);
  printf ("%*cEnd of pair %s\n", indent, ' ', p->name);
}



static void
dump_pair_list (const char *name, pair_p pp)
{
  pair_p p;
  printf ("%s:\n", name);
  for (p = pp; p != nullptr; p = p->next)
    dump_pair (0, p);
  printf ("End of %s\n\n", name);
}



static void
dump_structures (const char *name, type_p structures)
{
  printf ("%s:\n", name);
  dump_type_list (0, structures);
  printf ("End of %s\n\n", name);
}





static void
dump_everything (void)
{
  dump_pair_list ("typedefs", typedefs);
  dump_structures ("structures", structures);
  dump_pair_list ("variables", variables);


  htab_delete (seen_types);
}




static const struct option gengtype_long_options[] = {
  {"help", 0, nullptr, 'h'},
  {"version", 0, nullptr, 'V'},
  {"verbose", 0, nullptr, 'v'},
  {"dump", 0, nullptr, 'd'},
  {"debug", 0, nullptr, 'D'},
  {"plugin", 1, nullptr, 'P'},
  {"srcdir", 1, nullptr, 'S'},
  {"backupdir", 1, nullptr, 'B'},
  {"inputs", 1, nullptr, 'I'},
  {"read-state", 1, nullptr, 'r'},
  {"write-state", 1, nullptr, 'w'},

  {nullptr, 0, nullptr, 0},
};


static void
print_usage (void)
{
  printf ("Usage: %s\n", progname);
  printf ("\t -h | --help " " \t# Give this help.\n");
  printf ("\t -D | --debug "
   " \t# Give debug output to debug %s itself.\n", progname);
  printf ("\t -V | --version " " \t# Give version information.\n");
  printf ("\t -v | --verbose  \t# Increase verbosity.  Can be given several times.\n");
  printf ("\t -d | --dump " " \t# Dump state for debugging.\n");
  printf ("\t -P | --plugin <output-file> <plugin-src> ... "
   " \t# Generate for plugin.\n");
  printf ("\t -S | --srcdir <GCC-directory> "
   " \t# Specify the GCC source directory.\n");
  printf ("\t -B | --backupdir <directory> "
   " \t# Specify the backup directory for updated files.\n");
  printf ("\t -I | --inputs <input-list> "
   " \t# Specify the file with source files list.\n");
  printf ("\t -w | --write-state <state-file> " " \t# Write a state file.\n");
  printf ("\t -r | --read-state <state-file> " " \t# Read a state file.\n");
}

static void
print_version (void)
{
  printf ("%s %s%s\n", progname, pkgversion_string, version_string);
  printf ("Report bugs: %s\n", bug_report_url);
}


static void
parse_program_options (int argc, char **argv)
{
  int opt = -1;
  while ((opt = getopt_long (argc, argv, "hVvdP:S:B:I:w:r:D",
        gengtype_long_options, nullptr)) >= 0)
    {
      switch (opt)
 {
 case 'h':
   print_usage ();
   break;
 case 'V':
   print_version ();
   break;
 case 'd':
   do_dump = 1;
   break;
 case 'D':
   do_debug = 1;
   break;
 case 'v':
   verbosity_level++;
   break;
 case 'P':
   if (optarg)
     plugin_output_filename = optarg;
   else
     fatal ("missing plugin output file name");
   break;
 case 'S':
   if (optarg)
     srcdir = optarg;
   else
     fatal ("missing source directory");
   srcdir_len = strlen (srcdir);
   break;
 case 'B':
   if (optarg)
     backup_dir = optarg;
   else
     fatal ("missing backup directory");
   break;
 case 'I':
   if (optarg)
     inputlist = optarg;
   else
     fatal ("missing input list");
   break;
 case 'r':
   if (optarg)
     read_state_filename = optarg;
   else
     fatal ("missing read state file");
   do {if (do_debug) fprintf (
# 5061 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
  stderr
# 5061 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
  , "%s:%d: " "read state %s\n" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5061, optarg);} while (0);
   break;
 case 'w':
   do {if (do_debug) fprintf (
# 5064 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
  stderr
# 5064 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
  , "%s:%d: " "write state %s\n" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5064, optarg);} while (0);
   if (optarg)
     write_state_filename = optarg;
   else
     fatal ("missing write state file");
   break;
 default:
   fprintf (
# 5071 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
           stderr
# 5071 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
                 , "%s: unknown flag '%c'\n", progname, opt);
   print_usage ();
   fatal ("unexpected flag");
 }
    };
  if (plugin_output_filename)
    {

      int i = 0;
      if (optind >= argc)
 fatal ("no source files given in plugin mode");
      nb_plugin_files = argc - optind;
      plugin_files = ((input_file* *) xmalloc (sizeof (input_file*) * (nb_plugin_files)));
      for (i = 0; i < (int) nb_plugin_files; i++)
 {
   char *name = argv[i + optind];
   plugin_files[i] = input_file_by_name (name);
 }
    }
}






static htab_t input_file_htab;


input_file*
input_file_by_name (const char* name)
{
  void ** slot;
  input_file* f = nullptr;
  int namlen = 0;
  if (!name)
    return nullptr;
  namlen = strlen (name);
  f = ((input_file *) xcalloc (1, (sizeof (input_file)+namlen+2)));
  f->inpbitmap = 0;
  f->inpoutf = nullptr;
  f->inpisplugin = false;
  strcpy (f->inpname, name);
  slot = htab_find_slot (input_file_htab, f, INSERT);
  ((void)(!(slot != nullptr) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5115, __FUNCTION__), 0 : 0));
  if (*slot)
    {

      free (f);
      return (input_file*)(*slot);
    }

  *slot = f;
  return f;
    }


static hashval_t
htab_hash_inputfile (const void *p)
{
  const input_file *inpf = (const input_file *) p;
  ((void)(!(inpf) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5132, __FUNCTION__), 0 : 0));
  return htab_hash_string (get_input_file_name (inpf));
}

static int
htab_eq_inputfile (const void *x, const void *y)
{
  const input_file *inpfx = (const input_file *) x;
  const input_file *inpfy = (const input_file *) y;
  ((void)(!(inpfx != nullptr && inpfy != nullptr) ? fancy_abort ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5141, __FUNCTION__), 0 : 0));
  return !filename_cmp (get_input_file_name (inpfx), get_input_file_name (inpfy));
}


int
main (int argc, char **argv)
{
  size_t i;
  static struct fileloc pos = { nullptr, 0 };
  outf_p output_header;


  progname = "gengtype";

  input_file_htab =
    htab_create (800, htab_hash_inputfile, htab_eq_inputfile, nullptr);

  this_file = input_file_by_name ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c");
  system_h_file = input_file_by_name ("system.h");

  scalar_nonchar.u.scalar_is_char = false;
  scalar_char.u.scalar_is_char = true;

  parse_program_options (argc, argv);

  if (do_debug)
    {
      time_t now = (time_t) 0;
      time (&now);
      do {if (do_debug) fprintf (
# 5171 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
     stderr
# 5171 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     , "%s:%d: " "gengtype started pid %d at %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5171, (int) getpid (), ctime (&now));} while (0)
                                 ;
    }


  do {if (do_debug) fprintf (
# 5176 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
 stderr
# 5176 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
 , "%s:%d: " "inputlist %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5176, inputlist);} while (0);
  if (read_state_filename)
    {
      if (inputlist)
 fatal ("input list %s cannot be given with a read state file %s",
        inputlist, read_state_filename);
      read_state (read_state_filename);
      do {if (do_debug) dbgprint_count_type_at ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5183, "structures after read_state", structures);}while (0);
    }
  else if (inputlist)
    {





      do { pos.file = this_file; pos.line = 5192; do_scalar_typedef ("CUMULATIVE_ARGS", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5193; do_scalar_typedef ("REAL_VALUE_TYPE", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5194; do_scalar_typedef ("FIXED_VALUE_TYPE", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5195; do_scalar_typedef ("double_int", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5196; do_scalar_typedef ("poly_int64_pod", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5197; do_scalar_typedef ("offset_int", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5198; do_scalar_typedef ("widest_int", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5199; do_scalar_typedef ("int64_t", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5200; do_scalar_typedef ("poly_int64", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5201; do_scalar_typedef ("uint64_t", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5202; do_scalar_typedef ("uint8", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5203; do_scalar_typedef ("uintptr_t", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5204; do_scalar_typedef ("jword", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5205; do_scalar_typedef ("JCF_u2", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5206; do_scalar_typedef ("void", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5207; do_scalar_typedef ("machine_mode", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5208; do_scalar_typedef ("fixed_size_mode", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5209; do_scalar_typedef ("CONSTEXPR", &pos);} while (0);
      do { pos.file = this_file; pos.line = 5210; do_typedef ("PTR", create_pointer (resolve_typedef ("void", &pos)), &pos);} while (0)

             ;

      read_input_list (inputlist);
      for (i = 0; i < num_gt_files; i++)
 {
   parse_file (get_input_file_name (gt_files[i]));
   do {if (do_debug) fprintf (
# 5218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
  stderr
# 5218 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
  , "%s:%d: " "parsed file #%d %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5218, (int) i, get_input_file_name (gt_files[i]));} while (0)
                                                  ;
 }
      if (verbosity_level >= 1)
 printf ("%s parsed %d files with %d GTY types\n",
  progname, (int) num_gt_files, type_count);

      do {if (do_debug) dbgprint_count_type_at ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5225, "structures after parsing", structures);}while (0);
    }
  else
    fatal ("either an input list or a read state file should be given");
  if (hit_error)
    return 1;


  if (plugin_output_filename)
    {
      size_t ix = 0;


      if (!read_state_filename)
 fatal ("No read state given in plugin mode for %s",
        plugin_output_filename);

      if (nb_plugin_files == 0 || !plugin_files)
 fatal ("No plugin files given in plugin mode for %s",
        plugin_output_filename);


      for (ix = 0; ix < nb_plugin_files; ix++)
 {
   input_file* pluginput = plugin_files [ix];
   pluginput->inpisplugin = true;
   parse_file (get_input_file_name (pluginput));
 }
      if (hit_error)
 return 1;

      plugin_output = create_file ("GCC", plugin_output_filename);
      do {if (do_debug) fprintf (
# 5257 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
     stderr
# 5257 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     , "%s:%d: " "created plugin_output %p named %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5257, (void *) plugin_output, plugin_output->name);} while (0)
                                               ;
    }
  else
    {
      if (!srcdir)
 fatal ("gengtype needs a source directory in normal mode");
    }
  if (hit_error)
    return 1;

  gen_rtx_next ();

  set_gc_used (variables);

  for (type_p t = structures; t; t = t->next)
    {
      bool for_user = false;
      for (options_p o = t->u.s.opt; o; o = o->next)
 if (strcmp (o->name, "for_user") == 0)
   {
     for_user = true;
     break;
   }

      if (for_user)
 set_gc_used_type (t, GC_POINTED_TO);
    }



  if (write_state_filename)
    {
      do {if (do_debug) dbgprint_count_type_at ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5290, "structures before write_state", structures);}while (0);

      if (hit_error)
 fatal ("didn't write state file %s after errors",
        write_state_filename);

      do {if (do_debug) fprintf (
# 5296 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c" 3 4
     stderr
# 5296 "/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"
     , "%s:%d: " "before write_state %s" "\n", lbasename ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c"),5296, write_state_filename);} while (0);
      write_state (write_state_filename);

      if (do_dump)
 dump_everything ();



      if (hit_error)
 return 1;
      else
 return 0;
    }


  open_base_files ();

  output_header = plugin_output ? plugin_output : header_file;
  do {if (do_debug) dbgprint_count_type_at ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5314, "structures before write_types outputheader", structures);}while (0)
                    ;

  write_types (output_header, structures, &ggc_wtd);
  if (plugin_files == nullptr)
    {
      do {if (do_debug) dbgprint_count_type_at ("/home/giulianob/gcc_git_gnu/gcc/gcc/gengtype.c", 5320, "structures before write_types headerfil", structures);}while (0)
                 ;
      write_types (header_file, structures, &pch_wtd);
      write_local (header_file, structures);
    }
  write_roots (variables, plugin_files == nullptr);
  write_rtx_next ();
  close_output_files ();

  if (do_dump)
    dump_everything ();



  if (hit_error)
    return 1;
  return 0;
}
